# 签名验证合约

本教程实现了一个基于签名的gas高效访问系统,用于Web3活动。使用 `ecrecover` 在链上验证链下签名,避免存储白名单。涵盖消息哈希、以太坊签名消息前缀和签名恢复。

## 关键概念

### 状态变量
```solidity
string public eventName;
address public organizer;
uint256 public eventDate;
uint256 public maxAttendees;
uint256 public attendeeCount;
bool public isEventActive;

mapping(address => bool) public hasAttended;
```

### 事件
```solidity
event EventCreated(string name, uint256 date, uint256 maxAttendees);
event AttendeeCheckedIn(address attendee, uint256 timestamp);
event EventStatusChanged(bool isActive);
```

### 构造函数
```solidity
constructor(string memory _eventName, uint256 _eventDate_unix, uint256 _maxAttendees) {
    eventName = _eventName;
    organizer = msg.sender;
    eventDate = _eventDate_unix;
    maxAttendees = _maxAttendees;
    isEventActive = true;
    
    emit EventCreated(_eventName, _eventDate_unix, _maxAttendees);
}
```

### 修饰符
```solidity
modifier onlyOrganizer() {
    require(msg.sender == organizer, "Not the organizer");
    _;
}
```

### 设置活动状态
```solidity
function setEventStatus(bool _isActive) external onlyOrganizer {
    isEventActive = _isActive;
    emit EventStatusChanged(_isActive);
}
```

### 获取消息哈希
```solidity
function getMessageHash(address _attendee) public view returns (bytes32) {
    return keccak256(abi.encodePacked(address(this), eventName, _attendee));
}
```

### 获取以太坊签名消息哈希
```solidity
function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {
    return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _messageHash));
}
```

### 验证签名
```solidity
function verifySignature(address _attendee, bytes memory _signature) public view returns (bool) {
    bytes32 messageHash = getMessageHash(_attendee);
    bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);
    return recoverSigner(ethSignedMessageHash, _signature) == organizer;
}
```

### 恢复签名者
```solidity
function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) 
    public pure returns (address) 
{
    require(_signature.length == 65, "Invalid signature length");
    
    bytes32 r;
    bytes32 s;
    uint8 v;
    
    assembly {
        r := mload(add(_signature, 32))
        s := mload(add(_signature, 64))
        v := byte(0, mload(add(_signature, 96)))
    }
    
    return ecrecover(_ethSignedMessageHash, v, r, s);
}
```

### 签到
```solidity
function checkIn(bytes memory _signature) external {
    require(isEventActive, "Event is not active");
    require(block.timestamp <= eventDate + 1 days, "Event has ended");
    require(!hasAttended[msg.sender], "Attendee has already checked in");
    require(attendeeCount < maxAttendees, "Maximum attendees reached");
    require(verifySignature(msg.sender, _signature), "Invalid signature");
    
    hasAttended[msg.sender] = true;
    attendeeCount++;
    
    emit AttendeeCheckedIn(msg.sender, block.timestamp);
}
```

## 核心知识点

### 签名验证流程

1. **创建消息哈希**:
   ```solidity
   keccak256(abi.encodePacked(contract, eventName, attendee))
   ```

2. **添加以太坊前缀**:
   ```solidity
   keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash))
   ```

3. **分解签名**:
   - 签名包含 `r`, `s`, `v` 三部分
   - 总长度65字节
   - 使用内联汇编提取

4. **恢复签名者**:
   ```solidity
   ecrecover(ethSignedMessageHash, v, r, s)
   ```

### 为什么使用签名?

- **节省Gas**: 不需要在链上存储白名单
- **灵活性**: 组织者可以链下签名,用户链上验证
- **安全性**: 只有持有签名的人才能签到
- **隐私性**: 参与者列表不需要公开

### 签名组件

- **v**: 恢复ID (27或28)
- **r**: 签名的前32字节
- **s**: 签名的后32字节

### 以太坊签名消息前缀

`\x19Ethereum Signed Message:\n32` 用于防止签名重放攻击,确保签名只能用于以太坊消息。

### 内联汇编

```solidity
assembly {
    r := mload(add(_signature, 32))
    s := mload(add(_signature, 64))
    v := byte(0, mload(add(_signature, 96)))
}
```

直接从内存中读取签名组件,比Solidity原生操作更高效。

