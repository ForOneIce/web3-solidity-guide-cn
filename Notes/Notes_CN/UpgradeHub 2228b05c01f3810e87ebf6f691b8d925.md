# 升级中心合约

本教程介绍了使用代理模式的可升级智能合约。构建了一个 `SubscriptionStorage`(代理)和两个逻辑合约(`SubscriptionLogicV1`、`SubscriptionLogicV2`)来演示无需数据迁移的无缝升级。在fallback函数中使用内联汇编的 `delegatecall`。

## 关键概念

### 存储布局
```solidity
contract SubscriptionStorageLayout {
    address public logicContract;
    address public owner;
    
    struct Subscription {
        uint8 planId;
        uint256 expiry;
        bool paused;
    }
    
    mapping(address => Subscription) public subscriptions;
    mapping(uint8 => uint256) public planPrices;
    mapping(uint8 => uint256) public planDuration;
}
```

### 代理合约
```solidity
contract SubscriptionStorage is SubscriptionStorageLayout {
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor(address _logicContract) {
        owner = msg.sender;
        logicContract = _logicContract;
    }
    
    function upgradeTo(address _newLogic) external onlyOwner {
        logicContract = _newLogic;
    }
    
    fallback() external payable {
        address impl = logicContract;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
    
    receive() external payable {}
}
```

### 逻辑合约 V1
```solidity
contract SubscriptionLogicV1 is SubscriptionStorageLayout {
    function addPlan(uint8 planId, uint256 price, uint256 duration) external {
        planPrices[planId] = price;
        planDuration[planId] = duration;
    }
    
    function subscribe(uint8 planId) external payable {
        require(planPrices[planId] > 0, "Invalid plan");
        require(msg.value >= planPrices[planId], "Insufficient payment");
        
        Subscription storage s = subscriptions[msg.sender];
        
        if (block.timestamp < s.expiry) {
            s.expiry += planDuration[planId];
        } else {
            s.expiry = block.timestamp + planDuration[planId];
        }
        
        s.planId = planId;
        s.paused = false;
    }
    
    function isActive(address user) external view returns (bool) {
        Subscription storage s = subscriptions[user];
        return (block.timestamp < s.expiry && !s.paused);
    }
}
```

### 逻辑合约 V2 (新功能)
```solidity
contract SubscriptionLogicV2 is SubscriptionStorageLayout {
    // 继承V1的所有功能...
    
    function addPlan(uint8 planId, uint256 price, uint256 duration) external {
        planPrices[planId] = price;
        planDuration[planId] = duration;
    }
    
    function subscribe(uint8 planId) external payable {
        require(planPrices[planId] > 0, "Invalid plan");
        require(msg.value >= planPrices[planId], "Insufficient payment");
        
        Subscription storage s = subscriptions[msg.sender];
        
        if (block.timestamp < s.expiry) {
            s.expiry += planDuration[planId];
        } else {
            s.expiry = block.timestamp + planDuration[planId];
        }
        
        s.planId = planId;
        s.paused = false;
    }
    
    function isActive(address user) external view returns (bool) {
        Subscription storage s = subscriptions[user];
        return (block.timestamp < s.expiry && !s.paused);
    }
    
    // V2 新功能
    function pauseAccount(address user) external {
        subscriptions[user].paused = true;
    }
    
    function resumeAccount(address user) external {
        subscriptions[user].paused = false;
    }
}
```

## 核心知识点

### 代理模式架构

1. **代理合约** (SubscriptionStorage):
   - 存储所有数据
   - 将调用委托给逻辑合约
   - 可以升级逻辑合约地址

2. **逻辑合约** (V1, V2):
   - 包含业务逻辑
   - 不存储数据
   - 可以被替换

### Delegatecall

- 在调用者的上下文中执行代码
- 使用调用者的存储
- `msg.sender` 和 `msg.value` 保持不变

### Fallback函数中的内联汇编

```solidity
assembly {
    // 复制调用数据
    calldatacopy(0, 0, calldatasize())
    
    // 调用逻辑合约
    let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
    
    // 复制返回数据
    returndatacopy(0, 0, returndatasize())
    
    // 返回或回退
    switch result
    case 0 { revert(0, returndatasize()) }
    default { return(0, returndatasize()) }
}
```

### 存储布局

- **关键**: 代理和逻辑合约必须有相同的存储布局
- 使用共同的父合约 (`SubscriptionStorageLayout`)
- 变量声明顺序必须完全相同

### 升级流程

1. 部署新的逻辑合约 (V2)
2. 调用代理的 `upgradeTo(newLogicAddress)`
3. 所有后续调用使用新逻辑
4. 数据保持不变

### 优势

- **数据持久性**: 升级不影响现有数据
- **灵活性**: 可以添加新功能或修复bug
- **用户友好**: 合约地址不变

### 注意事项

- 存储布局必须兼容
- 不能更改现有变量的类型或顺序
- 只能在末尾添加新变量

