# 预购代币合约

本教程在 `SimpleERC20` 代币之上构建了一个代币销售合约。涵盖设置销售参数、处理购买、在销售期间锁定转账以及完成销售。需要将 `SimpleERC20` 函数修改为 `virtual`。

## 关键概念

### 修改 SimpleERC20 为 Virtual
```solidity
function transfer(address _to, uint256 _value) public virtual returns (bool);
function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool);
```

### 代币销售合约
```solidity
contract SimplifiedTokenSale is SimpleERC20 {
    uint256 public tokenPrice;
    uint256 public saleStartTime;
    uint256 public saleEndTime;
    uint256 public minPurchase;
    uint256 public maxPurchase;
    uint256 public totalRaised;
    address public projectOwner;
    bool public finalized = false;
    bool private initialTransferDone = false;
    
    event TokensPurchased(address indexed buyer, uint256 etherAmount, uint256 tokenAmount);
    event SaleFinalized(uint256 totalRaised, uint256 totalTokensSold);
}
```

### 构造函数
```solidity
constructor(
    uint256 _initialSupply,
    uint256 _tokenPrice,
    uint256 _saleStartTime,
    uint256 _saleDuration,
    uint256 _minPurchase,
    uint256 _maxPurchase
) SimpleERC20(_initialSupply) {
    tokenPrice = _tokenPrice;
    saleStartTime = _saleStartTime;
    saleEndTime = _saleStartTime + _saleDuration;
    minPurchase = _minPurchase;
    maxPurchase = _maxPurchase;
    projectOwner = msg.sender;
    
    _transfer(msg.sender, address(this), totalSupply);
    initialTransferDone = true;
}
```

### 销售状态检查
```solidity
function isSaleActive() public view returns (bool) {
    return block.timestamp >= saleStartTime && 
           block.timestamp <= saleEndTime && 
           !finalized;
}
```

### 购买代币
```solidity
function buyTokens() public payable {
    require(isSaleActive(), "Sale not active");
    require(msg.value >= minPurchase && msg.value <= maxPurchase, "Invalid purchase amount");
    
    uint256 tokenAmount = (msg.value * 10**uint256(decimals)) / tokenPrice;
    require(balanceOf[address(this)] >= tokenAmount, "Insufficient tokens");
    
    _transfer(address(this), msg.sender, tokenAmount);
    totalRaised += msg.value;
    
    emit TokensPurchased(msg.sender, msg.value, tokenAmount);
}
```

### 重写转账函数(添加锁定)
```solidity
function transfer(address _to, uint256 _value) public override returns (bool) {
    if (!finalized && msg.sender != address(this) && initialTransferDone) {
        require(false, "Tokens are locked until sale is finalized");
    }
    return super.transfer(_to, _value);
}

function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {
    if (!finalized && _from != address(this) && initialTransferDone) {
        require(false, "Tokens are locked until sale is finalized");
    }
    return super.transferFrom(_from, _to, _value);
}
```

### 完成销售
```solidity
function finalizeSale() public payable {
    require(msg.sender == projectOwner, "Only owner");
    require(block.timestamp > saleEndTime, "Sale not ended");
    require(!finalized, "Already finalized");
    
    finalized = true;
    
    (bool success, ) = projectOwner.call{value: address(this).balance}("");
    require(success, "Transfer failed");
    
    emit SaleFinalized(totalRaised, totalSupply - balanceOf[address(this)]);
}
```

### 工具函数
```solidity
function timeRemaining() public view returns (uint256) {
    if (block.timestamp >= saleEndTime) return 0;
    return saleEndTime - block.timestamp;
}

function tokensAvailable() public view returns (uint256) {
    return balanceOf[address(this)];
}

receive() external payable {
    buyTokens();
}
```

## 核心知识点

- **Virtual/Override**: 允许子合约重写父合约函数
- `super`: 调用父合约的函数
- **代币锁定**: 在销售期间防止转账
- `receive()`: 接收直接发送的ETH并触发购买
- **时间控制**: 使用 `block.timestamp` 控制销售时间
- **价格计算**: `(msg.value * decimals) / tokenPrice`
- 销售完成后解锁代币转账

