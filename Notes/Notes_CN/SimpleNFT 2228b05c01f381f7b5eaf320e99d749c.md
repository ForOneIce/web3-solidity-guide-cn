# 简单NFT合约

本教程从头开始创建一个基础的ERC-721 NFT合约,不使用OpenZeppelin。涵盖NFT元数据、所有权追踪、批准、转账和铸造。同时解释了 `IERC721` 和 `IERC721Receiver` 接口。

## 关键概念

### ERC-721标准

NFT(非同质化代币)标准,每个代币都是独一无二的。

### 状态变量
```solidity
string public name;
string public symbol;

uint256 private _tokenIdCounter;

mapping(uint256 => address) private _owners;
mapping(address => uint256) private _balances;
mapping(uint256 => address) private _tokenApprovals;
mapping(address => mapping(address => bool)) private _operatorApprovals;
mapping(uint256 => string) private _tokenURIs;
```

### 构造函数
```solidity
constructor(string memory _name, string memory _symbol) {
    name = _name;
    symbol = _symbol;
}
```

### 余额和所有者
```solidity
function balanceOf(address owner) public view returns (uint256) {
    require(owner != address(0), "Invalid address");
    return _balances[owner];
}

function ownerOf(uint256 tokenId) public view returns (address) {
    address owner = _owners[tokenId];
    require(owner != address(0), "Token doesn't exist");
    return owner;
}
```

### 批准
```solidity
function approve(address to, uint256 tokenId) public {
    address owner = ownerOf(tokenId);
    require(msg.sender == owner, "Not the owner");
    require(to != owner, "Approval to current owner");
    
    _tokenApprovals[tokenId] = to;
}

function getApproved(uint256 tokenId) public view returns (address) {
    require(_owners[tokenId] != address(0), "Token doesn't exist");
    return _tokenApprovals[tokenId];
}
```

### 操作员批准
```solidity
function setApprovalForAll(address operator, bool approved) public {
    require(operator != msg.sender, "Approve to caller");
    _operatorApprovals[msg.sender][operator] = approved;
}

function isApprovedForAll(address owner, address operator) public view returns (bool) {
    return _operatorApprovals[owner][operator];
}
```

### 转账
```solidity
function transferFrom(address from, address to, uint256 tokenId) public {
    require(_isApprovedOrOwner(msg.sender, tokenId), "Not approved");
    _transfer(from, to, tokenId);
}

function safeTransferFrom(address from, address to, uint256 tokenId) public {
    safeTransferFrom(from, to, tokenId, "");
}

function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {
    require(_isApprovedOrOwner(msg.sender, tokenId), "Not approved");
    _safeTransfer(from, to, tokenId, data);
}
```

### 铸造
```solidity
function mint(address to, string memory uri) public returns (uint256) {
    uint256 tokenId = _tokenIdCounter;
    _tokenIdCounter++;
    
    _owners[tokenId] = to;
    _balances[to]++;
    _tokenURIs[tokenId] = uri;
    
    return tokenId;
}
```

### TokenURI
```solidity
function tokenURI(uint256 tokenId) public view returns (string memory) {
    require(_owners[tokenId] != address(0), "Token doesn't exist");
    return _tokenURIs[tokenId];
}
```

### 内部函数

#### 转账逻辑
```solidity
function _transfer(address from, address to, uint256 tokenId) internal {
    require(ownerOf(tokenId) == from, "Not the owner");
    require(to != address(0), "Invalid address");
    
    _tokenApprovals[tokenId] = address(0);
    
    _balances[from]--;
    _balances[to]++;
    _owners[tokenId] = to;
}
```

#### 安全转账
```solidity
function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {
    _transfer(from, to, tokenId);
    require(_checkOnERC721Received(from, to, tokenId, data), "Not ERC721Receiver");
}
```

#### 检查批准或所有者
```solidity
function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
    address owner = ownerOf(tokenId);
    return (spender == owner || 
            getApproved(tokenId) == spender || 
            isApprovedForAll(owner, spender));
}
```

#### 检查接收器
```solidity
function _checkOnERC721Received(
    address from,
    address to,
    uint256 tokenId,
    bytes memory data
) private returns (bool) {
    if (to.code.length > 0) {
        try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) 
            returns (bytes4 retval) {
            return retval == IERC721Receiver.onERC721Received.selector;
        } catch {
            return false;
        }
    }
    return true;
}
```

## 核心知识点

### ERC-721 vs ERC-20

| 特性 | ERC-20 | ERC-721 |
|------|--------|---------|
| 类型 | 同质化 | 非同质化 |
| 可替代性 | 可替代 | 独一无二 |
| 用途 | 货币,代币 | 艺术品,收藏品 |

### 关键概念

1. **tokenId**: 每个NFT的唯一标识符
2. **tokenURI**: 指向元数据的链接(图片、属性等)
3. **所有权**: 每个NFT有一个所有者
4. **批准**: 授权他人转移你的NFT
5. **操作员**: 可以管理你所有NFT的地址

### 批准类型

1. **单一批准**: `approve()` - 批准一个NFT
2. **全部批准**: `setApprovalForAll()` - 批准所有NFT

### 安全转账

`safeTransferFrom()` 确保接收者能够处理NFT:
- 检查接收者是否实现了 `IERC721Receiver`
- 防止NFT被发送到不支持的合约

### IERC721Receiver接口

```solidity
interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}
```

合约必须实现此接口才能接收NFT。

### TokenURI和元数据

通常指向JSON文件:
```json
{
  "name": "My NFT #1",
  "description": "An amazing NFT",
  "image": "ipfs://...",
  "attributes": [...]
}
```

