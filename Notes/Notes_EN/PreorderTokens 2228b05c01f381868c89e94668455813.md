# PreorderTokens

Alright — now that we’ve built a working ERC-20 token contract, it’s time to level up.

Let’s say you want to **sell your token before your project officially launches**. Maybe you want to raise some ETH, reward early believers, or build hype.

This is exactly what many real-world crypto projects do — they run a **token sale** (also called a presale or ICO), where users send ETH and receive tokens in return at a fixed rate.

To pull this off, we’re going to build a **simple token sale contract** that builds directly on top of the ERC-20 token we just wrote. But before we get there, we need to make one important change to our token contract so it can be extended properly.

---

## What We’re Building

We’re about to build a **simple but powerful token sale contract** — the kind you’d use for a presale, early backer round, or launch event.

This contract will allow you to:

- Sell your custom ERC-20 token at a fixed price in ETH
- Set a start and end time for the sale
- Enforce minimum and maximum purchase amounts
- Automatically handle token distribution
- Prevent transfers during the sale (to stop flipping or bot dumping)
- Finalize the sale and transfer raised ETH to the project owner

So the flow will look like this:

1. You deploy the token sale contract
2. It creates and holds all the tokens
3. Buyers send ETH and get tokens in return
4. Transfers are **locked** during the sale
5. After the sale ends, you finalize it and claim your ETH

Pretty neat, right?

To make this all work though, we need to prepare our token for inheritance and override some key functions. Let’s handle that first.

---

## Marking Token Functions as Overridable

Before we dive into the token sale contract, there’s one thing we need to tweak in our original `SimpleERC20` contract.

In Solidity, if you want to **override** a function from a parent contract in a child contract, that function must be marked as `virtual`.

So in your `SimpleERC20` contract, update these two functions like this:

```solidity
function transfer(address _to, uint256 _value) public virtual  returns (bool);
function transferFrom(address _from, address _to, uint256 _value) public virtual  returns (bool);

```

This change tells Solidity:

> "Hey, this function can be modified if another contract inherits from this one."
> 

We’ll use this to **restrict token transfers** during the sale period.

---

## Contract Breakdown: `SimplifiedTokenSale`

```solidity
contract SimplifiedTokenSale is SimpleERC20 {

```

This contract inherits from `SimpleERC20`, so it has all the ERC-20 functionality we wrote earlier — plus whatever logic we’re about to add.

---

## State Variables — Sale Setup

```solidity
uint256 public tokenPrice;
uint256 public saleStartTime;
uint256 public saleEndTime;
uint256 public minPurchase;
uint256 public maxPurchase;
uint256 public totalRaised;
address public projectOwner;
bool public finalized = false;
bool private initialTransferDone = false;

```

Let’s break these down:

- `tokenPrice`: How much ETH (in wei) each token costs
- `saleStartTime` and `saleEndTime`: Timestamps that define when the sale begins and ends
- `minPurchase` and `maxPurchase`: Limits for how much ETH someone can send in a single transaction
- `totalRaised`: How much ETH has been collected so far
- `projectOwner`: The address that receives the ETH once the sale is done
- `finalized`: Has the sale been officially closed?
- `initialTransferDone`: Used to ensure the contract received all tokens before locking transfers

These variables power all the sale logic.

---

## Events

```solidity
event TokensPurchased(address indexed buyer, uint256 etherAmount, uint256 tokenAmount);
event SaleFinalized(uint256 totalRaised, uint256 totalTokensSold);

```

- `TokensPurchased`: Fired when someone successfully buys tokens. It logs who bought, how much ETH they paid, and how many tokens they received.
- `SaleFinalized`: Fired when the sale ends. Logs the total ETH raised and the number of tokens sold.

These are useful for frontends and explorers to display sale activity.

---

## 

## Constructor — Setting Everything Up

```solidity

constructor(
    uint256 _initialSupply,
    uint256 _tokenPrice,
    uint256 _saleDurationInSeconds,
    uint256 _minPurchase,
    uint256 _maxPurchase,
    address _projectOwner
) SimpleERC20(_initialSupply) {
    tokenPrice = _tokenPrice;
    saleStartTime = block.timestamp;
    saleEndTime = block.timestamp + _saleDurationInSeconds;
    minPurchase = _minPurchase;
    maxPurchase = _maxPurchase;
    projectOwner = _projectOwner;

    // Transfer all tokens to this contract for sale
    _transfer(msg.sender, address(this), totalSupply);

    // Mark that we've moved tokens from the deployer
    initialTransferDone = true;
}

```

Let’s go line by line:

---

```json
constructor(...) SimpleERC20(_initialSupply)
```

This is a **constructor**, meaning it runs **once** when the contract is first deployed.

But here’s something important: this contract inherits from `SimpleERC20`, so we need to pass the `_initialSupply` to the parent contract to actually **mint the tokens**.

So right away, this line:

```solidity
 
SimpleERC20(_initialSupply)

```

…calls the `SimpleERC20` constructor behind the scenes and gives the deployer all the tokens initially.

---

```json
tokenPrice = _tokenPrice;
```

Stores the price of each token in **wei** (the smallest unit of ETH). For example, if `tokenPrice = 10**16`, that means **each token costs 0.01 ETH**.

---

```json
saleStartTime = block.timestamp;
```

We mark the sale’s start time as **now** — the moment this contract is deployed.

---

```json
saleEndTime = block.timestamp + _saleDurationInSeconds;
```

The sale should only run for a limited time. So we set the end time by **adding a duration (in seconds)** to the start time.

If you pass in `604800` (seconds in a week), the sale ends in 7 days.

---

```json
minPurchase and maxPurchase
```

These two lines define the **limits** on how much ETH a buyer can send:

- `minPurchase` ensures someone doesn’t send too little (like a spam amount).
- `maxPurchase` prevents whales or bots from buying too much in a single transaction.

Both values are also in **wei**.

---

```json
projectOwner = _projectOwner;
```

We store the address of the project creator — the person who should receive the ETH raised during the sale.

Only this person can call `finalizeSale()` later and withdraw the funds.

---

```json
_transfer(msg.sender, address(this), totalSupply);
```

Here’s where things get fun.

- At this point, the deployer (you) owns all the tokens — because that’s how the ERC-20 constructor works.
- But you don’t want to **manually** send those tokens to the sale contract.
- So right here, inside the constructor, we **programmatically transfer all tokens from the deployer to the contract itself**.

That way, the contract becomes the token distributor for the sale.

---

```json
initialTransferDone = true;
```

We mark that the token handoff from the deployer to the contract is done.

This boolean is used in our `transfer()` function to ensure the locking logic only kicks in **after** tokens have been moved into the contract.

---

## isSaleActive()

```solidity
function isSaleActive() public view returns (bool) {
    return (!finalized && block.timestamp >= saleStartTime && block.timestamp <= saleEndTime);
}

```

This function checks if the sale is currently live:

- It must not be finalized
- The current time must fall within the sale window

This is used throughout the contract to gate logic.

---

## 

## `buyTokens()` — The Main Purchase Function

```solidity
  
function buyTokens() public payable {
    require(isSaleActive(), "Sale is not active");
    require(msg.value >= minPurchase, "Amount is below minimum purchase");
    require(msg.value <= maxPurchase, "Amount exceeds maximum purchase");

    uint256 tokenAmount = (msg.value * 10**uint256(decimals)) / tokenPrice;
    require(balanceOf[address(this)] >= tokenAmount, "Not enough tokens left for sale");

    totalRaised += msg.value;
    _transfer(address(this), msg.sender, tokenAmount);
    emit TokensPurchased(msg.sender, msg.value, tokenAmount);
}

```

This function is what users interact with when they want to buy your token during the presale. They call `buyTokens()` and send ETH along with the transaction. Here's what happens step by step:

---

### 1. Check if the sale is active

```solidity
  
require(isSaleActive(), "Sale is not active");

```

We call the helper function `isSaleActive()` to make sure the sale is happening right now. If the sale has ended, hasn't started yet, or has been finalized, this check fails, and the transaction is reverted.

---

### 2. Enforce min and max purchase limits

```solidity
  
require(msg.value >= minPurchase, "Amount is below minimum purchase");
require(msg.value <= maxPurchase, "Amount exceeds maximum purchase");

```

We want to control how little or how much ETH a user can send in one transaction. This helps prevent spam buys or huge purchases from bots. These two lines ensure that the amount of ETH sent is within the allowed range.

---

### 3. Calculate how many tokens to send

```solidity
  
uint256 tokenAmount = (msg.value * 10**uint256(decimals)) / tokenPrice;

```

Now we compute how many tokens the buyer should get for the ETH they sent.

- We multiply the ETH amount (`msg.value`) by `10 ** decimals` to handle the precision (remember: most ERC-20 tokens have 18 decimal places).
- Then we divide by `tokenPrice` (which is also expressed in wei per token).

This gives us the number of tokens they should receive, properly scaled.

---

### 4. Make sure the contract still has enough tokens

```solidity
  
require(balanceOf[address(this)] >= tokenAmount, "Not enough tokens left for sale");

```

Even if the user sent valid ETH and asked for a fair number of tokens, we still need to check whether the sale contract actually holds enough tokens to fulfill the request. If not, the purchase is blocked.

---

### 5. Update the ETH raised

```solidity
  
totalRaised += msg.value;

```

This keeps a running total of all ETH collected through the sale. We’ll use this later when finalizing the sale.

---

### 6. Transfer tokens to the buyer

```solidity
  
_transfer(address(this), msg.sender, tokenAmount);

```

This is where the actual token movement happens. The contract sends tokens to the buyer from its own balance.

- `address(this)` is the contract's address (the one that holds all tokens for the sale).
- `msg.sender` is the buyer’s address.

This internal `_transfer()` function is defined in the ERC-20 token we built earlier.

---

### 7. Emit a purchase event

```solidity
  
emit TokensPurchased(msg.sender, msg.value, tokenAmount);

```

We emit the `TokensPurchased` event, logging:

- Who bought the tokens
- How much ETH they spent
- How many tokens they received

---

## 

## Overriding `transfer()` — Locking Direct Transfers

```solidity
  
function transfer(address _to, uint256 _value) public override returns (bool) {
    if (!finalized && msg.sender != address(this) && initialTransferDone) {
        require(false, "Tokens are locked until sale is finalized");
    }
    return super.transfer(_to, _value);
}

```

This function overrides the standard ERC-20 `transfer()` function. The main goal here is to **temporarily restrict token transfers** while the sale is ongoing.

Let’s go through it step-by-step:

### 1. Sale Check

```solidity
  
if (!finalized && msg.sender != address(this) && initialTransferDone) {
    require(false, "Tokens are locked until sale is finalized");
}

```

This condition checks three things:

- `!finalized`: The sale has **not** been finalized yet.
- `msg.sender != address(this)`: The transaction is **not initiated by the contract** itself (e.g. during `buyTokens()`).
- `initialTransferDone`: The initial token supply has been transferred to the contract already.

If all of these are true, then the function **reverts**, effectively **blocking the transfer**.

Why?

To ensure that no one can send tokens to others or trade them **during the sale period**. This helps prevent:

- Premature trading or speculation
- Bots scooping up tokens and flipping them
- Manipulation before the token is live

Once the sale is finalized, this condition becomes false and transfers are allowed as usual.

### 2. Normal Transfer

```solidity
  
return super.transfer(_to, _value);

```

If the sale is finalized (or the sender is the contract itself), we simply call the parent contract’s original `transfer()` function. This performs the actual transfer logic.

---

## Overriding `transferFrom()` — Locking Delegated Transfers

```solidity
  
function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {
    if (!finalized && _from != address(this)) {
        require(false, "Tokens are locked until sale is finalized");
    }
    return super.transferFrom(_from, _to, _value);
}

```

Just like `transfer()`, this function overrides the ERC-20 `transferFrom()` — but it's used for **delegated transfers**, where someone is spending tokens on behalf of another wallet (typically after an `approve()` call).

Let’s break it down:

### 1. Sale Lock Check

```solidity
  
if (!finalized && _from != address(this)) {
    require(false, "Tokens are locked until sale is finalized");
}

```

Again, we check:

- Is the sale still ongoing?
- Is the transfer not coming from the contract?

If yes, we block the transaction. This ensures that **even approved spenders** can’t move tokens around on someone else’s behalf during the sale.

Why?

Because otherwise someone could approve a contract (like Uniswap), and that contract could trade tokens even while the sale is live — defeating the whole purpose of transfer locks.

### 2. Fallback to Default Logic

```solidity
  
return super.transferFrom(_from, _to, _value);

```

If the check passes (sale finalized or transfer initiated by the contract), we fall back to the original ERC-20 `transferFrom()` logic using `super`.

---

## finalizeSale()

```solidity
function finalizeSale() public payable {
    require(msg.sender == projectOwner, "Only Owner can call the function");
    require(!finalized, "Sale already finalized");
    require(block.timestamp > saleEndTime, "Sale not finished yet");

    finalized = true;
    uint256 tokensSold = totalSupply - balanceOf[address(this)];

    (bool success, ) = projectOwner.call{value: address(this).balance}("");
    require(success, "Transfer to project owner failed");

    emit SaleFinalized(totalRaised, tokensSold);
}

```

This is the function that **ends the token sale** — kind of like closing the shop after launch day. Let’s go through it step by step:

---

### Access Control and Timing

```solidity
  
require(msg.sender == projectOwner, "Only Owner can call the function");
require(!finalized, "Sale already finalized");
require(block.timestamp > saleEndTime, "Sale not finished yet");

```

These three `require()` checks do the following:

1. **Only the project owner** can call this function — this prevents random users from interfering with the sale.
2. It checks if the sale has already been finalized — if yes, we don’t allow a second call.
3. It ensures the sale period has ended (based on the end timestamp) — so you can't finalize it early.

---

### Marking the Sale as Complete

```solidity
  
finalized = true;

```

We update the `finalized` state variable so that other functions (like `transfer()` and `transferFrom()`) know the sale is over. This unlocks token transfers across the ecosystem.

---

### Calculating Tokens Sold

```solidity
  
uint256 tokensSold = totalSupply - balanceOf[address(this)];

```

This calculates how many tokens were actually sold:

- `totalSupply` is the full amount of tokens created.
- `balanceOf[address(this)]` is how many tokens are still held by the contract (i.e., unsold).
- Subtracting the two gives us the number of tokens distributed to users.

---

### Sending ETH to Project Owner

```solidity
  
(bool success, ) = projectOwner.call{value: address(this).balance}("");
require(success, "Transfer to project owner failed");

```

Here, we transfer **all the ETH raised** during the sale to the `projectOwner`.

- `address(this).balance` gives us the total ETH in the contract.
- We use `.call{value: ...}` to send the funds.
- The `require(success)` ensures the transfer didn’t silently fail.

This is how the project collects the ETH raised during the sale.

---

### Emitting the Final Event

```solidity
  
emit SaleFinalized(totalRaised, tokensSold);

```

Finally, we emit a `SaleFinalized` event with:

- The total ETH raised
- The number of tokens sold

This event can be picked up by a frontend, DApp, or block explorer to show users that the sale is officially complete.

---

## 

## `timeRemaining()` and `tokensAvailable()` — Sale Status Helpers

These two functions are **read-only** helpers that make it easier for frontends, dashboards, or other smart contracts to get live info about the token sale.

---

### `timeRemaining()`

```solidity
  
function timeRemaining() public view returns (uint256) {
    if (block.timestamp >= saleEndTime) {
        return 0;
    }
    return saleEndTime - block.timestamp;
}

```

This function tells you how much time (in seconds) is left before the sale ends.

- It compares the **current block timestamp** (`block.timestamp`) with the predefined `saleEndTime`.
- If the sale has already ended, it returns `0`.
- Otherwise, it returns the difference between now and the end time.

**Use Case:** A frontend can call this function to show a countdown like "2 hours and 15 minutes left" — great for urgency or last-minute participation.

---

### `tokensAvailable()`

```solidity
  
function tokensAvailable() public view returns (uint256) {
    return balanceOf[address(this)];
}

```

This function tells you how many tokens are **still available** for purchase.

- The token sale contract holds all tokens during the sale.
- So we simply return its current balance using `balanceOf[address(this)]`.

**Use Case:** Your frontend or DApp can show “X tokens left” to keep buyers informed and drive urgency.

---

### Why These Are Useful

Even though they’re small, both functions play a big role in making your token sale **user-friendly**:

- They help display live data
- They don’t cost gas for external calls (view functions)
- They keep your smart contract logic clean and readable

So whether you're building a fancy dashboard or just debugging your contract, these helpers make your life a lot easier.

---

## 

## `receive()` — Fallback ETH Handler

```solidity
  
receive() external payable {
    buyTokens();
}

```

This function is what makes the buying experience smooth and intuitive — especially for non-technical users.

In Solidity, the `receive()` function is a **special fallback function** that gets triggered when:

- Someone sends ETH **directly** to the contract address
- And **doesn’t specify** any function to call

Normally, if a contract doesn’t have this function, and someone tries to send ETH directly, the transaction would fail.

But in this case, we define `receive()` so that anytime someone sends ETH to this contract (even just from MetaMask or a simple wallet transfer), the contract will **automatically call `buyTokens()` behind the scenes**.

This means:

- No need for users to interact with a dApp UI
- No need to manually call the `buyTokens()` function
- Just sending ETH is enough to participate in the token sale

It’s a small addition, but it greatly improves the user experience — and ensures that even if people forget to call a function, they still get their tokens.

So in summary: `receive()` acts like a safety net and a shortcut.

It lets ETH in, and routes that ETH straight into the token sale logic.

---

## 🎯 Wrap Up

And that’s a wrap on building your very own **ERC-20 token sale** from scratch.

You didn’t just write a smart contract — you built a full-on **presale system** like the ones used by real crypto projects. You now understand how to:

- Deploy a custom ERC-20 token
- Set up a time-bound token sale with pricing logic
- Handle purchases in ETH with live token distribution
- Lock transfers to prevent speculation during the sale
- Finalize the sale and securely send raised funds to the project wallet

More importantly — you learned **why** each part matters.

From protecting buyers to maintaining fairness, from precise ETH-to-token calculations to UX-friendly `receive()` functions — you’ve seen how smart contracts bring it all together.

This structure is the backbone of many DeFi launches, DAO fundraisers, and even NFT drops (with a few tweaks). You’ve just stepped into the world of **smart contract-powered crowdfunding**.