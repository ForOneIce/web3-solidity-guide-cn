# SimpleNFT

---

# Create Your Own NFT (Simple ERC-721)

Alright, welcome back to **30 Days of Solidity**.

Up until now, we’ve been learning how smart contracts work under the hood. We made our own token, locked up funds, played around with access control, and even learned how to protect contracts from shady attacks.

But today?

Today’s different.

We’re finally stepping into the part of Solidity where the stuff you build has actual real-world use.

And we’re kicking things off with something everyone’s heard of, but few truly *get*:

**NFTs**.

---

### 

### 🎨 What Even *Is* an NFT?

Alright, let’s clear the air first — NFTs are not just monkey pictures or internet flexes.

Under all the hype, **NFTs are about digital ownership**.

And the key to understanding them is this one weird-sounding word: **non-fungible**.

**NFT** = **Non-Fungible Token**

Let’s break that down:

- A **token** is just a digital thing on a blockchain.
- **Fungible** means “interchangeable.” Like money. 1 dollar is always worth 1 dollar, no matter where it came from.
- **Non-fungible** means it’s *not* interchangeable. It’s unique. One-of-a-kind.

Let’s say your friend hands you a pen. Cool. It’s just a regular pen — you use it, lose it, whatever.

Now imagine your grandpa gives you a fountain pen he’s had since the 1940s. It’s old, engraved, and has a story behind it.

Technically, both are “just pens.” But are they equal?

No way.

The one from your grandpa is **non-fungible** — it has sentimental value, history, uniqueness.

You wouldn’t just swap it for a random pen from a stationery shop.

That’s exactly how NFTs work.

They’re digital items that *aren’t all the same*. Each one has its own ID, its own data, its own meaning.

Even if they’re part of the same collection, NFT #1 might be totally different from NFT #2000.

Different image, different stats, different story.

---

### 🤝 So How’s This Different From What We Built Before?

Remember that ERC-20 token we made earlier?

That was a **fungible** token — like making your own digital currency.

If you have 10 of it and I have 10, we’ve got the same thing. Tokens are equal and interchangeable.

NFTs (built using **ERC-721**) are totally different.

Each token has its *own identity*. Own number. Own meaning.

You can’t swap them 1:1 because each one could represent something completely different.

---

### 🚪 NFTs Are More Than Just Art

This is the part that most people miss.

NFTs aren’t just about artwork or collectibles.

They’re a way to represent **ownership** — of literally anything — in a digital form.

Let’s break down a few real examples:

### 🎟 Event Tickets

An NFT can be a ticket to a concert, a workshop, or a festival.

No paper. No screenshots. Just scan it from your wallet — and you're in.

### 🎮 In-Game Stuff

That rare skin, sword, or house you grinded for? If it’s an NFT, you *own* it.

Not the game company. You. You can sell it, rent it, even take it into other games.

### 📄 Property or Legal Docs

In the future, your house deed could be an NFT.

It would live on-chain, be super hard to fake, and easy to transfer without 20 layers of paperwork.

### 📛 Certificates or Proof

NFTs can be used as digital certificates.

Finished a course? Boom — NFT in your wallet. Anyone can verify it instantly.

---

### 💡 Why Does This Matter?

Before NFTs, the internet had a weird problem — you could share stuff, but you couldn’t *own* it.

You could post a photo, but it’s hard to prove it’s yours.

You could buy something in a game, but if the game shuts down — it’s gone.

NFTs fix that.

They bring the concept of **ownership** to the digital world — in a way that’s public, permanent, and programmable.

It’s not just art.

It’s your stuff — tickets, collectibles, ID, credentials — finally made real in the digital space.

---

### 🛠 So What Are We Building Today?

We’re gonna keep it simple.

You're going to build your **very first NFT contract**, from scratch.

No OpenZeppelin. No copy-pasting. Just raw Solidity — so you understand what’s actually going on.

It’ll follow the **ERC-721 standard**, which is like a rulebook for NFTs on Ethereum.

By the end of this, you’ll have created a real, mintable NFT — the kind you could connect to a game, a gallery, or even your own mini marketplace.

Let’s do this.

---

## 🔍 Full Code: `SimpleNFT.sol`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);

    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address);

    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    function transferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract SimpleNFT is IERC721 {
    string public name;
    string public symbol;

    uint256 private _tokenIdCounter = 1;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    mapping(uint256 => string) private _tokenURIs;

    constructor(string memory name_, string memory symbol_) {
        name = name_;
        symbol = symbol_;
    }

    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), "Zero address");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "Token doesn't exist");
        return owner;
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner, "Already owner");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "Not authorized");

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_owners[tokenId] != address(0), "Token doesn't exist");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != msg.sender, "Self approval");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "Not authorized");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        safeTransferFrom(from, to, tokenId, "");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "Not authorized");
        _safeTransfer(from, to, tokenId, data);
    }

    function mint(address to, string memory uri) public {
        uint256 tokenId = _tokenIdCounter;
        _tokenIdCounter++;

        _owners[tokenId] = to;
        _balances[to] += 1;
        _tokenURIs[tokenId] = uri;

        emit Transfer(address(0), to, tokenId);
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_owners[tokenId] != address(0), "Token doesn't exist");
        return _tokenURIs[tokenId];
    }

    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(ownerOf(tokenId) == from, "Not owner");
        require(to != address(0), "Zero address");

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        delete _tokenApprovals[tokenId];
        emit Transfer(from, to, tokenId);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), "Not ERC721Receiver");
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch {
                return false;
            }
        }
        return true;
    }
}

```

Alright, time to get our hands dirty.

This contract right here is a **barebones NFT contract** that follows the ERC-721 standard — but without using any external libraries or frameworks.

It’s super clean, super readable, and shows you the core ideas behind how NFTs work under the hood.

Here’s what it does:

- Gives your NFT collection a name and symbol
- Lets you **mint** new NFTs with custom metadata (like an image or description)
- Tracks **who owns what**
- Keeps track of **how many NFTs** each person owns
- Lets owners **approve** others to transfer their NFT
- And of course, handles **transfers** between users

This isn’t bloated. There’s no OpenZeppelin magic.

It’s just plain Solidity doing exactly what an NFT contract needs to do — nothing more, nothing less.

Let’s go through it.👇

## 📌 Breakdown

### 📜 The Interface

```solidity
 
interface IERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);

    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address);

    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    function transferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

```

### 🧠 What's Going On?

This is the **ERC-721 interface**, which defines all the mandatory functions and events an NFT contract must implement to be called “ERC-721 compliant.”

It’s like saying: “Hey Ethereum, my contract is an NFT contract, and here are the things I promise to support.”

- **Events** like `Transfer` and `Approval` tell the blockchain (and frontends) when NFTs move or get approved.
- **Functions** handle ownership, approvals, and transferring tokens.

---

### 📬 Handling Safe Transfers

```solidity
 
interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

```

This interface is used to **safely send NFTs to contracts**. Without it, if you try to transfer an NFT to a smart contract that can't handle it, the NFT might get stuck. So we check that the receiving contract knows what to do with an NFT.

---

# 🏗️ The Contract Begins

```solidity
 
contract SimpleNFT is IERC721 {
    string public name;
    string public symbol;

    uint256 private _tokenIdCounter = 1;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    mapping(uint256 => string) private _tokenURIs;

```

### 

### 🧠 What’s Happening Here?

Alright, this is where we roll up our sleeves and actually **build the brain** of our NFT contract.

Let’s walk through it one line at a time — not just *what* it is, but *why* we need it.

---

```jsx
contract SimpleNFT is IERC721{
```

This line is like us saying:

> "Hey Solidity, we’re building a new contract called SimpleNFT, and it’s going to follow the ERC-721 rules."
> 

In Solidity, when we use `is IERC721`, it’s like signing a contract:

"I promise to include all the functions defined inside the `IERC721` interface."

So yeah — if `IERC721` is a rulebook, `SimpleNFT` is our actual implementation of those rules. That’s how other contracts and platforms (like OpenSea) know how to interact with us.

```jsx
string public name; 
 string public symbol;
```

---

Every NFT collection, just like every currency, needs an identity.

- `name`: This could be something like `"CryptoCats"` or `"MyPixelPonies"`.
- `symbol`: A shorter ticker-style code like `"CAT"` or `"PONY"`.

These are public variables, which means anyone can call a function to ask for the name or symbol. Solidity will auto-generate getter functions for them under the hood.

---

```jsx
uint256 private _tokenIdCounter = 1;
```

NFTs need to be unique, right? So we assign them IDs — like collectible cards numbered `#1`, `#2`, `#3`, and so on.

This variable helps us **track the next available token ID** to mint.

We start from `1` instead of `0` (just to keep things human-readable and less error-prone).

Every time we mint a new NFT, we:

1. Use the current `_tokenIdCounter`
2. Then increase (`++`) it for the next mint

---

```jsx
mapping(uint256 => address) private _owners;
```

This map answers a simple question:

> "Who owns token #X?"
> 

We use this to **store the address** of the person who owns a given token ID. If `_owners[10] = 0xabc...`, it means token #10 is owned by that address.

No owner = no token.

---

```jsx
mapping(address => uint256) private _balances;
```

This one’s the opposite of the above.

Instead of asking **“Who owns token #X?”**, this asks:

> "How many tokens does Alice own?"
> 

We’re tracking balances here — how many total NFTs an address owns.

So if `_balances[0xabc...] = 3`, that means this person owns 3 NFTs from this contract.

This helps us implement the `balanceOf()` function in the interface.

---

```jsx
mapping(uint256 => address) private _tokenApprovals;
```

Okay — here’s where it starts to feel a little like a security checkpoint.

NFTs can be **approved** to be transferred by someone else. For example, if you want OpenSea to sell your NFT on your behalf, you need to approve them.

This mapping tracks that:

- `_tokenApprovals[12] = 0xopensea...` means the address `0xopensea...` is approved to transfer token #12.

Think of it like giving someone temporary permission to hand over your card collection to a buyer.

---

```jsx
mapping(address => mapping(address => bool)) private _operatorApprovals;
```

This is like a broader version of the previous one.

Here, we’re saying:

> "I trust this address to manage all my NFTs — not just one."
> 

So for example:

```solidity

_operatorApprovals[Alice][Bob] = true

```

Means Bob is allowed to move **any** NFT owned by Alice.

This is handy for marketplaces, rental systems, or delegating rights to another wallet.

---

```jsx
mapping(uint256 => string) private _tokenURIs;
```

Finally, the fun part — this is where the NFT magic lives!

This mapping stores the **metadata URL** for each token.

Each token might have an image, a description, maybe even a 3D model.

The URI could point to something like:

```

https://my-nft-host.com/metadata/42.json

```

Which contains:

```json

{
  "name": "Dragon #42",
  "description": "A fierce fire-breathing NFT.",
  "image": "ipfs://somehash/dragon.png"
}

```

This is what makes NFTs *more than just numbers*.

They become characters, artworks, music — anything you want them to represent.

---

# Constructor

```solidity
 
    constructor(string memory name_, string memory symbol_) {
        name = name_;
        symbol = symbol_;
    }

```

### 🧠 What’s Going On?

When you deploy this contract, you set the name and symbol of your NFT collection. For example, “CryptoDragons” and symbol “CDR”.

---

# 🏦 balanceOf

```solidity
  function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), "Zero address");
        return _balances[owner];
    }

```

### 🧠 Explanation

This returns how many NFTs an address owns.

- If someone calls this with a `0x0` address (which isn’t valid), we reject it.
- Otherwise, we just return the count stored in `_balances`.

---

# 👑 ownerOf

```solidity

    function ownerOf(uint256 tokenId) public view override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "Token doesn't exist");
        return owner;
    }

```

### 🧠 Explanation

Given a token ID, this tells you **who owns it**.

If the token doesn’t exist (i.e., no one owns it yet), we throw an error.

---

# ✉️ `approve`

```solidity
 
function approve(address to, uint256 tokenId) public override {
    address owner = ownerOf(tokenId);
    require(to != owner, "Already owner");
    require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "Not authorized");

    _tokenApprovals[tokenId] = to;
    emit Approval(owner, to, tokenId);
}

```

---

### 🧠 What’s Going On Here?

This function allows the current owner of an NFT to say:

> “Hey, I’m giving this specific person permission to transfer this specific token.”
> 

It doesn’t transfer ownership — it just hands over the keys *temporarily*.

Let’s go line-by-line.

---

### 🔍 Line-by-Line Breakdown

```jsx
address owner = ownerOf(tokenId);
```

We first figure out **who actually owns** this token. This is important because **only the real owner** can approve someone else — we don’t want randos handing out permissions.

---

```jsx
require(to != owner, "Already owner");
```

Here’s a sanity check:

Why would you approve yourself to transfer your own token? Makes no sense.

So we block that with this line.

---

```jsx
require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "Not authorized");
```

This is our security gate.

It says:

“You can only approve someone if *you’re the owner*… or if *you’ve been approved by the owner to manage all their tokens* (via `setApprovalForAll`).”

Basically:

- ✅ Owner can approve someone
- ✅ An *operator* (someone pre-approved to manage all tokens) can approve someone
- ❌ A random wallet cannot

This ensures **only authorized users can assign token-specific permissions**.

---

```jsx
_tokenApprovals[tokenId] = to;
```

Now that all checks are passed — we go ahead and **save the approval**.

This means:

> “Token #123 is now approved to be transferred by address 0xSomeOtherWallet.”
> 

That info gets stored in the `_tokenApprovals` mapping.

---

```jsx
emit Approval(owner, to, tokenId);
```

Finally, we emit an `Approval` event — a little shout-out to the outside world.

This event is super important for platforms like OpenSea or Etherscan because it helps them know:

- Who owns what
- Who's allowed to move it

Frontends *listen* to these events to keep their UIs in sync.

---

# 🔍 getApproved

```solidity
 
    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_owners[tokenId] != address(0), "Token doesn't exist");
        return _tokenApprovals[tokenId];
    }

```

### 🧠 Explanation

Check who is approved to transfer a specific token.

---

# ✅ setApprovalForAll

```solidity
 
    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != msg.sender, "Self approval");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

```

### 🧠 Explanation

Instead of approving each token individually, this lets a user **approve or revoke access** to all their NFTs for a given operator (e.g., a marketplace or vault contract).

---

# 🔄 isApprovedForAll

```solidity

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

```

### 🧠 Explanation

Just checks if an operator is approved to manage *all* NFTs owned by someone.

---

# 🔁 _transfer (Internal)

```solidity
 
    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(ownerOf(tokenId) == from, "Not owner");
        require(to != address(0), "Zero address");

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        delete _tokenApprovals[tokenId];
        emit Transfer(from, to, tokenId);
    }

```

### 🧠 What’s Happening Here?

This is the **core function** that handles the actual movement of an NFT from one wallet to another.

But here’s the key thing: `_transfer` is **not meant to be called directly by users**. Instead, it acts as a **helper** — a **reusable internal tool** that other functions like `transferFrom()` and `safeTransferFrom()` rely on under the hood.

So whenever someone calls those public transfer functions, this little guy right here is doing the real job.

Let’s walk through it line by line:

---

### 🔍 Step-by-Step Breakdown

### ✅ Ownership Check

```solidity
 
require(ownerOf(tokenId) == from, "Not owner");

```

Before anything else, we check:

“Is this `from` address actually the owner of this token?”

If not — we stop. No unauthorized moves allowed.

---

### ❌ No Blackhole Transfers

```solidity
 
require(to != address(0), "Zero address");

```

We also block transfers to the **zero address** — this would be like sending an NFT into a digital black hole.

Only minting (creating new NFTs) should use the zero address as `from`.

---

### ➖ Update the Sender’s Balance

```solidity
 
_balances[from] -= 1;

```

The `from` address is losing this NFT, so we decrease their balance by 1.

---

### ➕ Update the Recipient’s Balance

```solidity
 
_balances[to] += 1;

```

The `to` address is receiving a new NFT, so we bump their balance up.

---

### 👑 Change Ownership

```solidity
 
_owners[tokenId] = to;

```

Now that the token has changed hands, we **reassign the token ID** to the new owner.

This is the most critical step — the ownership record gets updated.

---

### 🧹 Clear Old Approvals

```solidity
 
delete _tokenApprovals[tokenId];

```

If someone had been previously approved to transfer this token — we **remove that approval**.

After all, the token has a new owner now, and they should decide who (if anyone) gets permission next.

---

### 📢 Emit Transfer Event

```solidity
 
emit Transfer(from, to, tokenId);

```

This sends out an **official signal** to the blockchain (and to frontends like Etherscan or OpenSea):

> "Token #123 just moved from Alice to Bob."
> 

This event is required by the ERC-721 standard and is what makes public UIs stay in sync with the blockchain state.

---

### 📦 So Why Is This Function *Internal*?

Great question.

We mark this function as `internal` because:

- It’s **not safe for end-users to call directly.**
- It doesn’t perform permission checks like "Is the caller approved to transfer this token?"
- It assumes those checks have **already happened** in the outer function (`transferFrom()` or `safeTransferFrom()`).

So instead of repeating this transfer logic everywhere, we write it once here and call it safely from other functions **after all permissions are verified**.

# 🔐 `_safeTransfer` (Internal)

```solidity
 
function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
    _transfer(from, to, tokenId);
    require(_checkOnERC721Received(from, to, tokenId, data), "Not ERC721Receiver");
}

```

---

### 🧠 What’s Going On Here?

This function is like `_transfer`, but with **extra safety armor**.

It does everything `_transfer` does (updating balances, ownership, clearing approvals, and firing the `Transfer` event), **but adds one crucial check** afterward:

> “Hey, are we sending this NFT to a smart contract? If yes — can it actually receive NFTs?”
> 

Because here’s the thing — if you accidentally send an NFT to a contract that **doesn’t know how to handle NFTs**, it’ll just get stuck there… forever.

This function helps avoid that by calling `_checkOnERC721Received()` right after the transfer. If that check fails, the entire transfer is rolled back.

So, in short:

- ✅ Works fine if `to` is a normal wallet.
- 🔒 Extra safe when `to` is a smart contract.
- 🚫 Reverts if the contract doesn’t support ERC-721.

---

# 🔍 `_isApprovedOrOwner`

```solidity
 
function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
    address owner = ownerOf(tokenId);
    return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
}

```

---

### 🧠 What’s Going On Here?

This is the **gatekeeper function**. Before we allow anyone to move a token, we ask this simple question:

> “Is the caller allowed to move this token?”
> 

Let’s break it down:

- `spender == owner` → The person calling is the actual owner of the token.
- `getApproved(tokenId) == spender` → The token owner gave this specific person permission to move this one token.
- `isApprovedForAll(owner, spender)` → The token owner said, “This person can manage all my tokens.”

If any of those checks return true, then the caller is authorized to proceed.

This function gets used all over the place to **enforce access control** before doing sensitive things like transferring tokens.

---

# 📦 `_checkOnERC721Received`

```solidity
 
function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {
    if (to.code.length > 0) {
        try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
            return retval == IERC721Receiver.onERC721Received.selector;
        } catch {
            return false;
        }
    }
    return true;
}

```

---

### 🧠 What’s Going On Here?

This is the **safety check** used by `_safeTransfer`.

It’s here to answer one very important question:

> “Are we sending this NFT to a smart contract that knows how to handle it?”
> 

Let’s go line by line.

### 🧠 `if (to.code.length > 0)`

This checks:

> Is the recipient a smart contract?
> 

Wallet addresses have no code, but contracts do.

So if `to.code.length > 0`, then yeah — we’re talking to a smart contract.

---

### 🎯 Try calling `onERC721Received`

```solidity
 
try IERC721Receiver(to).onERC721Received(...) returns (bytes4 retval)

```

We then **try to call** the function that a smart contract is *supposed* to implement if it wants to safely receive NFTs.

This is like knocking on the door and asking:

> “Do you know what to do with this NFT?”
> 

If the contract returns the expected value (which is a specific selector), all is good. Transfer successful.

---

### 💥 Catch failure

If the call fails (i.e. the contract doesn’t implement `onERC721Received`, or throws an error), then we return `false`.

This causes `_safeTransfer` to revert the entire transaction, protecting the NFT from being lost.

---

### ✅ If it’s just a wallet...

```solidity
 
return true;

```

If we’re sending the NFT to a regular wallet (not a contract), then we’re good — no need for fancy checks.

# 🔁 transferFrom

```solidity
 
    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "Not authorized");
        _transfer(from, to, tokenId);
    }

```

### 🧠 Explanation

Transfers a token from one person to another. Only the owner or someone approved can do this.

It uses `_isApprovedOrOwner` to check permissions, and then calls `_transfer`.

---

### 

# 🛡️ `safeTransferFrom` (Basic Version)

```solidity
 
function safeTransferFrom(address from, address to, uint256 tokenId) public override {
    safeTransferFrom(from, to, tokenId, "");
}

```

---

### 🧠 What’s Going On Here?

This is the **simplified version** of a safe transfer.

Think of it as a shortcut — when you don’t want to include any extra data, just call this one.

All it does is **delegate to the next version** (the one with the `bytes memory data`), passing in an empty data payload.

This is useful for 99% of transfers, like when a user is simply sending an NFT from one wallet to another.

---

# 🛡️ `safeTransferFrom` (With Data)

```solidity
 
function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override {
    require(_isApprovedOrOwner(msg.sender, tokenId), "Not authorized");
    _safeTransfer(from, to, tokenId, data);
}

```

---

### 🧠 What’s Going On Here?

This is the **real** `safeTransferFrom` function — the one that does all the actual work.

It handles two important things:

---

### ✅ Step 1: Access Control Check

```solidity
 
require(_isApprovedOrOwner(msg.sender, tokenId), "Not authorized");

```

This ensures the caller is **allowed** to move this NFT.

So who’s allowed?

- The **owner** of the token
- Someone who’s been **approved** to transfer this specific token
- Or an **operator** who has general permission to manage all the owner’s tokens

If you’re not one of these three, the transfer is blocked.

---

### ⚙️ Step 2: Perform Safe Transfer

```solidity
 
_safeTransfer(from, to, tokenId, data);

```

This is where the magic happens.

It calls `_safeTransfer`, which:

- Moves the token
- Updates balances and ownership
- Clears previous approvals
- Checks if the recipient is a **smart contract**, and if so, makes sure it supports NFTs

If the recipient is a wallet: ✅ smooth transfer.

If it’s a contract that doesn’t implement `onERC721Received`: ❌ transaction is reverted.

This avoids accidentally “locking” NFTs inside contracts that don’t know what to do with them.

---

# 🧪 Minting NFTs

```solidity
 
    function mint(address to, string memory uri) public {
        uint256 tokenId = _tokenIdCounter;
        _tokenIdCounter++;

        _owners[tokenId] = to;
        _balances[to] += 1;
        _tokenURIs[tokenId] = uri;

        emit Transfer(address(0), to, tokenId);
    }

```

### 🧠 Explanation

This is your **minting function** — it creates a new NFT:

- Assigns it a unique tokenId.
- Gives ownership to the recipient.
- Stores its metadata URI.
- Emits a `Transfer` from the zero address (which signals minting).

---

### 🖼️ tokenURI

```solidity
 
    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_owners[tokenId] != address(0), "Token doesn't exist");
        return _tokenURIs[tokenId];
    }

```

### 🧠 Explanation

This is how you **get the metadata URL** for a given NFT — image, description, etc.

---

### 

# 🧩 Why This Function Design Pattern?

If you're wondering why this contract has so many functions — some public, some internal, some that look almost the same — it’s not overengineering. It’s **smart separation of responsibilities**. The idea is to break things down into small, predictable building blocks that each do *one thing well*. Public functions like `transferFrom` or `safeTransferFrom` handle **permission checks** and external inputs. Internal functions like `_transfer` or `_safeTransfer` do the **core logic** of moving tokens or updating state. And helper functions like `_isApprovedOrOwner` keep our access rules clean and reusable. This modular structure makes the contract **easier to understand, safer to maintain, and way less error-prone** — especially when you start building on top of it with more complex features. Think of it like assembling Lego bricks: each brick has a specific shape and purpose, but when you snap them together, you get a solid, complete NFT engine.

## 🚀 How to Run Your NFT Contract and Mint Your First Token

---

### 🧱 Prerequisites

Before you start, make sure you’ve got:

- A **MetaMask wallet** (with some test ETH on a testnet like Sepolia or an l2 testnet)
- The **Remix IDE** (no setup needed, runs in browser)
- An account on [**Pinata**](https://www.pinata.cloud/) (for uploading images + metadata to IPFS)

---

## ⚙️ Step-by-Step Breakdown

---

### ✅ 1. Deploy the Contract on Remix

1. Open Remix
2. Create a new file (e.g. `SimpleNFT.sol`) and paste your NFT contract code inside.
3. Make sure the compiler version is set to `0.8.19`
4. Compile the contract.
5. Go to the “Deploy & Run Transactions” tab:
    - Select **Injected Provider - MetaMask** as the environment
    - Connect your wallet
    - Choose the contract and hit **Deploy**

Your contract is now live on the testnet!

---

### 🖼️ 2. Upload Image to IPFS via Pinata

Here’s where we store the NFT’s **actual media file** — like an image — on a decentralized storage network.

1. Go to https://app.pinata.cloud/pinmanager
2. Click **Upload** → **File**
3. Upload your image (e.g., `dragon.png`)
4. Once uploaded, Pinata will give you an IPFS hash.
    
    It will look something like:
    
    ```
    
    QmYk...zKs
    
    ```
    
5. You can preview your image using:
    
    ```
    
    https://gateway.pinata.cloud/ipfs/QmYk...zKs
    
    ```
    

---

### 🧾 3. Create and Upload the Metadata JSON

NFTs don't just store images — they store **metadata** that describes the NFT. This metadata is stored in a JSON file.

Create a file like this on your local machine:

```json

{
  "name": "Dragon #1",
  "description": "A fierce fire-breathing NFT dragon.",
  "image": "ipfs://QmYk...zKs"
}

```

Upload this JSON file to Pinata just like the image (step 2).

Once uploaded, you’ll get another IPFS hash — this is your **token URI**.

Example URI:

```

ipfs://QmT7...2uN

```

This is what you’ll pass to your smart contract when minting the NFT.

---

### 🧪 4. Mint the NFT via Remix

1. In Remix, under “Deployed Contracts,” open up your contract’s methods.
2. Look for the `mint` function. It should look something like:

```solidity

function mint(address to, string memory uri) public

```

1. Fill in:
    - `to`: your wallet address (you can copy it from MetaMask)
    - `uri`: the IPFS link to your metadata, e.g.
    
    ```
    
    ipfs://QmT7...2uN
    
    ```
    
2. Hit **transact** and confirm the transaction in MetaMask.

Boom 💥! You’ve just minted your own NFT!

---

### 👀 5. View Your NFT on a Testnet Explorer or Marketplace

- Use your contract address
- Or try importing your contract and wallet to testnet versions of **OpenSea** or **Rarible**.

They’ll pick up the `tokenURI`, fetch the metadata from IPFS, and show your NFT image + name + description.

---

## 🧠 Why IPFS and Pinata?

- **Ethereum stores only the token ID + URI**, not actual media (too expensive).
- **IPFS** is a decentralized storage system — content stays available even if your website goes down.
- **Pinata** is an IPFS pinning service — it helps keep your files alive on IPFS and gives you easy tools to manage uploads.