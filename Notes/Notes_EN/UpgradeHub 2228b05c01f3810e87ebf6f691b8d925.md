# UpgradeHub

Imagine youâ€™ve launched a smart contract into the wild. Itâ€™s running smoothly, users are subscribing, the ETH is flowingâ€¦ and then, boom ðŸ’¥ â€” you discover a bug. Or maybe you want to add a new feature. Or you realize your logic could be way more efficient.

Now hereâ€™s the problem:

> You canâ€™t change a smart contract once itâ€™s deployed.
> 

At least, not traditionally.

In web2, if you fix a bug or add a feature, you just push an update to your server. But in web3? A smart contract is immutable. Once deployed, itâ€™s locked in.

Unlessâ€¦ you design it to be **upgradeable**.

---

## ðŸ”„ What Does Upgradeable Mean?

When we say **upgradeable contracts**, weâ€™re talking about separating **storage** from **logic**.

The idea is:

- You deploy one contract that stores the **data** â€” weâ€™ll call it the **proxy**.
- You deploy another contract that holds the **logic** â€” this is the actual code.
- The proxy uses `delegatecall` to execute logic from the external contract â€” but on **its own storage**.

So if you ever need to change behavior, you donâ€™t touch the proxy â€” you just point it to a new logic contract. All the data stays safe.

Pretty cool, right?

---

## ðŸ§° What We're Building: An Upgradeable Subscription System

Letâ€™s bring this idea to life by building a **modular subscription manager**, the kind you'd use for a SaaS app or dApp.

Hereâ€™s the game plan:

### 1. **`SubscriptionStorageLayout.sol`**

This is the blueprint. It defines:

- Who the owner is
- Where the logic contract lives
- The actual storage layout: user subscriptions, plan prices, durations, etc.

Think of this like the shared brain that both the proxy and logic contracts understand.

---

### 2. **`SubscriptionStorage.sol`**

This is the **proxy contract**:

- It owns the data
- It delegates all the logic to an external contract via `delegatecall`
- It can upgrade to a new logic contract at any time

So users interact with this contract â€” but behind the scenes, itâ€™s just forwarding their calls to whatever logic contract itâ€™s currently pointing to.

---

### 3. **`SubscriptionLogicV1.sol`**

The first version of our logic:

- Add subscription plans
- Let users subscribe
- Check if a user is active

Simple and clean â€” and works perfectly.

---

### 4. **`SubscriptionLogicV2.sol`**

An upgraded version with **extra powers**:

- Everything from V1 âœ…
- But now you can pause or resume user accounts ðŸ”’

Weâ€™ll switch the proxy to point to this contract when weâ€™re ready to upgrade.

---

## ðŸŽ¯ Why This Setup is Powerful

Letâ€™s say youâ€™ve got thousands of users subscribed. Their subscription info is saved in the proxy. Then you realize: â€œI want to let users pause their subscriptions.â€

In a non-upgradeable world, you'd be stuck. Youâ€™d either:

- Deploy a new contract and lose all the old data, or
- Migrate everything â€” which is a hassle and not user-friendly

But here?

You simply write a new logic contract with the pause/resume featuresâ€¦ and **call `upgradeTo()`**.

No migrations. No downtime. No user impact.

---

**So in the next sections, weâ€™ll go one contract at a time â€” explain what it does, how it works, and why this architecture is upgrade-safe and gas-friendly.**

Letâ€™s start with the shared layout.

## ðŸ“¦ `SubscriptionStorageLayout.sol` â€“ The Shared Memory Blueprint

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SubscriptionStorageLayout {
    address public logicContract;
    address public owner;

    struct Subscription {
        uint8 planId;
        uint256 expiry;
        bool paused;
    }

    mapping(address => Subscription) public subscriptions;
    mapping(uint8 => uint256) public planPrices;
    mapping(uint8 => uint256) public planDuration;
}

```

### âœ… Contract Declaration

```solidity
 
contract SubscriptionStorageLayout {

```

This is a standalone contract that **only holds state variables** â€” it doesnâ€™t include any functions (except for inherited logic later). The idea is to **separate storage from logic**, which is a key part of the proxy upgrade pattern.

This layout contract acts like a **blueprint** that defines the **memory structure** for both the proxy and the logic contracts.

By importing and inheriting this layout, both contracts can **share and manipulate the same data**, assuming it's in the same memory layout order â€” which is critical for `delegatecall` to work correctly.

---

### ðŸ”‘ `logicContract`

```solidity
 
    address public logicContract;

```

- This stores the **current implementation address** â€” the logic contract where the actual functionality lives.
- Itâ€™s used by the proxy contract to know **where to forward calls using `delegatecall`**.
- You can update this address later via the `upgradeTo()` function in the proxy to switch to a new version of the logic.

---

### ðŸ‘‘ `owner`

```solidity
 
    address public owner;

```

- This keeps track of the **admin or deployer** of the contract â€” the only one who can upgrade to new logic versions.
- You could expand this later with role-based access control or multisig ownership for more security.

---

### ðŸ“¦ `Subscription` Struct

```solidity
 
    struct Subscription {
        uint8 planId;
        uint256 expiry;
        bool paused;
    }

```

Letâ€™s unpack this:

- `uint8 planId`:
    
    The identifier for the user's plan. A small number like `1`, `2`, or `3` to represent different tiers (e.g., Basic, Pro, Premium).
    
    â†’ We use `uint8` to **save gas** compared to `uint256`.
    
- `uint256 expiry`:
    
    A timestamp indicating when the subscription runs out.
    
    â†’ We use `uint256` here since Unix timestamps are large numbers.
    
- `bool paused`:
    
    A toggle to temporarily deactivate a user's subscription **without deleting it**.
    
    â†’ Useful for allowing users to pause or resume their plan.
    

---

### ðŸ—‚ï¸ Subscription Mappings

```solidity
 
    mapping(address => Subscription) public subscriptions;

```

- Each user (`address`) gets their own `Subscription` object.
- This allows us to **track each user's active plan**, its expiry, and pause status.

```solidity
 
    mapping(uint8 => uint256) public planPrices;

```

- This defines how much ETH each plan costs.
- For example, `planPrices[1] = 0.01 ether`, `planPrices[2] = 0.05 ether`.

```solidity
 
    mapping(uint8 => uint256) public planDuration;

```

- This tells us **how long** each plan lasts (in seconds).
- For example, `planDuration[1] = 30 days`, `planDuration[2] = 365 days`.

## ðŸ§­ `SubscriptionStorage.sol` â€“ The Proxy Contract

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

contract SubscriptionStorage is SubscriptionStorageLayout {
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(address _logicContract) {
        owner = msg.sender;
        logicContract = _logicContract;
    }

    function upgradeTo(address _newLogic) external onlyOwner {
        logicContract = _newLogic;
    }

    fallback() external payable {
        address impl = logicContract;
        require(impl != address(0), "Logic contract not set");

        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

    receive() external payable {}
}

```

### Headers

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

```

- The usual license and version pragma.
- We **import** the shared storage layout â€” this makes sure the proxy has the same variable structure as the logic contract. If you remember, `delegatecall` means **code runs from logic contract but storage belongs to proxy**, so both must share the exact same layout.

---

### ðŸ”§ Contract Declaration

```solidity
 
contract SubscriptionStorage is SubscriptionStorageLayout {

```

We define a contract named `SubscriptionStorage`. This is not where your business logic lives â€” this is the **contract users will interact with**, but it will **delegate all real work** to the logic contract.

It **inherits** from `SubscriptionStorageLayout`, meaning it now owns:

- `logicContract` (pointer to the current logic)
- `owner`
- All the mappings (`subscriptions`, `planPrices`, `planDuration`)

---

### ðŸ” Owner Check Modifier

```solidity
 
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

```

- This modifier is used to **protect sensitive functions** â€” like upgrading the contract.
- Only the deployer (or whoever owns the contract) can change which logic is being used.

---

### ðŸ—ï¸ Constructor

```solidity
 
    constructor(address _logicContract) {
        owner = msg.sender;
        logicContract = _logicContract;
    }

```

This is the function that runs **once** when the proxy is first deployed.

- `owner = msg.sender`: The deployer becomes the owner.
- `logicContract = _logicContract`: You pass in the address of your initial logic contract â€” usually `SubscriptionLogicV1`.

So now your proxy knows which logic to use when users start interacting with it.

---

### ðŸ”„ Logic Upgrade

```solidity
 
    function upgradeTo(address _newLogic) external onlyOwner {
        logicContract = _newLogic;
    }

```

This function is what makes the entire upgradeable architecture possible.

- It updates `logicContract` to point to a **new contract** (like `SubscriptionLogicV2`).
- Protected with `onlyOwner`, so only the deployer can upgrade.
- When this happens, **the storage stays the same**, but all new interactions will use the new logic.

ðŸ§  Why is this powerful?

You can fix bugs, add features, or refactor code **without ever touching user data or asking people to redeploy**.

---

### âœ¨ The Fallback Function â€“ Where the Magic Happens

```solidity
 
    fallback() external payable {
        address impl = logicContract;
        require(impl != address(0), "Logic contract not set");

        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

```

This is the **most critical part** of the whole proxy setup.

Letâ€™s break it down:

### ðŸ§­ What is `fallback()`?

- Itâ€™s a special function that gets triggered **whenever a user calls a function that doesnâ€™t exist in this proxy contract**.
- Thatâ€™s perfect, because this proxy **has no business logic of its own**.
- So, this gets triggered *every time* users try to interact with a function in our other contracts (like `subscribe()` or `isActive()`).

### ðŸ› ï¸ What does the inline assembly do?

Letâ€™s decode it step-by-step:

```solidity
 
address impl = logicContract;
require(impl != address(0), "Logic contract not set");

```

- Make sure a logic contract has been set.
- Store it in `impl`.

---

```solidity
 
calldatacopy(0, 0, calldatasize())

```

- Copy the **input data** (function signature + arguments) to memory slot `0`.

```solidity
 
let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)

```

- This is the main event.
- Weâ€™re saying: â€œHey, run this input on the logic contract (`impl`)â€¦â€
- `delegatecall` runs the logic code, but uses **this proxyâ€™s storage** and **this proxyâ€™s context**.

---

```solidity
 
returndatacopy(0, 0, returndatasize())

```

- Copy whatever came back from the logic contractâ€™s execution to memory.
- Could be a return value or an error message.

```solidity
 
switch result
case 0 { revert(0, returndatasize()) }
default { return(0, returndatasize()) }

```

- If the logic call **failed**, we revert and return the error.
- Otherwise, we return the result back to the original caller â€” as if the proxy had executed it itself.

---

### ðŸ’¸ The `receive()` Function

```solidity
 
    receive() external payable {}

```

- A safety net that lets the proxy **accept raw ETH transfers**.
- You may not need it here, but it's often useful when the contract receives ETH directly (e.g., during a payment).

## ðŸ§© `SubscriptionLogicV1.sol` â€“ The First Logic Contract

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

contract SubscriptionLogicV1 is SubscriptionStorageLayout {
    function addPlan(uint8 planId, uint256 price, uint256 duration) external {
        planPrices[planId] = price;
        planDuration[planId] = duration;
    }

    function subscribe(uint8 planId) external payable {
        require(planPrices[planId] > 0, "Invalid plan");
        require(msg.value >= planPrices[planId], "Insufficient payment");

        Subscription storage s = subscriptions[msg.sender];
        if (block.timestamp < s.expiry) {
            s.expiry += planDuration[planId];
        } else {
            s.expiry = block.timestamp + planDuration[planId];
        }

        s.planId = planId;
        s.paused = false;
    }

    function isActive(address user) external view returns (bool) {
        Subscription memory s = subscriptions[user];
        return (block.timestamp < s.expiry && !s.paused);
    }
}

```

## ðŸ§© `SubscriptionLogicV1.sol` â€“ The First Logic Contract

```solidity
  
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

```

- Standard SPDX license and Solidity version.
- We **import the shared storage layout** so this logic contract has access to the **same state variables** (like `subscriptions`, `planPrices`, `planDuration`, etc.) as the proxy.
- This is **critical** because all storage updates will happen in the proxyâ€™s memory (via `delegatecall`), so both contracts must share the exact memory layout.

---

```solidity
  
contract SubscriptionLogicV1 is SubscriptionStorageLayout {

```

- We define the logic contract and inherit from `SubscriptionStorageLayout` so we get access to the proxyâ€™s storage when this contract is delegate-called.

This contract handles:

- Adding new plans
- Subscribing users
- Checking active status

Now, letâ€™s break down each function.

---

### 1ï¸âƒ£ `addPlan()`

```solidity
  
function addPlan(uint8 planId, uint256 price, uint256 duration) external {
    planPrices[planId] = price;
    planDuration[planId] = duration;
}

```

ðŸ§  **What this does:**

- Allows the owner (or whoever calls it) to register a new subscription plan.
- Each `planId` represents a unique plan (e.g. `1 = Basic`, `2 = Pro`).
- We store the price of the plan in `planPrices[planId]`.
- We also set how long the plan lasts using `planDuration[planId]`.

ðŸ“Œ **Why this is useful:**

- This makes the subscription system customizable â€” you can define multiple plans with different pricing tiers and durations.
- Since this contract can be upgraded, the plan model can evolve over time too.

---

### 2ï¸âƒ£ `subscribe()`

```solidity
  
function subscribe(uint8 planId) external payable {
    require(planPrices[planId] > 0, "Invalid plan");
    require(msg.value >= planPrices[planId], "Insufficient payment");

    Subscription storage s = subscriptions[msg.sender];
    if (block.timestamp < s.expiry) {
        s.expiry += planDuration[planId];
    } else {
        s.expiry = block.timestamp + planDuration[planId];
    }

    s.planId = planId;
    s.paused = false;
}

```

ðŸ§  **What this does:**

- Letâ€™s users **subscribe** to a specific plan by sending ETH.
- First, it checks:
    - If the plan is valid (`planPrices[planId] > 0`)
    - If the user sent enough ETH (`msg.value >= price`)
- Then we fetch the callerâ€™s subscription record from the `subscriptions` mapping.

ðŸ“¦ Two cases:

1. If the user already has time left (`block.timestamp < s.expiry`):
    - Add the new duration to the current expiry. This lets them **extend** their subscription.
2. If the subscription expired:
    - Reset the expiry to `now + duration`. Itâ€™s a **fresh subscription**.

We then:

- Set `s.planId = planId` to record the plan they chose.
- Unpause the subscription by setting `s.paused = false`.

ðŸ“Œ **Why this is smart:**

- Itâ€™s simple and gas-efficient.
- It supports both new and existing subscribers in one function.
- It automatically "resumes" paused subscriptions (useful for things like V2).

---

### 3ï¸âƒ£ `isActive()`

```solidity
  
function isActive(address user) external view returns (bool) {
    Subscription memory s = subscriptions[user];
    return (block.timestamp < s.expiry && !s.paused);
}

```

ðŸ§  **What this does:**

- Letâ€™s anyone check if a userâ€™s subscription is currently active.

It returns `true` **only if**:

- The current time is before the subscriptionâ€™s expiry
- And the subscription isnâ€™t paused

ðŸ“Œ **Why this matters:**

- This is the read-only helper youâ€™d use in:
    - Frontends (to show subscription status)
    - Gatekeeping access to premium features
    - Displaying renew prompts

## ðŸš€ `SubscriptionLogicV2.sol` â€“ Upgraded with Pause/Resume

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

contract SubscriptionLogicV2 is SubscriptionStorageLayout {
    function addPlan(uint8 planId, uint256 price, uint256 duration) external {
        planPrices[planId] = price;
        planDuration[planId] = duration;
    }

    function subscribe(uint8 planId) external payable {
        require(planPrices[planId] > 0, "Invalid plan");
        require(msg.value >= planPrices[planId], "Insufficient payment");

        Subscription storage s = subscriptions[msg.sender];
        if (block.timestamp < s.expiry) {
            s.expiry += planDuration[planId];
        } else {
            s.expiry = block.timestamp + planDuration[planId];
        }

        s.planId = planId;
        s.paused = false;
    }

    function isActive(address user) external view returns (bool) {
        Subscription memory s = subscriptions[user];
        return (block.timestamp < s.expiry && !s.paused);
    }

    function pauseAccount(address user) external {
        subscriptions[user].paused = true;
    }

    function resumeAccount(address user) external {
        subscriptions[user].paused = false;
    }
}

```

## ðŸš€ `SubscriptionLogicV2.sol` â€“ Upgraded with Pause/Resume

```solidity
  
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

```

This setup is the same as before â€” we're importing the shared storage layout so we can **safely use the proxyâ€™s storage** during `delegatecall`.

---

```solidity
  
contract SubscriptionLogicV2 is SubscriptionStorageLayout {

```

This defines the second version of our logic contract. By inheriting the layout, it has full access to the exact same storage structure as the proxy.

Letâ€™s now walk through each function, line by line.

---

### 1ï¸âƒ£ `addPlan()`

```solidity
  
function addPlan(uint8 planId, uint256 price, uint256 duration) external {
    planPrices[planId] = price;
    planDuration[planId] = duration;
}

```

âœ… **What it does:**

- Adds or updates a subscription plan.
- Uses `planId` as the identifier for the plan.
- Stores how much it costs and how long it lasts.

ðŸ§  **Same as V1** â€” we didnâ€™t change anything here, because it already works well.

---

### 2ï¸âƒ£ `subscribe()`

```solidity
  
function subscribe(uint8 planId) external payable {
    require(planPrices[planId] > 0, "Invalid plan");
    require(msg.value >= planPrices[planId], "Insufficient payment");

    Subscription storage s = subscriptions[msg.sender];
    if (block.timestamp < s.expiry) {
        s.expiry += planDuration[planId];
    } else {
        s.expiry = block.timestamp + planDuration[planId];
    }

    s.planId = planId;
    s.paused = false;
}

```

âœ… **What it does:**

- Users call this to subscribe or renew their plan.
- If the plan is still active, it extends the expiry.
- If expired, it sets a fresh expiry from now.
- It also ensures the subscription is **unpaused** â€” useful if the user is coming back after a break.

ðŸ§  Again, this is identical to V1 â€” no need to mess with whatâ€™s already working.

---

### 3ï¸âƒ£ `isActive()`

```solidity
  
function isActive(address user) external view returns (bool) {
    Subscription memory s = subscriptions[user];
    return (block.timestamp < s.expiry && !s.paused);
}

```

âœ… **What it does:**

- Returns `true` if:
    - The subscription hasnâ€™t expired
    - The subscription isnâ€™t paused

ðŸ§  Used by frontend apps or smart contracts to **check eligibility for premium features**.

---

### ðŸ†• 4ï¸âƒ£ `pauseAccount()`

```solidity
  
function pauseAccount(address user) external {
    subscriptions[user].paused = true;
}

```

ðŸ§  **What it does:**

- Manually pauses a userâ€™s account.
- Could be used by an admin, or delegated to the user themselves in a future version.

ðŸ“Œ **Why it matters:**

- Some users may want to freeze their subscription temporarily.
- Or, as an admin, you may want to suspend an account due to abuse or payment failure.

ðŸ§ª **It doesnâ€™t touch expiry** â€” so the clock still ticks, but the account is blocked from access.

---

### ðŸ†• 5ï¸âƒ£ `resumeAccount()`

```solidity
  
function resumeAccount(address user) external {
    subscriptions[user].paused = false;
}

```

âœ… **What it does:**

- Re-enables a paused subscription.

ðŸ§  Useful when:

- The user wants to unpause on their own
- Admins want to re-enable after resolving an issue

This simply flips the `paused` flag back to `false`, restoring access.

# ðŸ› ï¸ Runnng the Upgradeable Subscription Manager (in Remix)

Weâ€™re going to deploy a proxy-based subscription system with upgradeable logic using `delegatecall`. Follow these steps to test it out in **Remix**.

---

## ðŸ”§ Step 1: Create the 3 Contracts

Open Remix, then:

1. In the **File Explorer**, create these 3 new files:
    - `SubscriptionStorage.sol`
    - `SubscriptionLogicV1.sol`
    - `SubscriptionLogicV2.sol`
2. Paste the respective code into each file from the previous breakdowns.

---

## ðŸ§± Step 2: Compile All Contracts

1. Click the **Solidity Compiler tab** (left sidebar â€“ second icon).
2. Make sure the compiler version is set to `0.8.x` (anything in the 0.8 range).
3. Compile all three contracts:
    - `SubscriptionStorage.sol`
    - `SubscriptionLogicV1.sol`
    - `SubscriptionLogicV2.sol`

âœ… You should see `Compilation successful` for each.

---

## ðŸš€ Step 3: Deploy the Logic Contract (V1)

1. Go to the **Deploy & Run Transactions** tab (third icon).
2. In the **Contract Editor**, choose `SubscriptionLogicV1`. this will automatically load the contract in the deploy button
3. Click **Deploy**.
4. Copy the deployed contract address â€” you'll need it in the next step.

---

## ðŸ“¦ Step 4: Deploy the Proxy Contract

1. Switch  to `SubscriptionStorage`   in the contract editor
2. In the input box next to `Deploy`, paste the **V1 logic address** inside quotes:
    
    ```
    
    "0x1234...abcd"
    
    ```
    
3. Click **Deploy**.

ðŸŽ‰ You now have a proxy wired to your first logic contract!

- `logicV1 = <address of SubscriptionLogicV1>`
- `proxy = <address of SubscriptionStorage>`

---

## ðŸ§  Step 5: Interact with V1 via the Proxy

Since the proxy doesn't expose any logic functions itself, Remix wonâ€™t show buttons like `addPlan()` or `subscribe()` automatically.

Hereâ€™s how to interact using the **V1 ABI**:

### âž• Load the Proxy with V1 ABI

1. Scroll down to the **"At Address"** section in the Deploy tab.
2. Select `SubscriptionLogicV1` in the contract editor, this will allow remix to automatically pickup its abi
3. In the input box, paste your deployed **proxy address**.
4. Click **At Address**.
5. Now a new instance of v1 will be deployed, you can interact with it

âœ… Youâ€™ll now see V1 functions like `addPlan()` and `subscribe()` â€” but theyâ€™re being executed **through the proxy** via `delegatecall`.

---

## ðŸ’° Step 6: Test the Subscription Flow (V1)

Try these via the loaded proxy interface:

1. Call:
    
    ```solidity
       
    addPlan(1, 10000000000000000, 60)
    
    ```
    
    â†’ Adds a plan: **0.01 ETH for 60 seconds**
    
2. Call:
    
    ```solidity
       
    subscribe(1)
    
    ```
    
    â†’ Make sure to **send 0.01 ETH** with the transaction
    
3. Call:
    
    ```solidity
       
    isActive(<your wallet address>)
    
    ```
    
    â†’ Should return `true`
    

âœ… All this logic is coming from `SubscriptionLogicV1`, but executed **via the proxy**.

---

## ðŸ”„ Step 7: Upgrade to V2 Logic

1. In the contract editor, select `SubscriptionLogicV2`.
2. Click **Deploy**.
3. Copy the deployed V2 address:
    
    ```
    
    logicV2 = <address of SubscriptionLogicV2>
    
    ```
    
4. Scroll to your deployed **SubscriptionStorage** instance.
5. Call the `upgradeTo` funtion with the v2 address:
    
    ```solidity
       
    upgradeTo(logicV2)
    
    ```
    
    âœ… This tells the proxy to now use the V2 contract for logic.
    

---

## ðŸ§ª Step 8: Use V2 Features via the Same Proxy

You can now call the **new pause/resume functions** â€” still using the same proxy address.

1. Scroll to **"At Address"** again
2. Select `SubscriptionLogicV2` from the contract editor
3. Paste your **proxy address** again and click **At Address**
4. Now, you will see a new instance of V2

You should now see additional functions like:

- `pauseAccount(address)`
- `resumeAccount(address)`

### Test them:

1. Call:
    
    ```solidity
       
    pauseAccount(<your wallet address>)
    
    ```
    
2. Then call:
    
    ```solidity
       
    isActive(<your wallet address>)
    
    ```
    
    â†’ Should return `false`
    
3. Call:
    
    ```solidity
       
    resumeAccount(<your wallet address>)
    
    ```
    
    â†’ `isActive()` should now return `true` again
    

---

## ðŸŽ‰ You Did It!

You just:

- Deployed a logic contract (V1)
- Routed calls through a proxy
- Upgraded to a new logic contract (V2)
- Preserved all data in the same storage

Welcome to the world of **upgradeable smart contracts** â€” the same pattern used by giants like OpenZeppelinâ€™s UUPS and Proxy systems.