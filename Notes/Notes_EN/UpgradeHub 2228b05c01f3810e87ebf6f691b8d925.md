# UpgradeHub

Imagine you‚Äôve launched a smart contract into the wild. It‚Äôs running smoothly, users are subscribing, the ETH is flowing‚Ä¶ and then, boom üí• ‚Äî you discover a bug. Or maybe you want to add a new feature. Or you realize your logic could be way more efficient.

Now here‚Äôs the problem:

> You can‚Äôt change a smart contract once it‚Äôs deployed.
> 

At least, not traditionally.

In web2, if you fix a bug or add a feature, you just push an update to your server. But in web3? A smart contract is immutable. Once deployed, it‚Äôs locked in.

Unless‚Ä¶ you design it to be **upgradeable**.

---

## üîÑ What Does Upgradeable Mean?

When we say **upgradeable contracts**, we‚Äôre talking about separating **storage** from **logic**.

The idea is:

- You deploy one contract that stores the **data** ‚Äî we‚Äôll call it the **proxy**.
- You deploy another contract that holds the **logic** ‚Äî this is the actual code.
- The proxy uses `delegatecall` to execute logic from the external contract ‚Äî but on **its own storage**.

So if you ever need to change behavior, you don‚Äôt touch the proxy ‚Äî you just point it to a new logic contract. All the data stays safe.

Pretty cool, right?

---

## üß∞ What We're Building: An Upgradeable Subscription System

Let‚Äôs bring this idea to life by building a **modular subscription manager**, the kind you'd use for a SaaS app or dApp.

Here‚Äôs the game plan:

### 1. **`SubscriptionStorageLayout.sol`**

This is the blueprint. It defines:

- Who the owner is
- Where the logic contract lives
- The actual storage layout: user subscriptions, plan prices, durations, etc.

Think of this like the shared brain that both the proxy and logic contracts understand.

---

### 2. **`SubscriptionStorage.sol`**

This is the **proxy contract**:

- It owns the data
- It delegates all the logic to an external contract via `delegatecall`
- It can upgrade to a new logic contract at any time

So users interact with this contract ‚Äî but behind the scenes, it‚Äôs just forwarding their calls to whatever logic contract it‚Äôs currently pointing to.

---

### 3. **`SubscriptionLogicV1.sol`**

The first version of our logic:

- Add subscription plans
- Let users subscribe
- Check if a user is active

Simple and clean ‚Äî and works perfectly.

---

### 4. **`SubscriptionLogicV2.sol`**

An upgraded version with **extra powers**:

- Everything from V1 ‚úÖ
- But now you can pause or resume user accounts üîí

We‚Äôll switch the proxy to point to this contract when we‚Äôre ready to upgrade.

---

## üéØ Why This Setup is Powerful

Let‚Äôs say you‚Äôve got thousands of users subscribed. Their subscription info is saved in the proxy. Then you realize: ‚ÄúI want to let users pause their subscriptions.‚Äù

In a non-upgradeable world, you'd be stuck. You‚Äôd either:

- Deploy a new contract and lose all the old data, or
- Migrate everything ‚Äî which is a hassle and not user-friendly

But here?

You simply write a new logic contract with the pause/resume features‚Ä¶ and **call `upgradeTo()`**.

No migrations. No downtime. No user impact.

---

**So in the next sections, we‚Äôll go one contract at a time ‚Äî explain what it does, how it works, and why this architecture is upgrade-safe and gas-friendly.**

Let‚Äôs start with the shared layout.

## üì¶ `SubscriptionStorageLayout.sol` ‚Äì The Shared Memory Blueprint

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SubscriptionStorageLayout {
    address public logicContract;
    address public owner;

    struct Subscription {
        uint8 planId;
        uint256 expiry;
        bool paused;
    }

    mapping(address => Subscription) public subscriptions;
    mapping(uint8 => uint256) public planPrices;
    mapping(uint8 => uint256) public planDuration;
}

```

### ‚úÖ Contract Declaration

```solidity
 
contract SubscriptionStorageLayout {

```

This is a standalone contract that **only holds state variables** ‚Äî it doesn‚Äôt include any functions (except for inherited logic later). The idea is to **separate storage from logic**, which is a key part of the proxy upgrade pattern.

This layout contract acts like a **blueprint** that defines the **memory structure** for both the proxy and the logic contracts.

By importing and inheriting this layout, both contracts can **share and manipulate the same data**, assuming it's in the same memory layout order ‚Äî which is critical for `delegatecall` to work correctly.

---

### üîë `logicContract`

```solidity
 
    address public logicContract;

```

- This stores the **current implementation address** ‚Äî the logic contract where the actual functionality lives.
- It‚Äôs used by the proxy contract to know **where to forward calls using `delegatecall`**.
- You can update this address later via the `upgradeTo()` function in the proxy to switch to a new version of the logic.

---

### üëë `owner`

```solidity
 
    address public owner;

```

- This keeps track of the **admin or deployer** of the contract ‚Äî the only one who can upgrade to new logic versions.
- You could expand this later with role-based access control or multisig ownership for more security.

---

### üì¶ `Subscription` Struct

```solidity
 
    struct Subscription {
        uint8 planId;
        uint256 expiry;
        bool paused;
    }

```

Let‚Äôs unpack this:

- `uint8 planId`:
    
    The identifier for the user's plan. A small number like `1`, `2`, or `3` to represent different tiers (e.g., Basic, Pro, Premium).
    
    ‚Üí We use `uint8` to **save gas** compared to `uint256`.
    
- `uint256 expiry`:
    
    A timestamp indicating when the subscription runs out.
    
    ‚Üí We use `uint256` here since Unix timestamps are large numbers.
    
- `bool paused`:
    
    A toggle to temporarily deactivate a user's subscription **without deleting it**.
    
    ‚Üí Useful for allowing users to pause or resume their plan.
    

---

### üóÇÔ∏è Subscription Mappings

```solidity
 
    mapping(address => Subscription) public subscriptions;

```

- Each user (`address`) gets their own `Subscription` object.
- This allows us to **track each user's active plan**, its expiry, and pause status.

```solidity
 
    mapping(uint8 => uint256) public planPrices;

```

- This defines how much ETH each plan costs.
- For example, `planPrices[1] = 0.01 ether`, `planPrices[2] = 0.05 ether`.

```solidity
 
    mapping(uint8 => uint256) public planDuration;

```

- This tells us **how long** each plan lasts (in seconds).
- For example, `planDuration[1] = 30 days`, `planDuration[2] = 365 days`.

## üß≠ `SubscriptionStorage.sol` ‚Äì The Proxy Contract

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

contract SubscriptionStorage is SubscriptionStorageLayout {
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(address _logicContract) {
        owner = msg.sender;
        logicContract = _logicContract;
    }

    function upgradeTo(address _newLogic) external onlyOwner {
        logicContract = _newLogic;
    }

    fallback() external payable {
        address impl = logicContract;
        require(impl != address(0), "Logic contract not set");

        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

    receive() external payable {}
}

```

### Headers

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

```

- The usual license and version pragma.
- We **import** the shared storage layout ‚Äî this makes sure the proxy has the same variable structure as the logic contract. If you remember, `delegatecall` means **code runs from logic contract but storage belongs to proxy**, so both must share the exact same layout.

---

### üîß Contract Declaration

```solidity
 
contract SubscriptionStorage is SubscriptionStorageLayout {

```

We define a contract named `SubscriptionStorage`. This is not where your business logic lives ‚Äî this is the **contract users will interact with**, but it will **delegate all real work** to the logic contract.

It **inherits** from `SubscriptionStorageLayout`, meaning it now owns:

- `logicContract` (pointer to the current logic)
- `owner`
- All the mappings (`subscriptions`, `planPrices`, `planDuration`)

---

### üîê Owner Check Modifier

```solidity
 
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

```

- This modifier is used to **protect sensitive functions** ‚Äî like upgrading the contract.
- Only the deployer (or whoever owns the contract) can change which logic is being used.

---

### üèóÔ∏è Constructor

```solidity
 
    constructor(address _logicContract) {
        owner = msg.sender;
        logicContract = _logicContract;
    }

```

This is the function that runs **once** when the proxy is first deployed.

- `owner = msg.sender`: The deployer becomes the owner.
- `logicContract = _logicContract`: You pass in the address of your initial logic contract ‚Äî usually `SubscriptionLogicV1`.

So now your proxy knows which logic to use when users start interacting with it.

---

### üîÑ Logic Upgrade

```solidity
 
    function upgradeTo(address _newLogic) external onlyOwner {
        logicContract = _newLogic;
    }

```

This function is what makes the entire upgradeable architecture possible.

- It updates `logicContract` to point to a **new contract** (like `SubscriptionLogicV2`).
- Protected with `onlyOwner`, so only the deployer can upgrade.
- When this happens, **the storage stays the same**, but all new interactions will use the new logic.

üß† Why is this powerful?

You can fix bugs, add features, or refactor code **without ever touching user data or asking people to redeploy**.

---

### ‚ú® The Fallback Function ‚Äì Where the Magic Happens

```solidity
 
    fallback() external payable {
        address impl = logicContract;
        require(impl != address(0), "Logic contract not set");

        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

```

This is the **most critical part** of the whole proxy setup.

Let‚Äôs break it down:

### üß≠ What is `fallback()`?

- It‚Äôs a special function that gets triggered **whenever a user calls a function that doesn‚Äôt exist in this proxy contract**.
- That‚Äôs perfect, because this proxy **has no business logic of its own**.
- So, this gets triggered *every time* users try to interact with a function in our other contracts (like `subscribe()` or `isActive()`).

### üõ†Ô∏è What does the inline assembly do?

Let‚Äôs decode it step-by-step:

```solidity
 
address impl = logicContract;
require(impl != address(0), "Logic contract not set");

```

- Make sure a logic contract has been set.
- Store it in `impl`.

---

```solidity
 
calldatacopy(0, 0, calldatasize())

```

- Copy the **input data** (function signature + arguments) to memory slot `0`.

```solidity
 
let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)

```

- This is the main event.
- We‚Äôre saying: ‚ÄúHey, run this input on the logic contract (`impl`)‚Ä¶‚Äù
- `delegatecall` runs the logic code, but uses **this proxy‚Äôs storage** and **this proxy‚Äôs context**.

---

```solidity
 
returndatacopy(0, 0, returndatasize())

```

- Copy whatever came back from the logic contract‚Äôs execution to memory.
- Could be a return value or an error message.

```solidity
 
switch result
case 0 { revert(0, returndatasize()) }
default { return(0, returndatasize()) }

```

- If the logic call **failed**, we revert and return the error.
- Otherwise, we return the result back to the original caller ‚Äî as if the proxy had executed it itself.

---

### üí∏ The `receive()` Function

```solidity
 
    receive() external payable {}

```

- A safety net that lets the proxy **accept raw ETH transfers**.
- You may not need it here, but it's often useful when the contract receives ETH directly (e.g., during a payment).

## üß© `SubscriptionLogicV1.sol` ‚Äì The First Logic Contract

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

contract SubscriptionLogicV1 is SubscriptionStorageLayout {
    function addPlan(uint8 planId, uint256 price, uint256 duration) external {
        planPrices[planId] = price;
        planDuration[planId] = duration;
    }

    function subscribe(uint8 planId) external payable {
        require(planPrices[planId] > 0, "Invalid plan");
        require(msg.value >= planPrices[planId], "Insufficient payment");

        Subscription storage s = subscriptions[msg.sender];
        if (block.timestamp < s.expiry) {
            s.expiry += planDuration[planId];
        } else {
            s.expiry = block.timestamp + planDuration[planId];
        }

        s.planId = planId;
        s.paused = false;
    }

    function isActive(address user) external view returns (bool) {
        Subscription memory s = subscriptions[user];
        return (block.timestamp < s.expiry && !s.paused);
    }
}

```

## üß© `SubscriptionLogicV1.sol` ‚Äì The First Logic Contract

```solidity
  
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

```

- Standard SPDX license and Solidity version.
- We **import the shared storage layout** so this logic contract has access to the **same state variables** (like `subscriptions`, `planPrices`, `planDuration`, etc.) as the proxy.
- This is **critical** because all storage updates will happen in the proxy‚Äôs memory (via `delegatecall`), so both contracts must share the exact memory layout.

---

```solidity
  
contract SubscriptionLogicV1 is SubscriptionStorageLayout {

```

- We define the logic contract and inherit from `SubscriptionStorageLayout` so we get access to the proxy‚Äôs storage when this contract is delegate-called.

This contract handles:

- Adding new plans
- Subscribing users
- Checking active status

Now, let‚Äôs break down each function.

---

### 1Ô∏è‚É£ `addPlan()`

```solidity
  
function addPlan(uint8 planId, uint256 price, uint256 duration) external {
    planPrices[planId] = price;
    planDuration[planId] = duration;
}

```

üß† **What this does:**

- Allows the owner (or whoever calls it) to register a new subscription plan.
- Each `planId` represents a unique plan (e.g. `1 = Basic`, `2 = Pro`).
- We store the price of the plan in `planPrices[planId]`.
- We also set how long the plan lasts using `planDuration[planId]`.

üìå **Why this is useful:**

- This makes the subscription system customizable ‚Äî you can define multiple plans with different pricing tiers and durations.
- Since this contract can be upgraded, the plan model can evolve over time too.

---

### 2Ô∏è‚É£ `subscribe()`

```solidity
  
function subscribe(uint8 planId) external payable {
    require(planPrices[planId] > 0, "Invalid plan");
    require(msg.value >= planPrices[planId], "Insufficient payment");

    Subscription storage s = subscriptions[msg.sender];
    if (block.timestamp < s.expiry) {
        s.expiry += planDuration[planId];
    } else {
        s.expiry = block.timestamp + planDuration[planId];
    }

    s.planId = planId;
    s.paused = false;
}

```

üß† **What this does:**

- Let‚Äôs users **subscribe** to a specific plan by sending ETH.
- First, it checks:
    - If the plan is valid (`planPrices[planId] > 0`)
    - If the user sent enough ETH (`msg.value >= price`)
- Then we fetch the caller‚Äôs subscription record from the `subscriptions` mapping.

üì¶ Two cases:

1. If the user already has time left (`block.timestamp < s.expiry`):
    - Add the new duration to the current expiry. This lets them **extend** their subscription.
2. If the subscription expired:
    - Reset the expiry to `now + duration`. It‚Äôs a **fresh subscription**.

We then:

- Set `s.planId = planId` to record the plan they chose.
- Unpause the subscription by setting `s.paused = false`.

üìå **Why this is smart:**

- It‚Äôs simple and gas-efficient.
- It supports both new and existing subscribers in one function.
- It automatically "resumes" paused subscriptions (useful for things like V2).

---

### 3Ô∏è‚É£ `isActive()`

```solidity
  
function isActive(address user) external view returns (bool) {
    Subscription memory s = subscriptions[user];
    return (block.timestamp < s.expiry && !s.paused);
}

```

üß† **What this does:**

- Let‚Äôs anyone check if a user‚Äôs subscription is currently active.

It returns `true` **only if**:

- The current time is before the subscription‚Äôs expiry
- And the subscription isn‚Äôt paused

üìå **Why this matters:**

- This is the read-only helper you‚Äôd use in:
    - Frontends (to show subscription status)
    - Gatekeeping access to premium features
    - Displaying renew prompts

## üöÄ `SubscriptionLogicV2.sol` ‚Äì Upgraded with Pause/Resume

```solidity
 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

contract SubscriptionLogicV2 is SubscriptionStorageLayout {
    function addPlan(uint8 planId, uint256 price, uint256 duration) external {
        planPrices[planId] = price;
        planDuration[planId] = duration;
    }

    function subscribe(uint8 planId) external payable {
        require(planPrices[planId] > 0, "Invalid plan");
        require(msg.value >= planPrices[planId], "Insufficient payment");

        Subscription storage s = subscriptions[msg.sender];
        if (block.timestamp < s.expiry) {
            s.expiry += planDuration[planId];
        } else {
            s.expiry = block.timestamp + planDuration[planId];
        }

        s.planId = planId;
        s.paused = false;
    }

    function isActive(address user) external view returns (bool) {
        Subscription memory s = subscriptions[user];
        return (block.timestamp < s.expiry && !s.paused);
    }

    function pauseAccount(address user) external {
        subscriptions[user].paused = true;
    }

    function resumeAccount(address user) external {
        subscriptions[user].paused = false;
    }
}

```

## üöÄ `SubscriptionLogicV2.sol` ‚Äì Upgraded with Pause/Resume

```solidity
  
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SubscriptionStorageLayout.sol";

```

This setup is the same as before ‚Äî we're importing the shared storage layout so we can **safely use the proxy‚Äôs storage** during `delegatecall`.

---

```solidity
  
contract SubscriptionLogicV2 is SubscriptionStorageLayout {

```

This defines the second version of our logic contract. By inheriting the layout, it has full access to the exact same storage structure as the proxy.

Let‚Äôs now walk through each function, line by line.

---

### 1Ô∏è‚É£ `addPlan()`

```solidity
  
function addPlan(uint8 planId, uint256 price, uint256 duration) external {
    planPrices[planId] = price;
    planDuration[planId] = duration;
}

```

‚úÖ **What it does:**

- Adds or updates a subscription plan.
- Uses `planId` as the identifier for the plan.
- Stores how much it costs and how long it lasts.

üß† **Same as V1** ‚Äî we didn‚Äôt change anything here, because it already works well.

---

### 2Ô∏è‚É£ `subscribe()`

```solidity
  
function subscribe(uint8 planId) external payable {
    require(planPrices[planId] > 0, "Invalid plan");
    require(msg.value >= planPrices[planId], "Insufficient payment");

    Subscription storage s = subscriptions[msg.sender];
    if (block.timestamp < s.expiry) {
        s.expiry += planDuration[planId];
    } else {
        s.expiry = block.timestamp + planDuration[planId];
    }

    s.planId = planId;
    s.paused = false;
}

```

‚úÖ **What it does:**

- Users call this to subscribe or renew their plan.
- If the plan is still active, it extends the expiry.
- If expired, it sets a fresh expiry from now.
- It also ensures the subscription is **unpaused** ‚Äî useful if the user is coming back after a break.

üß† Again, this is identical to V1 ‚Äî no need to mess with what‚Äôs already working.

---

### 3Ô∏è‚É£ `isActive()`

```solidity
  
function isActive(address user) external view returns (bool) {
    Subscription memory s = subscriptions[user];
    return (block.timestamp < s.expiry && !s.paused);
}

```

‚úÖ **What it does:**

- Returns `true` if:
    - The subscription hasn‚Äôt expired
    - The subscription isn‚Äôt paused

üß† Used by frontend apps or smart contracts to **check eligibility for premium features**.

---

### üÜï 4Ô∏è‚É£ `pauseAccount()`

```solidity
  
function pauseAccount(address user) external {
    subscriptions[user].paused = true;
}

```

üß† **What it does:**

- Manually pauses a user‚Äôs account.
- Could be used by an admin, or delegated to the user themselves in a future version.

üìå **Why it matters:**

- Some users may want to freeze their subscription temporarily.
- Or, as an admin, you may want to suspend an account due to abuse or payment failure.

üß™ **It doesn‚Äôt touch expiry** ‚Äî so the clock still ticks, but the account is blocked from access.

---

### üÜï 5Ô∏è‚É£ `resumeAccount()`

```solidity
  
function resumeAccount(address user) external {
    subscriptions[user].paused = false;
}

```

‚úÖ **What it does:**

- Re-enables a paused subscription.

üß† Useful when:

- The user wants to unpause on their own
- Admins want to re-enable after resolving an issue

This simply flips the `paused` flag back to `false`, restoring access.

# üõ†Ô∏è Runnng the Upgradeable Subscription Manager (in Remix)

We‚Äôre going to deploy a proxy-based subscription system with upgradeable logic using `delegatecall`. Follow these steps to test it out in **Remix**.

---

## üîß Step 1: Create the 3 Contracts

Open Remix, then:

1. In the **File Explorer**, create these 3 new files:
    - `SubscriptionStorage.sol`
    - `SubscriptionLogicV1.sol`
    - `SubscriptionLogicV2.sol`
2. Paste the respective code into each file from the previous breakdowns.

---

## üß± Step 2: Compile All Contracts

1. Click the **Solidity Compiler tab** (left sidebar ‚Äì second icon).
2. Make sure the compiler version is set to `0.8.x` (anything in the 0.8 range).
3. Compile all three contracts:
    - `SubscriptionStorage.sol`
    - `SubscriptionLogicV1.sol`
    - `SubscriptionLogicV2.sol`

‚úÖ You should see `Compilation successful` for each.

---

## üöÄ Step 3: Deploy the Logic Contract (V1)

1. Go to the **Deploy & Run Transactions** tab (third icon).
2. In the **Contract Editor**, choose `SubscriptionLogicV1`. this will automatically load the contract in the deploy button
3. Click **Deploy**.
4. Copy the deployed contract address ‚Äî you'll need it in the next step.

---

## üì¶ Step 4: Deploy the Proxy Contract

1. Switch  to `SubscriptionStorage`   in the contract editor
2. In the input box next to `Deploy`, paste the **V1 logic address** inside quotes:
    
    ```
    
    "0x1234...abcd"
    
    ```
    
3. Click **Deploy**.

üéâ You now have a proxy wired to your first logic contract!

- `logicV1 = <address of SubscriptionLogicV1>`
- `proxy = <address of SubscriptionStorage>`

---

## üß† Step 5: Interact with V1 via the Proxy

Since the proxy doesn't expose any logic functions itself, Remix won‚Äôt show buttons like `addPlan()` or `subscribe()` automatically.

Here‚Äôs how to interact using the **V1 ABI**:

### ‚ûï Load the Proxy with V1 ABI

1. Scroll down to the **"At Address"** section in the Deploy tab.
2. Select `SubscriptionLogicV1` in the contract editor, this will allow remix to automatically pickup its abi
3. In the input box, paste your deployed **proxy address**.
4. Click **At Address**.
5. Now a new instance of v1 will be deployed, you can interact with it

‚úÖ You‚Äôll now see V1 functions like `addPlan()` and `subscribe()` ‚Äî but they‚Äôre being executed **through the proxy** via `delegatecall`.

---

## üí∞ Step 6: Test the Subscription Flow (V1)

Try these via the loaded proxy interface:

1. Call:
    
    ```solidity
       
    addPlan(1, 10000000000000000, 60)
    
    ```
    
    ‚Üí Adds a plan: **0.01 ETH for 60 seconds**
    
2. Call:
    
    ```solidity
       
    subscribe(1)
    
    ```
    
    ‚Üí Make sure to **send 0.01 ETH** with the transaction
    
3. Call:
    
    ```solidity
       
    isActive(<your wallet address>)
    
    ```
    
    ‚Üí Should return `true`
    

‚úÖ All this logic is coming from `SubscriptionLogicV1`, but executed **via the proxy**.

---

## üîÑ Step 7: Upgrade to V2 Logic

1. In the contract editor, select `SubscriptionLogicV2`.
2. Click **Deploy**.
3. Copy the deployed V2 address:
    
    ```
    
    logicV2 = <address of SubscriptionLogicV2>
    
    ```
    
4. Scroll to your deployed **SubscriptionStorage** instance.
5. Call the `upgradeTo` funtion with the v2 address:
    
    ```solidity
       
    upgradeTo(logicV2)
    
    ```
    
    ‚úÖ This tells the proxy to now use the V2 contract for logic.
    

---

## üß™ Step 8: Use V2 Features via the Same Proxy

You can now call the **new pause/resume functions** ‚Äî still using the same proxy address.

1. Scroll to **"At Address"** again
2. Select `SubscriptionLogicV2` from the contract editor
3. Paste your **proxy address** again and click **At Address**
4. Now, you will see a new instance of V2

You should now see additional functions like:

- `pauseAccount(address)`
- `resumeAccount(address)`

### Test them:

1. Call:
    
    ```solidity
       
    pauseAccount(<your wallet address>)
    
    ```
    
2. Then call:
    
    ```solidity
       
    isActive(<your wallet address>)
    
    ```
    
    ‚Üí Should return `false`
    
3. Call:
    
    ```solidity
       
    resumeAccount(<your wallet address>)
    
    ```
    
    ‚Üí `isActive()` should now return `true` again
    

---

## üéâ You Did It!

You just:

- Deployed a logic contract (V1)
- Routed calls through a proxy
- Upgraded to a new logic contract (V2)
- Preserved all data in the same storage

Welcome to the world of **upgradeable smart contracts** ‚Äî the same pattern used by giants like OpenZeppelin‚Äôs UUPS and Proxy systems.