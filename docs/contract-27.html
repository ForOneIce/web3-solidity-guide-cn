<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YieldFarming - 收益农场 - Solidity学习</title>
    <link href="https://fonts.googleapis.com/css2?family=Gochi+Hand&family=Reenie+Beanie&family=Comic+Neue:ital,wght@0,400;0,700;1,400&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --accent: #4cc9f0;
            --light: #f8f9fa;
            --dark: #212529;
            --easy: #43AA8B;
            --medium: #F8961E;
            --hard: #E71D36;
            --expert: #7209B7;
            --warm-brown: #8B7355;
            --parchment: #F5F1E6;
            --vintage-blue: #6B8E9F;
            --warm-red: #C44536;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Comic Neue', cursive;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf9 100%);
            color: var(--dark);
            line-height: 1.8;
            background-image: radial-gradient(#d0e3ff 1px, transparent 1px);
            background-size: 30px 30px;
        }
        
        .nav-bar {
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px 20px;
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .nav-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .back-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 10px;
            font-family: 'Comic Neue', cursive;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .back-btn:hover {
            background: var(--secondary);
            transform: translateX(-3px);
        }
        
        .nav-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.3rem;
            color: var(--secondary);
        }
        
        .nav-right {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .nav-btn {
            background: white;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 5px 15px;
            border-radius: 8px;
            font-family: 'Comic Neue', cursive;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
        }
        
        .nav-btn:hover {
            background: var(--primary);
            color: white;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px 20px;
        }
        
        .hero-section {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            border-top: 5px solid var(--accent);
        }
        
        .hero-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .hero-title {
            flex: 1;
            min-width: 250px;
        }
        
        .day-badge {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 8px 20px;
            border-radius: 15px;
            font-family: 'Gochi Hand', cursive;
            font-size: 1.2rem;
            margin-bottom: 10px;
            display: inline-block;
        }
        
        h1 {
            font-family: 'Gochi Hand', cursive;
            font-size: 2.8rem;
            color: var(--secondary);
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 20px;
        }
        
        .meta-tags {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .difficulty-badge {
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            color: white;
            font-size: 1rem;
        }
        
        .tag {
            background: var(--light);
            padding: 5px 15px;
            border-radius: 15px;
            color: var(--secondary);
            font-size: 0.9rem;
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 25px;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.1);
        }
        
        .section-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 2rem;
            color: var(--secondary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px dashed var(--accent);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .key-points {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .key-point {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--accent);
        }
        
        .key-point-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .concept-card {
            background: linear-gradient(135deg, #e6f7ff, #d6f0ff);
            border-left: 5px solid var(--primary);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .concept-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.4rem;
            color: var(--secondary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        pre {
            background: #282c34;
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
            margin: 15px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }
        
        code {
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #f8f8f2;
        }
        
        .inline-code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Fira Code', monospace;
            color: var(--hard);
            font-size: 0.9em;
        }
        
        .navigation-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .nav-footer-btn {
            flex: 1;
            min-width: 200px;
            background: white;
            border: 3px solid var(--primary);
            padding: 20px;
            border-radius: 15px;
            text-decoration: none;
            color: var(--dark);
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .nav-footer-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .nav-footer-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .nav-footer-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.3rem;
        }        
        /* 参考答案模块样式 - 温暖治愈风格 */
        .answer-reference {
            position: relative;
            margin: 60px 0 30px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .envelope-container {
            position: relative;
            width: 340px;
            height: 240px;
            cursor: pointer;
            perspective: 1200px;
            margin-bottom: 20px;
            filter: drop-shadow(0 10px 20px rgba(139, 115, 85, 0.2));
        }
        
        .envelope {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        .envelope-front, .envelope-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .envelope-front {
            background: linear-gradient(135deg, #f9f3e9, #e8dfd1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #d4c9b8;
        }
        
        .envelope-flap {
            position: absolute;
            top: -70px;
            width: 0;
            height: 0;
            border-left: 170px solid transparent;
            border-right: 170px solid transparent;
            border-bottom: 70px solid #e8dfd1;
            z-index: 1;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.1));
        }
        
        .envelope-flap::after {
            content: "";
            position: absolute;
            top: 3px;
            left: -170px;
            width: 0;
            height: 0;
            border-left: 170px solid transparent;
            border-right: 170px solid transparent;
            border-bottom: 67px solid #f9f3e9;
        }
        
        .envelope-seal {
            position: absolute;
            bottom: 25px;
            right: 35px;
            width: 70px;
            height: 70px;
            background: radial-gradient(circle at 30% 30%, #C44536, #8B2E24);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 2;
            border: 2px solid #A52A2A;
        }
        
        .seal-icon {
            color: #F5F1E6;
            font-size: 1.8rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .envelope-text {
            font-family: 'Reenie Beanie', cursive;
            font-size: 2.4rem;
            color: var(--warm-brown);
            z-index: 2;
            position: relative;
            margin-top: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            letter-spacing: 1px;
        }
        
        .envelope-pattern {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 15% 25%, rgba(139, 115, 85, 0.05) 3px, transparent 3px),
                radial-gradient(circle at 85% 75%, rgba(139, 115, 85, 0.05) 3px, transparent 3px);
            background-size: 40px 40px;
            z-index: 0;
        }
        
        .envelope-back {
            background: linear-gradient(135deg, #f5f1e6, #e8dfd1);
            transform: rotateY(180deg);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d4c9b8;
        }
        
        .envelope-container:hover .envelope {
            transform: rotateY(10deg) translateY(-5px);
        }
        
        .envelope-container.open .envelope {
            transform: rotateY(180deg);
        }
        
        .envelope-hint {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.3rem;
            color: var(--warm-brown);
            margin-top: 15px;
            opacity: 0.9;
            background: rgba(245, 241, 230, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
        }
        
        /* 弹窗样式 */
        .answer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            background: rgba(107, 142, 159, 0.7);
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(3px);
        }
        
        .letter-container {
            width: 90%;
            max-width: 900px;
            height: 80vh;
            background: #F5F1E6;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(107, 142, 159, 0.4);
            overflow: hidden;
            transform: scale(0);
            transition: transform 0.7s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            flex-direction: column;
            position: relative;
            border: 1px solid #d4c9b8;
        }
        
        .answer-modal.open .letter-container {
            transform: scale(1);
        }
        
        .letter-header {
            background: linear-gradient(135deg, #8B7355, #6B5A45);
            padding: 25px 30px;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-bottom: 2px dashed #A5947A;
        }
        
        .letter-title {
            font-family: 'Reenie Beanie', cursive;
            font-size: 3rem;
            color: #F5F1E6;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            letter-spacing: 2px;
        }
        
        .letter-subtitle {
            color: rgba(245, 241, 230, 0.9);
            font-size: 1.3rem;
            font-family: 'Gochi Hand', cursive;
        }
        
        .close-letter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(245, 241, 230, 0.2);
            color: #F5F1E6;
            border: 1px solid rgba(245, 241, 230, 0.3);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }
        
        .close-letter:hover {
            background: rgba(245, 241, 230, 0.3);
            transform: rotate(90deg);
        }
        
        .letter-body {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            background: #F5F1E6;
            position: relative;
        }
        
        .letter-body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background-image: 
                linear-gradient(90deg, transparent 98%, rgba(139, 115, 85, 0.1) 98%),
                linear-gradient(rgba(139, 115, 85, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
        }
        
        /* MD内容样式 */
        .md-content {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        .md-section {
            margin-bottom: 40px;
        }
        
        .md-section h1 {
            font-family: 'Reenie Beanie', cursive;
            font-size: 3rem;
            color: var(--warm-brown);
            margin-bottom: 20px;
            border-bottom: 2px dashed #A5947A;
            padding-bottom: 10px;
            text-align: center;
        }
        
        .md-section h2 {
            font-family: 'Reenie Beanie', cursive;
            font-size: 2.2rem;
            color: var(--warm-brown);
            margin: 30px 0 15px 0;
            position: relative;
            padding-left: 25px;
        }
        
        .md-section h2::before {
            content: "•";
            position: absolute;
            left: 0;
            top: 0;
            color: var(--warm-red);
            font-size: 2.5rem;
        }
        
        .md-meta {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .md-tag {
            background: rgba(139, 115, 85, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            color: var(--warm-brown);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
            border: 1px solid rgba(139, 115, 85, 0.2);
        }
        
        .md-highlight {
            background: rgba(107, 142, 159, 0.1);
            border-left: 5px solid var(--vintage-blue);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            border: 1px solid rgba(107, 142, 159, 0.2);
        }
        
        .md-content pre {
            background: #2d2a2e;
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.1);
            border: 1px solid #3a363b;
        }
        
        .md-content code {
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #f8f8f2;
        }
        
        .md-content .inline-code {
            background: rgba(139, 115, 85, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            color: var(--warm-brown);
            font-size: 0.9em;
            border: 1px solid rgba(139, 115, 85, 0.2);
        }
        
        .md-content ul, .md-content ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .md-content li {
            margin-bottom: 8px;
            line-height: 1.7;
        }
        
        .md-content blockquote {
            border-left: 4px solid var(--vintage-blue);
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #666;
            background: rgba(107, 142, 159, 0.05);
            padding: 15px 20px;
            border-radius: 0 8px 8px 0;
        }
        
        .md-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(139, 115, 85, 0.2);
        }
        
        .md-content th, .md-content td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(139, 115, 85, 0.2);
        }
        
        .md-content th {
            background: linear-gradient(135deg, var(--warm-brown), #6B5A45);
            color: #F5F1E6;
            font-weight: bold;
            font-family: 'Gochi Hand', cursive;
            font-size: 1.1rem;
        }
        
        .md-content tr:nth-child(even) {
            background: rgba(139, 115, 85, 0.05);
        }
        
        .signature {
            text-align: right;
            margin-top: 40px;
            font-family: 'Reenie Beanie', cursive;
            font-size: 2rem;
            color: var(--warm-brown);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .hero-section {
                padding: 25px;
            }
            
            .section {
                padding: 20px;
            }
            
            .key-points {
                grid-template-columns: 1fr;
            }
            
            .envelope-container {
                width: 300px;
                height: 210px;
            }
            
            .envelope-flap {
                border-left: 150px solid transparent;
                border-right: 150px solid transparent;
                border-bottom: 60px solid #e8dfd1;
            }
            
            .envelope-flap::after {
                border-left: 150px solid transparent;
                border-right: 150px solid transparent;
                border-bottom: 57px solid #f9f3e9;
                left: -150px;
            }
            
            .envelope-text {
                font-size: 2rem;
            }
            
            .answer-modal {
                padding: 10px;
            }
            
            .letter-container {
                width: 95%;
                height: 85vh;
            }
            
            .letter-title {
                font-size: 2.2rem;
            }
            
            .md-section h1 {
                font-size: 2.2rem;
            }
            
            .md-section h2 {
                font-size: 1.8rem;
            }
        }
    </style>

        <style>
        /* 隐藏 mermaid 渲染组件 */
        .md-content section.js-render-needs-enrichment,
        .md-content .js-render-enrichment-target,
        .md-content .js-render-block-actions,
        .md-content .render-container,
        .md-content .js-render-enrichment-fallback,
        .md-content details[class*="details"],
        .md-content iframe[title="File display"] {
            display: none !important;
        }
        
        /* 修复 GitHub 代码块样式 */
        .md-content .highlight,
        .md-content .highlight-source-solidity,
        .md-content .highlight-source-js,
        .md-content .highlight-source-javascript {
            background: #2d2a2e !important;
            border-radius: 10px;
            padding: 20px !important;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.1);
            border: 1px solid #3a363b;
        }
        
        .md-content .highlight pre,
        .md-content .highlight-source-solidity pre,
        .md-content .highlight-source-js pre {
            background: transparent !important;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
        }
        
        /* 基础代码文字颜色 - 确保所有文字都可见 */
        .md-content .highlight pre {
            color: #f8f8f2 !important;
        }
        
        .md-content .highlight code,
        .md-content .highlight pre code,
        .md-content .highlight pre span,
        .md-content .highlight pre * {
            /* Added to ensure all text in pre is visible */
            color: #f8f8f2 !important;
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        /* 确保代码块内所有文字（包括没有 span 包裹的文字）都可见 */
        .md-content .highlight pre,
        .md-content .highlight pre code {
            color: #f8f8f2 !important;
        }
        
        /* 特别处理代码块中的纯文本节点（没有被 span 包裹的文字，如变量名） */
        .md-content .highlight pre {
            color: #f8f8f2 !important;
        }
        
        /* 确保所有直接文本内容都可见 - 覆盖继承的颜色 */
        .md-content .highlight pre * {
            color: #f8f8f2 !important;
        }
        
        /* 特别处理变量名 - 确保清晰可见 */
        .md-content .highlight pre span.pl-v,
        .md-content .highlight pre span.pl-en,
        .md-content .highlight pre span.pl-e {
            color: #dcdcaa !important;
            font-weight: 500 !important;
        }
        
        /* GitHub 语法高亮类颜色修复 */
        .md-content .highlight [class*="pl-"] {
            color: #f8f8f2 !important; /* Default to light color */
        }
        .md-content .highlight .pl-c { /* 注释 */
            color: #6a9955 !important;
        }
        .md-content .highlight .pl-s, .md-content .highlight .pl-s1 { /* 字符串 */
            color: #ce9178 !important;
        }
        .md-content .highlight .pl-k, .md-content .highlight .pl-c1 { /* 关键字/常量 */
            color: #569cd6 !important;
        }
        .md-content .highlight .pl-v, .md-content .highlight .pl-en, .md-content .highlight .pl-e, .md-content .highlight .pl-ent { /* 变量/函数名/实体名 */
            color: #dcdcaa !important;
            font-weight: 500 !important;
        }
        .md-content code {
            background-color: rgba(139, 115, 85, 0.15);
            color: var(--warm-brown);
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }
        </style>
        </head>
<body>
    <div class="nav-bar">
        <div class="nav-left">
            <a href="index.html" class="back-btn">
                <i class="fas fa-arrow-left"></i> 返回首页
            </a>
            <span class="nav-title">第27天 - 收益农场</span>
        </div>
        <div class="nav-right">
            <a href="#concepts" class="nav-btn">📚 核心概念</a>
            <a href="#code" class="nav-btn">💻 代码讲解</a>
            <a href="#practice" class="nav-btn">🎯 实践</a>
        </div>
    </div>

    <div class="container">
        <div class="hero-section">
            <div class="hero-header">
                <div class="hero-title">
                    <div class="day-badge">第 27 天 🌾</div>
                    <h1>YieldFarming - 收益农场</h1>
                    <p class="subtitle">实现流动性挖矿和质押奖励机制</p>
                </div>
                <div class="meta-tags">
                    <div class="difficulty-badge" style="background: var(--expert);">
                        🏆 专家
                    </div>
                    <span class="tag">质押</span>
                    <span class="tag">奖励</span>
                    <span class="tag">流动性挖矿</span>
                    <span class="tag">时间加权</span>
                </div>
            </div>
            
            <div class="key-points">
                <div class="key-point">
                    <div class="key-point-title">📌 学习目标</div>
                    <div>掌握收益农场和质押奖励机制</div>
                </div>
                <div class="key-point">
                    <div class="key-point-title">🎯 核心技能</div>
                    <div>质押合约、奖励计算、时间加权分配</div>
                </div>
                <div class="key-point">
                    <div class="key-point-title">⏱️ 预计时间</div>
                    <div>70分钟</div>
                </div>
                <div class="key-point">
                    <div class="key-point-title">🔥 难度系数</div>
                    <div>★★★★★</div>
                </div>
            </div>
        </div>

        <div class="section" id="concepts">
            <h2 class="section-title">
                <i class="fas fa-lightbulb"></i> 核心概念详解
            </h2>
            
            <div class="concept-card">
                <div class="concept-title">🌾 收益农场原理</div>
                <p>收益农场（Yield Farming）是DeFi中的核心机制，用户通过质押代币获得奖励：</p>
                <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong style="color: #155724;">✅ 基本流程</strong>
                    <ol style="margin-left: 20px; margin-top: 10px; color: #155724;">
                        <li>用户质押代币到合约</li>
                        <li>合约记录质押数量和时间</li>
                        <li>根据时间和数量计算奖励</li>
                        <li>用户可随时领取奖励</li>
                        <li>用户可取回质押的代币</li>
                    </ol>
                </div>
                <p><strong>奖励计算公式：</strong></p>
                <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: center;">
                    <code style="font-size: 1.2rem; color: #856404;">
                        奖励 = 质押数量 × 奖励率 × 时间
                    </code>
                </div>
            </div>

            <div class="concept-card">
                <div class="concept-title">⏰ 时间加权奖励系统</div>
                <p>智能的奖励分配需要精确的时间计算：</p>
                <pre><code class="language-solidity">struct StakerInfo {
    uint256 stakedAmount;      // 质押数量
    uint256 rewardDebt;        // 累积未领取奖励
    uint256 lastUpdateTime;    // 上次更新时间
}

function updateRewards(address user) internal {
    StakerInfo storage staker = stakers[user];
    
    if (staker.stakedAmount > 0) {
        uint256 pending = pendingRewards(user);
        staker.rewardDebt += pending;
    }
    
    staker.lastUpdateTime = block.timestamp;
}</code></pre>
                <p><strong>关键机制：</strong></p>
                <ul style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                    <li><strong>实时更新：</strong>每次操作都更新奖励</li>
                    <li><strong>累积计算：</strong>奖励不断累积到rewardDebt</li>
                    <li><strong>时间精度：</strong>使用区块时间戳计算</li>
                    <li><strong>Gas优化：</strong>只在必要时计算</li>
                </ul>
            </div>

            <div class="concept-card">
                <div class="concept-title">🔒 安全机制设计</div>
                <p>收益农场合约需要多重安全保护：</p>
                <div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong style="color: #721c24;">⚠️ 潜在风险</strong>
                    <ul style="margin-left: 20px; margin-top: 10px; color: #721c24;">
                        <li>重入攻击</li>
                        <li>奖励池耗尽</li>
                        <li>时间操纵</li>
                        <li>整数溢出</li>
                    </ul>
                </div>
                <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong style="color: #155724;">🛡️ 防护措施</strong>
                    <ul style="margin-left: 20px; margin-top: 10px; color: #155724;">
                        <li>ReentrancyGuard防重入</li>
                        <li>奖励池余额检查</li>
                        <li>紧急提取功能</li>
                        <li>SafeMath防溢出</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section" id="code">
            <h2 class="section-title">
                <i class="fas fa-code"></i> 完整代码详解
            </h2>
            
            <h3 style="color: var(--secondary); margin: 20px 0;">📄 收益农场合约</h3>
            <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface IERC20Metadata {
    function decimals() external view returns (uint8);
}

contract YieldFarming is ReentrancyGuard {
    IERC20 public stakingToken;
    IERC20 public rewardToken;
    uint256 public rewardRatePerSecond;
    address public owner;
    
    uint8 public stakingTokenDecimals;
    
    struct StakerInfo {
        uint256 stakedAmount;
        uint256 rewardDebt;
        uint256 lastUpdateTime;
    }
    
    mapping(address => StakerInfo) public stakers;
    
    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);
    event RewardClaimed(address indexed user, uint256 reward);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    event RewardRefilled(uint256 amount);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor(
        address _stakingToken,
        address _rewardToken,
        uint256 _rewardRatePerSecond
    ) {
        require(_stakingToken != address(0), "Invalid staking token");
        require(_rewardToken != address(0), "Invalid reward token");
        require(_rewardRatePerSecond > 0, "Invalid reward rate");
        
        stakingToken = IERC20(_stakingToken);
        rewardToken = IERC20(_rewardToken);
        rewardRatePerSecond = _rewardRatePerSecond;
        owner = msg.sender;
        
        stakingTokenDecimals = IERC20Metadata(_stakingToken).decimals();
    }
    
    // 质押代币
    function stake(uint256 amount) external nonReentrant {
        require(amount > 0, "Cannot stake 0");
        
        updateRewards(msg.sender);
        
        stakingToken.transferFrom(msg.sender, address(this), amount);
        stakers[msg.sender].stakedAmount += amount;
        
        emit Staked(msg.sender, amount);
    }
    
    // 取消质押
    function unstake(uint256 amount) external nonReentrant {
        require(amount > 0, "Cannot unstake 0");
        require(stakers[msg.sender].stakedAmount >= amount, "Insufficient balance");
        
        updateRewards(msg.sender);
        
        stakers[msg.sender].stakedAmount -= amount;
        stakingToken.transfer(msg.sender, amount);
        
        emit Unstaked(msg.sender, amount);
    }
    
    // 领取奖励
    function claimRewards() external nonReentrant {
        updateRewards(msg.sender);
        
        uint256 reward = stakers[msg.sender].rewardDebt;
        require(reward > 0, "No rewards");
        
        stakers[msg.sender].rewardDebt = 0;
        rewardToken.transfer(msg.sender, reward);
        
        emit RewardClaimed(msg.sender, reward);
    }
    
    // 紧急提取（放弃奖励）
    function emergencyWithdraw() external nonReentrant {
        uint256 amount = stakers[msg.sender].stakedAmount;
        require(amount > 0, "No stake");
        
        stakers[msg.sender].stakedAmount = 0;
        stakers[msg.sender].rewardDebt = 0;
        stakers[msg.sender].lastUpdateTime = 0;
        
        stakingToken.transfer(msg.sender, amount);
        
        emit EmergencyWithdraw(msg.sender, amount);
    }
    
    // 管理员充值奖励
    function refillRewards(uint256 amount) external onlyOwner {
        require(amount > 0, "Cannot refill 0");
        
        rewardToken.transferFrom(msg.sender, address(this), amount);
        
        emit RewardRefilled(amount);
    }
    
    // 更新用户奖励
    function updateRewards(address user) internal {
        StakerInfo storage staker = stakers[user];
        
        if (staker.stakedAmount > 0) {
            uint256 pending = pendingRewards(user);
            staker.rewardDebt += pending;
        }
        
        staker.lastUpdateTime = block.timestamp;
    }
    
    // 计算待领取奖励
    function pendingRewards(address user) public view returns (uint256) {
        StakerInfo memory staker = stakers[user];
        
        if (staker.stakedAmount == 0) return 0;
        
        uint256 timeElapsed = block.timestamp - staker.lastUpdateTime;
        if (timeElapsed == 0) return 0;
        
        // 奖励 = 质押量 × 奖励率 × 时间
        uint256 reward = (staker.stakedAmount * rewardRatePerSecond * timeElapsed)
            / (10 ** stakingTokenDecimals);
        
        return reward;
    }
    
    // 获取用户总奖励（包括待领取）
    function getTotalRewards(address user) external view returns (uint256) {
        return stakers[user].rewardDebt + pendingRewards(user);
    }
    
    // 获取质押代币小数位数
    function getStakingTokenDecimals() external view returns (uint8) {
        return stakingTokenDecimals;
    }
    
    // 获取合约奖励余额
    function getRewardBalance() external view returns (uint256) {
        return rewardToken.balanceOf(address(this));
    }
}</code></pre>

            <div style="background: linear-gradient(135deg, #d4edda, #c3e6cb); border-left: 5px solid #28a745; padding: 20px; border-radius: 10px; margin: 20px 0;">
                <strong style="color: #155724;">✅ 收益农场机制</strong>
                <p style="margin-top: 10px; color: #155724;">
                    用户质押代币 → 合约记录质押信息 → 基于时间和数量计算奖励 → 用户随时领取奖励 → 可紧急提取本金。整个过程透明、自动化，无需信任第三方。
                </p>
            </div>
        </div>

        <div class="section" id="practice">
            <h2 class="section-title">
                <i class="fas fa-dumbbell"></i> 实践与练习
            </h2>
            
            <h3 style="color: var(--secondary); margin-bottom: 20px;">📝 Remix实战步骤</h3>
            
            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤1: 准备代币</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>部署质押代币（如STAKE）和奖励代币（如REWARD）</li>
                    <li>给自己铸造足够的代币用于测试</li>
                    <li>记录代币合约地址</li>
                </ol>
            </div>

            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤2: 部署农场合约</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>使用代币地址和奖励率部署YieldFarming合约</li>
                    <li>设置合理的奖励率（如每秒0.1个代币）</li>
                    <li>管理员向合约充值奖励代币</li>
                </ol>
            </div>

            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤3: 质押测试</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>批准农场合约使用你的质押代币</li>
                    <li>调用<code class="inline-code">stake(1000)</code>质押代币</li>
                    <li>等待一段时间，观察奖励累积</li>
                    <li>调用<code class="inline-code">pendingRewards()</code>查看待领取奖励</li>
                </ol>
            </div>

            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤4: 奖励领取</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>调用<code class="inline-code">claimRewards()</code>领取奖励</li>
                    <li>检查奖励代币余额增加</li>
                    <li>验证rewardDebt重置为0</li>
                    <li>继续等待，观察新奖励累积</li>
                </ol>
            </div>

            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤5: 取消质押</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>调用<code class="inline-code">unstake(500)</code>部分取消质押</li>
                    <li>观察质押数量和奖励率变化</li>
                    <li>测试紧急提取功能</li>
                    <li>验证所有资金安全返回</li>
                </ol>
            </div>

            <h3 style="color: var(--secondary); margin: 40px 0 20px 0;">🎯 挑战练习</h3>
            <div style="background: linear-gradient(135deg, #fff9e6, #ffedd5); border-left: 5px solid var(--medium); padding: 25px; border-radius: 10px;">
                <p style="font-weight: bold; margin-bottom: 15px; font-size: 1.1rem;">尝试以下改进:</p>
                <ol style="margin-left: 25px; line-height: 2.2;">
                    <li>实现多池质押（支持多种代币）</li>
                    <li>添加锁定期机制（提前取出有惩罚）</li>
                    <li>实现推荐奖励系统</li>
                    <li>添加质押等级和加成</li>
                    <li>实现复利机制（自动复投奖励）</li>
                    <li>创建治理代币分配</li>
                </ol>
            </div>

            <h3 style="color: var(--secondary); margin: 40px 0 20px 0;">📚 扩展知识</h3>
            
            <div style="background: white; border: 2px solid var(--accent); padding: 20px; border-radius: 10px; margin: 20px 0;">
                <h4 style="color: var(--primary); margin-bottom: 10px;">复利计算实现</h4>
                <pre><code class="language-solidity">function compound() external nonReentrant {
    updateRewards(msg.sender);
    
    uint256 reward = stakers[msg.sender].rewardDebt;
    require(reward > 0, "No rewards to compound");
    
    // 将奖励转换为质押代币并重新质押
    stakers[msg.sender].rewardDebt = 0;
    stakers[msg.sender].stakedAmount += reward;
    
    emit Compounded(msg.sender, reward);
}</code></pre>
                <p style="margin-top: 10px;">复利机制可以显著提高长期收益，但需要考虑代币转换和滑点问题。</p>
            </div>
        </div>

        <div class="navigation-footer">
            <a href="contract-26.html" class="nav-footer-btn" style="border-color: var(--accent);">
                <div class="nav-footer-label">← 上一个</div>
                <div class="nav-footer-title">NFT Marketplace - NFT市场</div>
            </a>
            <a href="contract-28.html" class="nav-footer-btn" style="border-color: var(--accent);">
                <div class="nav-footer-label">下一个 →</div>
                <div class="nav-footer-title">DAO - 去中心化治理</div>
            </a>
        </div>
    
        <!-- Sneha的一封来信模块 -->
        <div class="answer-reference">
            <div class="envelope-container" id="envelope-container">
                <div class="envelope">
                    <div class="envelope-front">
                        <div class="envelope-flap"></div>
                        <div class="envelope-pattern"></div>
                        <div class="envelope-seal">
                            <i class="fas fa-feather-alt seal-icon"></i>
                        </div>
                        <div class="envelope-text">Sneha的一封来信</div>
                    </div>
                    <div class="envelope-back">
                        <div class="envelope-text" style="color: var(--warm-brown);">点击开启</div>
                    </div>
                </div>
            </div>
            <div class="envelope-hint">点击信封查看Sneha的来信</div>
        </div>
    </div>

    <!-- 弹窗 - 内容待后续精细化处理 -->
    <div class="answer-modal" id="answer-modal">
        <div class="letter-container">
            <div class="letter-header">
                <div class="letter-title">Sneha的一封来信</div>
                <div class="letter-subtitle">关于第27天的学习指导</div>
                <button id="close-letter" class="close-letter">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="letter-body">
                <div id="md-content" class="md-content">
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">质押/定期/活期理财产品合约</h1></div>
<p dir="auto">Day: Day 27
ID: 27
译者: Rebecca9715
难度等级: 高级</p>
<p dir="auto">嘿嘿，欢迎回到 <strong>30 天 Solidity</strong> —</p>
<p dir="auto">在这里，我们每一天都不仅仅是学习智能合约如何工作...</p>
<p dir="auto">我们正在<strong>亲手构建 DeFi 的基石</strong>(以及其他东西😉)。</p>
<p dir="auto">今天?</p>
<p dir="auto">你将要构建 <strong>DeFi 运行的引擎</strong>之一:</p>
<p dir="auto">一个<strong>收益耕作平台</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧠 但首先... 什么<em>是</em>收益耕作?</h2></div>
<p dir="auto">让我们用超级简单的方式来说明。</p>
<p dir="auto">想象你的代币就像种子。</p>
<p dir="auto">你可以:</p>
<ul dir="auto">
<li>只是让它们闲置在你的钱包里什么都不做...</li>
<li><strong>或者</strong>你可以把它们"种植"在某个地方，<strong>锁定一段时间</strong>，并<strong>生长出更多代币</strong>作为奖励。</li>
</ul>
<p dir="auto">这就是收益耕作。</p>
<blockquote>
<p dir="auto">质押代币 → 让时间流逝 → 收获奖励。</p>
</blockquote>
<p dir="auto">你的资产不是积灰尘，而是积累<em>收益</em>。</p>
<p dir="auto">而且你质押的时间越长或数量越多，你赚得越多。</p>
<hr>
<p dir="auto">在 Web3 的真实世界中，收益耕作支撑着:</p>
<ul dir="auto">
<li>流动性池</li>
<li>DAO 金库</li>
<li>DeFi 激励措施</li>
<li>GameFi 奖励系统</li>
<li>启动平台和代币分发</li>
</ul>
<p dir="auto">它<strong>无处不在</strong>。</p>
<p dir="auto">从 Uniswap 到 SushiSwap 再到 Curve —</p>
<p dir="auto"><strong>每个奖励池背后，都有一个就像你即将构建的智能合约</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">💡 你今天要构建什么</h2></div>
<p dir="auto">在今天的项目中，你将创建一个让用户能够:</p>
<ul dir="auto">
<li>📥 <strong>质押</strong> ERC-20 代币</li>
<li>⏳ <strong>随时间累积奖励</strong>，基于他们质押了多少和多长时间</li>
<li>💰 <strong>随时领取他们的奖励</strong></li>
<li>🚪 如果需要，<strong>紧急提取</strong>他们的代币</li>
<li>🔧 <strong>管理员可以补充</strong>奖励池以保持耕作活跃</li>
</ul>
<p dir="auto">我们将用以下方式完成这一切:</p>
<ul dir="auto">
<li>具有<strong>重入保护</strong></li>
<li>干净地处理<strong>不同的代币和小数位数</strong></li>
</ul>
<p dir="auto">简而言之:</p>
<p dir="auto">你不仅仅是随机分发代币 —</p>
<p dir="auto">你正在构建一个<strong>公平的</strong>、<strong>安全的</strong>、<strong>基于时间加权的奖励系统</strong>，使 DeFi 生态系统保持运转。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔥 为什么这个合约很重要</h2></div>
<p dir="auto">这个收益耕作平台是许多 DeFi 协议的<strong>真正基础</strong>。</p>
<p dir="auto">它向你展示如何:</p>
<ul dir="auto">
<li>正确跟踪<strong>个人用户质押</strong></li>
<li>随时间计算<strong>动态奖励</strong></li>
<li>为用户构建<strong>紧急退出选项</strong></li>
<li><strong>管理奖励资金</strong>而不破坏系统</li>
</ul>
<p dir="auto">通过掌握这个，你将解锁智能合约开发的全新水平 — 一个<strong>时间</strong>、<strong>价值</strong>和<strong>用户行为</strong>都在链上交互的水平。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🚀 准备好播种了吗?</h1></div>
<p dir="auto">好的，在我们开始编写代码之前...</p>
<p dir="auto">让我们快速回顾一下并<strong>理解你即将构建的完整逻辑</strong>。</p>
<p dir="auto">因为<strong>这不仅仅是一个随机的质押合约</strong> —</p>
<p dir="auto">它是一个经过精心设计的系统，每个部分都扮演着重要角色。</p>
<p dir="auto">以下是整个流程的工作方式:</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧩 我们的收益耕作合约的宏观逻辑</h2></div>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">1. 📥 质押</h3></div>
<ul dir="auto">
<li>用户调用 <code>stake()</code> 将<strong>他们的代币存入</strong>农场。</li>
<li>我们跟踪<strong>多少</strong>他们质押以及<strong>何时</strong>他们质押。</li>
<li>他们的奖励开始<strong>自动累积</strong> — 基于质押的金额。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">2. ⏳ 赚取奖励</h3></div>
<ul dir="auto">
<li>
<p dir="auto">奖励是<strong>按秒计算</strong>的 — 不是按区块计算。</p>
</li>
<li>
<p dir="auto">你质押的代币越多，留下的时间越长，<strong>你的奖励就越大</strong>。</p>
</li>
<li>
<p dir="auto">我们不会神奇地铸造奖励 —</p>
<p dir="auto">它们必须由管理员<strong>预先资助</strong>到合约中(<code>refillRewards()</code>)。</p>
</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">3. 💰 领取奖励</h3></div>
<ul dir="auto">
<li>当用户想要收获时，他们调用 <code>claimRewards()</code>。</li>
<li>他们以<strong>奖励代币</strong>的形式收到所有累积的奖励。</li>
<li>他们的奖励计数器在领取后重置为零。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">4. 🚪 取消质押</h3></div>
<ul dir="auto">
<li>用户也可以 <code>unstake()</code> 部分或全部他们的代币。</li>
<li>当他们这样做时，他们在质押减少之前仍然<strong>领取他们的待处理奖励</strong>。</li>
<li>这是一个丝滑<strong>的退出</strong>，不会失去已赚取的奖励。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">5. 🚨 紧急提取</h3></div>
<ul dir="auto">
<li>
<p dir="auto">如果发生了一些疯狂的事情(用户恐慌、UI 错误、黑客恐慌)，用户可以调用 <code>emergencyWithdraw()</code>。</p>
</li>
<li>
<p dir="auto">这让他们<strong>立即取出他们的质押</strong> —</p>
<p dir="auto">但<strong>他们会失去任何待处理的奖励</strong>作为紧急退出的代价。</p>
</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">6. 🔧 管理员控制</h3></div>
<ul dir="auto">
<li><strong>所有者</strong>(部署合约的人)可以调用 <code>refillRewards()</code>。</li>
<li>这会向系统添加更多奖励代币，<strong>保持农场活跃和可持续</strong>。</li>
<li>无需重新部署合约 — 你可以继续充值。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">7. 🛡️ 内置安全性</h3></div>
<ul dir="auto">
<li><strong>ReentrancyGuard</strong> 在所有敏感函数上都是活跃的。</li>
<li><strong>SafeCast</strong> 用于防止数学运算时的溢出/下溢。</li>
<li>ETH 转账被<strong>拒绝</strong> — 这仅限 ERC-20。</li>
<li>一切都被设计为<strong>公平、安全和基于时间</strong>。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">📜 完整的收益耕作合约</h1></div>
<p dir="auto">好的，这是宏观视图:</p>
<p dir="auto">你即将看到的不仅仅是另一个 Solidity 合约。</p>
<p dir="auto">这是<strong>实时 DeFi 耕作系统的完整蓝图</strong> — 那种位于真实质押程序、流动性激励和 Web3 奖励系统背后的东西。</p>
<p dir="auto">你手中持有的这个智能合约将让用户:</p>
<ul dir="auto">
<li>📥 <strong>质押 ERC-20 代币</strong>到农场</li>
<li>⏳ <strong>自动累积奖励</strong>，按秒计算</li>
<li>💰 <strong>随时领取奖励</strong>以收获</li>
<li>🚪 在收集奖励的同时<strong>取消质押</strong>他们的代币</li>
<li>🚨 如果需要，<strong>紧急提取</strong>而无需等待</li>
<li>🔧 <strong>管理员补充</strong>奖励池而无需停止或重启合约</li>
</ul>
<p dir="auto">在做这一切的同时，它还:</p>
<ul dir="auto">
<li>🛡️ 防止重入攻击</li>
<li>📏 安全地处理代币小数位数</li>
<li>🏗️ 如果需要，公平地存储和计算数千用户的奖励</li>
<li>📢 为所有重要内容发出事件(质押、取消质押、奖励、紧急情况)</li>
</ul>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">// SPDX-License-Identifier: MIT</span>
<span class="pl-k">pragma solidity</span> <span class="pl-k">^</span><span class="pl-c1">0.8.20</span>;

<span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/token/ERC20/IERC20.sol</span>"</span>;
<span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/security/ReentrancyGuard.sol</span>"</span>;
<span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/utils/math/SafeCast.sol</span>"</span>; <span class="pl-c">// 如果需要使用 SafeCast</span>

<span class="pl-c">// 用于获取 ERC-20 元数据(小数位数)的接口</span>
<span class="pl-k">interface</span> <span class="pl-en">IERC20Metadata</span> <span class="pl-k">is</span> <span class="pl-en">IERC20</span> {
    <span class="pl-k">function<span class="pl-en"> decimals</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint8</span>);
    <span class="pl-k">function<span class="pl-en"> name</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">string</span> <span class="pl-k">memory</span>);
    <span class="pl-k">function<span class="pl-en"> symbol</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">string</span> <span class="pl-k">memory</span>);
}

<span class="pl-c">/// @title 收益耕作平台</span>
<span class="pl-c">///     质押代币以随时间赚取奖励,可选紧急提取和管理员补充</span>
<span class="pl-k">contract</span> <span class="pl-en">YieldFarming</span> <span class="pl-k">is</span> <span class="pl-en">ReentrancyGuard</span> {
    <span class="pl-k">using<span class="pl-en"> SafeCast</span></span> <span class="pl-k">for</span> <span class="pl-c1">uint256</span>;

    <span class="pl-c1">IERC20</span> <span class="pl-k">public</span> stakingToken;
    <span class="pl-c1">IERC20</span> <span class="pl-k">public</span> rewardToken;

    <span class="pl-c1">uint256</span> <span class="pl-k">public</span> rewardRatePerSecond; <span class="pl-c">// 每秒分配的奖励</span>

    <span class="pl-c1">address</span> <span class="pl-k">public</span> owner;

    <span class="pl-c1">uint8</span> <span class="pl-k">public</span> stakingTokenDecimals; <span class="pl-c">// 存储质押代币的小数位数</span>

    <span class="pl-k">struct<span class="pl-en"> StakerInfo</span></span> {
        <span class="pl-c1">uint256</span> stakedAmount;
        <span class="pl-c1">uint256</span> rewardDebt;
        <span class="pl-c1">uint256</span> lastUpdate;
    }

    <span class="pl-k">mapping</span>(<span class="pl-c1">address</span> <span class="pl-k">=&gt;</span> StakerInfo) <span class="pl-k">public</span> stakers;

    <span class="pl-k">event <span class="pl-en">Staked</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
    <span class="pl-k">event <span class="pl-en">Unstaked</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
    <span class="pl-k">event <span class="pl-en">RewardClaimed</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
    <span class="pl-k">event <span class="pl-en">EmergencyWithdraw</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
    <span class="pl-k">event <span class="pl-en">RewardRefilled</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">owner</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);

    <span class="pl-k">modifier<span class="pl-en"> onlyOwner</span></span>() {
        <span class="pl-k">require</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span> <span class="pl-k">==</span> owner, <span class="pl-s">"<span class="pl-s">Not the owner</span>"</span>);
        <span class="pl-k">_;</span>
    }

    <span class="pl-k">constructor</span>(
        <span class="pl-c1">address</span> <span class="pl-v">_stakingToken</span>,
        <span class="pl-c1">address</span> <span class="pl-v">_rewardToken</span>,
        <span class="pl-c1">uint256</span> <span class="pl-v">_rewardRatePerSecond</span>
    ) {
        stakingToken <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_stakingToken);
        rewardToken <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_rewardToken);
        rewardRatePerSecond <span class="pl-k">=</span> _rewardRatePerSecond;
        owner <span class="pl-k">=</span> <span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>;

        <span class="pl-c">// 尝试获取小数位数</span>
        <span class="pl-k">try</span> <span class="pl-c1">IERC20Metadata</span>(_stakingToken).<span class="pl-en">decimals</span>() <span class="pl-k">returns</span> (<span class="pl-c1">uint8</span> <span class="pl-v">decimals</span>) {
            stakingTokenDecimals <span class="pl-k">=</span> decimals;
        } <span class="pl-k">catch</span> (<span class="pl-c1">bytes</span> <span class="pl-k">memory</span>) {
            stakingTokenDecimals <span class="pl-k">=</span> <span class="pl-c1">18</span>; <span class="pl-c">// 如果获取失败,默认为 18 位小数</span>
        }
    }

    <span class="pl-c">///     质押代币以开始赚取奖励</span>
    <span class="pl-k">function<span class="pl-en"> stake</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> nonReentrant {
        <span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Cannot stake 0</span>"</span>);

        <span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);

        stakingToken.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amount);
        stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">+=</span> amount;

        <span class="pl-k">emit</span> <span class="pl-en">Staked</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
    }

    <span class="pl-c">///     取消质押代币并可选择领取奖励</span>
    <span class="pl-k">function<span class="pl-en"> unstake</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> nonReentrant {
        <span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Cannot unstake 0</span>"</span>);
        <span class="pl-k">require</span>(stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">&gt;=</span> amount, <span class="pl-s">"<span class="pl-s">Not enough staked</span>"</span>);

        <span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);

        stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">-=</span> amount;
        stakingToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);

        <span class="pl-k">emit</span> <span class="pl-en">Unstaked</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
    }

    <span class="pl-c">///     领取累积的奖励</span>
    <span class="pl-k">function<span class="pl-en"> claimRewards</span></span>() <span class="pl-k">external</span> nonReentrant {
        <span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);

        <span class="pl-c1">uint256</span> reward <span class="pl-k">=</span> stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt;
        <span class="pl-k">require</span>(reward <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">No rewards to claim</span>"</span>);
        <span class="pl-k">require</span>(rewardToken.<span class="pl-en">balanceOf</span>(<span class="pl-c1">address</span>(<span class="pl-mi">this</span>)) <span class="pl-k">&gt;=</span> reward, <span class="pl-s">"<span class="pl-s">Insufficient reward token balance</span>"</span>);

        stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        rewardToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, reward);

        <span class="pl-k">emit</span> <span class="pl-en">RewardClaimed</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, reward);
    }

    <span class="pl-c">///     紧急取消质押而不领取奖励</span>
    <span class="pl-k">function<span class="pl-en"> emergencyWithdraw</span></span>() <span class="pl-k">external</span> nonReentrant {
        <span class="pl-c1">uint256</span> amount <span class="pl-k">=</span> stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount;
        <span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Nothing staked</span>"</span>);

        stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].lastUpdate <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span>;

        stakingToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);

        <span class="pl-k">emit</span> <span class="pl-en">EmergencyWithdraw</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
    }

    <span class="pl-c">///     管理员可以补充奖励代币</span>
    <span class="pl-k">function<span class="pl-en"> refillRewards</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> onlyOwner {
        rewardToken.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amount);

        <span class="pl-k">emit</span> <span class="pl-en">RewardRefilled</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
    }

    <span class="pl-c">///     更新质押者的奖励</span>
    <span class="pl-k">function<span class="pl-en"> updateRewards</span></span>(<span class="pl-c1">address</span> <span class="pl-v">user</span>) <span class="pl-k">internal</span> {
        StakerInfo <span class="pl-k">storage</span> staker <span class="pl-k">=</span> stakers[user];

        <span class="pl-k">if</span> (staker.stakedAmount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-c1">uint256</span> timeDiff <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span> <span class="pl-k">-</span> staker.lastUpdate;
            <span class="pl-c1">uint256</span> rewardMultiplier <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> stakingTokenDecimals;
            <span class="pl-c1">uint256</span> pendingReward <span class="pl-k">=</span> (timeDiff <span class="pl-k">*</span> rewardRatePerSecond <span class="pl-k">*</span> staker.stakedAmount) <span class="pl-k">/</span> rewardMultiplier;
            staker.rewardDebt <span class="pl-k">+=</span> pendingReward;
        }

        staker.lastUpdate <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span>;
    }

    <span class="pl-c">///     查看待处理奖励而不领取</span>
    <span class="pl-k">function<span class="pl-en"> pendingRewards</span></span>(<span class="pl-c1">address</span> <span class="pl-v">user</span>) <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span>) {
        StakerInfo <span class="pl-k">memory</span> staker <span class="pl-k">=</span> stakers[user];

        <span class="pl-c1">uint256</span> pendingReward <span class="pl-k">=</span> staker.rewardDebt;

        <span class="pl-k">if</span> (staker.stakedAmount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-c1">uint256</span> timeDiff <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span> <span class="pl-k">-</span> staker.lastUpdate;
            <span class="pl-c1">uint256</span> rewardMultiplier <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> stakingTokenDecimals;
            pendingReward <span class="pl-k">+=</span> (timeDiff <span class="pl-k">*</span> rewardRatePerSecond <span class="pl-k">*</span> staker.stakedAmount) <span class="pl-k">/</span> rewardMultiplier;
        }

        <span class="pl-k">return</span> pendingReward;
    }

    <span class="pl-c">///     查看质押代币小数位数</span>
    <span class="pl-k">function<span class="pl-en"> getStakingTokenDecimals</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint8</span>) {
        <span class="pl-k">return</span> stakingTokenDecimals;
    }
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">一. 产品需求书</h1></div>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">用户流程</h3></div>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">数据库</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>Contract</th>
<th>Type</th>
<th>Bases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SimpleStablecoin</strong></td>
<td>Implementation</td>
<td>ERC20, Ownable, ReentrancyGuard, AccessControl</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>序号</th>
<th>Function Name</th>
<th>Visibility</th>
<th>Mutability</th>
<th>Modifiers</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>constructor</td>
<td>Public ❗️</td>
<td>🛑</td>
<td>-</td>
<td>初始化合约，设置质押代币、奖励代币和奖励速率</td>
</tr>
<tr>
<td>2</td>
<td>stake</td>
<td>External ❗️</td>
<td>🛑</td>
<td>nonReentrant</td>
<td>用户质押代币开始赚取奖励</td>
</tr>
<tr>
<td>3</td>
<td>unstake</td>
<td>External ❗️</td>
<td>🛑</td>
<td>nonReentrant</td>
<td>用户取消质押代币并自动更新奖励</td>
</tr>
<tr>
<td>4</td>
<td>claimRewards</td>
<td>External ❗️</td>
<td>🛑</td>
<td>nonReentrant</td>
<td>用户领取所有累积的奖励</td>
</tr>
<tr>
<td>5</td>
<td>emergencyWithdraw</td>
<td>External ❗️</td>
<td>🛑</td>
<td>nonReentrant</td>
<td>紧急提取质押代币（放弃奖励）</td>
</tr>
<tr>
<td>6</td>
<td>refillRewards</td>
<td>External ❗️</td>
<td>🛑</td>
<td>onlyOwner</td>
<td>管理员补充奖励池</td>
</tr>
<tr>
<td>7</td>
<td>updateRewards</td>
<td>Internal 🔒</td>
<td>🛑</td>
<td>-</td>
<td>内部函数：更新用户的奖励累积</td>
</tr>
<tr>
<td>8</td>
<td>pendingRewards</td>
<td>External ❗️</td>
<td>👀</td>
<td>-</td>
<td>查看用户当前待处理的奖励（不领取）</td>
</tr>
<tr>
<td>9</td>
<td>getStakingTokenDecimals</td>
<td>External ❗️</td>
<td>👀</td>
<td>-</td>
<td>查看质押代币的小数位数</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">事件列表</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>Event Name</th>
<th>Parameters</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Minted</td>
<td>address indexed user, uint256 amount, uint256 collateralDeposited</td>
<td>铸造稳定币时触发</td>
</tr>
<tr>
<td>Redeemed</td>
<td>address indexed user, uint256 amount, uint256 collateralReturned</td>
<td>赎回稳定币时触发</td>
</tr>
<tr>
<td>PriceFeedUpdated</td>
<td>address newPriceFeed</td>
<td>价格源更新时触发</td>
</tr>
<tr>
<td>CollateralizationRatioUpdated</td>
<td>uint256 newRatio</td>
<td>抵押率更新时触发</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">错误列表</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>Error Name</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>InvalidCollateralTokenAddress</td>
<td>无效的抵押代币地址</td>
</tr>
<tr>
<td>InvalidPriceFeedAddress</td>
<td>无效的价格源地址</td>
</tr>
<tr>
<td>MintAmountIsZero</td>
<td>铸造数量为零</td>
</tr>
<tr>
<td>InsufficientStablecoinBalance</td>
<td>稳定币余额不足</td>
</tr>
<tr>
<td>CollateralizationRatioTooLow</td>
<td>抵押率低于100%</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">状态变量</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>Variable Name</th>
<th>Type</th>
<th>Visibility</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>PRICE_FEED_MANAGER_ROLE</td>
<td>bytes32</td>
<td>public constant</td>
<td>价格源管理员角色标识符</td>
</tr>
<tr>
<td>collateralToken</td>
<td>IERC20</td>
<td>public immutable</td>
<td>抵押代币合约地址</td>
</tr>
<tr>
<td>collateralDecimals</td>
<td>uint8</td>
<td>public immutable</td>
<td>抵押代币小数位数</td>
</tr>
<tr>
<td>priceFeed</td>
<td>AggregatorV3Interface</td>
<td>public</td>
<td>Chainlink价格源接口</td>
</tr>
<tr>
<td>collateralizationRatio</td>
<td>uint256</td>
<td>public</td>
<td>抵押率（默认150%）</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">二. 细节解说</h1></div>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">📦 1. 导入 – 引入正确的工具</h1></div>
<p dir="auto">在我们编写任何一行自定义逻辑之前，</p>
<p dir="auto">我们引入一些<strong>经过实战测试的 OpenZeppelin 库</strong>，使我们的合约<strong>更安全</strong>、<strong>更智能</strong>和<strong>面向未来</strong>。</p>
<p dir="auto">以下是我们使用的导入 — 以及每个导入为何重要:</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ 1.1 ERC-20 接口</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/token/ERC20/IERC20.sol</span>"</span>;
</pre></div>
<p dir="auto">这个导入让我们访问 <strong>ERC-20 接口</strong> — 基本上，这是任何像 USDC、DAI 或你的自定义代币将遵循的标准函数集。</p>
<p dir="auto">它包括基本函数，如:</p>
<ul dir="auto">
<li><code>transfer()</code></li>
<li><code>transferFrom()</code></li>
<li><code>approve()</code></li>
<li><code>balanceOf()</code></li>
</ul>
<p dir="auto"><strong>为什么我们在这里需要它:</strong></p>
<p dir="auto">因为用户将质押和领取 <strong>ERC-20 代币</strong>，我们需要安全地与这些代币交互而不硬编码任何东西。</p>
<p dir="auto">✅ 无论是自定义代币、稳定币还是其他东西 — 只要它遵循 ERC-20，我们的合约就可以处理它。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🛡️ 1.2 重入保护</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/security/ReentrancyGuard.sol</span>"</span>;
</pre></div>
<p dir="auto">这个对于<strong>安全性</strong>来说<strong>超级重要</strong>。</p>
<p dir="auto">当资金(或代币)在智能合约内移动时，你必须小心一种叫做<strong>重入攻击</strong>的东西 — 有人试图在第一次调用完成之前<em>再次</em>调用函数，导致意外行为并可能耗尽资金。</p>
<p dir="auto"><strong>为什么我们在这里需要它:</strong></p>
<p dir="auto">像 <code>stake()</code>、<code>unstake()</code>、<code>claimRewards()</code> 和 <code>emergencyWithdraw()</code> 这样的函数都在处理代币转账 — 这意味着它们是重入的潜在目标。</p>
<p dir="auto">✅ 通过使用 <code>ReentrancyGuard</code>，我们确保一旦函数开始执行，它会<strong>锁定</strong>自己直到完成 — 不允许偷偷重新进入。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 1.3 SafeCast</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/utils/math/SafeCast.sol</span>"</span>; <span class="pl-c">// 如果需要使用 SafeCast</span>
</pre></div>
<p dir="auto">在 Solidity 中，当你在不同类型的数字之间移动时(如 <code>uint256</code> → <code>uint8</code>)，你需要<strong>非常小心</strong>。</p>
<p dir="auto">如果你盲目地向下转换数字而不检查，你可能会<strong>溢出</strong>或<strong>截断值</strong>而没有意识到 — 这可能导致错误甚至安全漏洞。</p>
<p dir="auto"><strong>为什么我们在这里需要它:</strong></p>
<p dir="auto">在处理奖励和计算时，特别是涉及代币<strong>小数位数</strong>时，我们想确保我们<strong>安全地</strong>转换数字。</p>
<p dir="auto">✅ <code>SafeCast</code> 有助于防止在我们跨不同大小的数字进行数学运算时意外溢出或数据丢失。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🛠️ 2. ERC-20 元数据的自定义接口</h1></div>
<p dir="auto">这是代码片段:</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">// 用于获取 ERC-20 元数据(小数位数)的接口</span>
<span class="pl-k">interface</span> <span class="pl-en">IERC20Metadata</span> <span class="pl-k">is</span> <span class="pl-en">IERC20</span> {
    <span class="pl-k">function<span class="pl-en"> decimals</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint8</span>);
    <span class="pl-k">function<span class="pl-en"> name</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">string</span> <span class="pl-k">memory</span>);
    <span class="pl-k">function<span class="pl-en"> symbol</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">string</span> <span class="pl-k">memory</span>);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 这里发生了什么?</h3></div>
<p dir="auto">我们正在创建标准 <code>IERC20</code> 接口的<strong>小扩展</strong>。</p>
<p dir="auto">通常，ERC-20 代币保证它将具有:</p>
<ul dir="auto">
<li><code>balanceOf()</code></li>
<li><code>transfer()</code></li>
<li><code>approve()</code></li>
<li>和其他基本函数...</li>
</ul>
<p dir="auto"><strong>但你猜怎么着?</strong></p>
<p dir="auto"><strong><code>decimals()</code>、<code>name()</code> 和 <code>symbol()</code> 在原始 ERC-20 标准中是<em>可选的</em>。</strong></p>
<p dir="auto">它们后来变得常见 — 但并非每个 ERC-20 代币都必须正式实现它们。</p>
<p dir="auto">这就是为什么 OpenZeppelin 将其分离为一个不同的接口，称为 <code>IERC20Metadata</code>。</p>
<p dir="auto">我们在这里以轻量级的方式重新创建它，以便我们可以<em>使用</em>这些函数，如果代币支持它们 — 而不是默认假设它们存在。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔥 为什么我们需要这个</h3></div>
<p dir="auto">我们的收益耕作合约<strong>想要知道</strong>质押代币的 <code>decimals</code> —</p>
<p dir="auto">因为当我们计算奖励时，我们需要正确<strong>缩放</strong>数字。</p>
<p dir="auto">例子:</p>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>代币</th>
<th>小数位数</th>
<th>1 个代币看起来像什么</th>
</tr>
</thead>
<tbody>
<tr>
<td>USDC</td>
<td>6 位小数</td>
<td>1 USDC = 1,000,000 单位</td>
</tr>
<tr>
<td>ETH</td>
<td>18 位小数</td>
<td>1 ETH = 1,000,000,000,000,000,000 单位</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<blockquote>
<p dir="auto">🧠 如果你忽略小数位数，你的数学将完全错误 —</p>
<p dir="auto">用户可能会赚得<em>太多</em>或<em>太少</em>奖励。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📚 每个函数的详细说明</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>函数</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>decimals()</code></td>
<td>返回代币使用的小数位数</td>
</tr>
<tr>
<td><code>name()</code></td>
<td>返回人类可读的代币名称(例如，"Dai Stablecoin")</td>
</tr>
<tr>
<td><code>symbol()</code></td>
<td>返回简短的股票代码符号(例如，"DAI")</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<ul dir="auto">
<li>我们<strong>主要</strong>关心 <code>decimals()</code> 用于奖励数学。</li>
<li>但拥有 <code>name()</code> 和 <code>symbol()</code> 对于以后的 UI 也很有用!</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🌟 这就是为什么这个小接口很重要</h3></div>
<p dir="auto">这是一件小事 — 只是几行。</p>
<p dir="auto">但没有它，<strong>你的整个农场可能会崩溃</strong>，当质押具有奇怪小数位数的代币时。</p>
<p dir="auto">好的合约<strong>考虑现实世界的混乱</strong> —</p>
<p dir="auto">你现在正在学习用这种远见来构建。🌱</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🏛️ 3. 合约声明</h1></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">contract</span> <span class="pl-en">YieldFarming</span> <span class="pl-k">is</span> <span class="pl-en">ReentrancyGuard</span> {
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧠 这里发生了什么?</h2></div>
<p dir="auto">这一行同时做两件主要事情:</p>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">1. 📜 创建合约</h3></div>
<p dir="auto">我们正在创建一个名为 <strong><code>YieldFarming</code></strong> 的全新智能合约。</p>
<p dir="auto">这是人们与你的农场互动时将使用的名称。</p>
<p dir="auto">这是像 MetaMask 这样的钱包将显示的内容。</p>
<p dir="auto">这是将在像 Etherscan 这样的浏览器中显示的名称。</p>
<p dir="auto">这是你的<strong>数字农场的官方标题</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">2. 🛡️ 继承重入保护</h3></div>
<p dir="auto">注意 <code>is ReentrancyGuard</code> 部分吗?</p>
<p dir="auto">这意味着我们的 YieldFarming 合约<strong>继承</strong>自 OpenZeppelin 的 <code>ReentrancyGuard</code> 合约。</p>
<blockquote>
<p dir="auto">🧠 在 Solidity 中，继承意味着你从另一个合约中引入函数和保护 — 而不必自己重写它们。</p>
</blockquote>
<p dir="auto"><strong>具体来说:</strong></p>
<p dir="auto">它为我们提供了 <code>nonReentrant</code> 修饰符，我们将在所有敏感函数上使用它，如:</p>
<ul dir="auto">
<li><code>stake()</code></li>
<li><code>unstake()</code></li>
<li><code>claimRewards()</code></li>
<li><code>emergencyWithdraw()</code></li>
</ul>
<p dir="auto">✅ 每次用户存入或提取代币时，我们都会<strong>锁定</strong>函数以防止重入攻击 —</p>
<p dir="auto">这种攻击曾从编写不当的 DeFi 应用中耗尽了数百万美元。</p>
<blockquote>
<p dir="auto">甚至没有意识到，你正在编写 DeFi 级别的安全代码，只需正确设置这个。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">📦 4. 状态变量 – 我们的农场将处理什么数据?</h1></div>
<p dir="auto">好的 — 在我们开始构建质押函数或奖励领取之前，</p>
<p dir="auto">让我们花点时间思考一下我们的农场实际上需要跟踪的<strong>数据类型</strong>。</p>
<p dir="auto">因为当你构建一个系统，用户锁定他们的代币并随时间赚取奖励时，</p>
<p dir="auto"><strong>你不能只是"希望"数字正确。</strong></p>
<p dir="auto">你需要:</p>
<ul dir="auto">
<li>知道用户正在质押<strong>什么代币</strong></li>
<li>知道用户将获得<strong>什么代币</strong>作为奖励</li>
<li>知道奖励分配的<strong>速度有多快</strong></li>
<li>跟踪<strong>谁负责</strong>维护农场</li>
<li>干净地处理<strong>不同的代币小数位数</strong>(因为并非所有代币都是平等创建的)</li>
</ul>
<p dir="auto">在本节中，我们将<strong>声明所有重要的状态变量</strong> —</p>
<p dir="auto">我们的农场顺利、公平和安全运行所需的信息片段。</p>
<hr>
<p dir="auto">✅ 现在，让我们逐行分解!</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">using<span class="pl-en"> SafeCast</span></span> <span class="pl-k">for</span> <span class="pl-c1">uint256</span>;

<span class="pl-c1">IERC20</span> <span class="pl-k">public</span> stakingToken;
<span class="pl-c1">IERC20</span> <span class="pl-k">public</span> rewardToken;

<span class="pl-c1">uint256</span> <span class="pl-k">public</span> rewardRatePerSecond; <span class="pl-c">// 每秒分配的奖励</span>

<span class="pl-c1">address</span> <span class="pl-k">public</span> owner;

<span class="pl-c1">uint8</span> <span class="pl-k">public</span> stakingTokenDecimals;
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🛠️ 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ <code>using SafeCast for uint256;</code></h3></div>
<p dir="auto"><strong>这一行是一个 Solidity 技巧</strong> — 它用 <code>SafeCast</code> 库中的新<em>安全</em>函数扩展了原生 <code>uint256</code> 类型。</p>
<p dir="auto"><strong>用简单的英语:</strong></p>
<p dir="auto">它允许我们直接在 <code>uint256</code> 数字上调用像 <code>.toUint8()</code>、<code>.toUint128()</code> 等方法 — 并在不冒溢出或奇怪错误风险的情况下安全地在不同类型之间转换。</p>
<blockquote>
<p dir="auto">例子:</p>
<p dir="auto">如果我们稍后有一个 <code>uint256</code>，我们需要安全地将其缩小到 <code>uint8</code>,</p>
<p dir="auto">而不是手动编写一个大检查，我们可以这样做:</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint8</span> smallNumber <span class="pl-k">=</span> bigNumber.<span class="pl-en">toUint8</span>();
</pre></div>
</blockquote>
<p dir="auto">✅ <strong>它使转换更简单、更安全。</strong></p>
<p dir="auto">我们主要在以下情况下使用它:</p>
<ul dir="auto">
<li>处理不同的奖励规模</li>
<li>管理小数位数</li>
<li>进行精确的奖励计算</li>
</ul>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">IERC20</span> <span class="pl-k">public</span> stakingToken;
</pre></div>
<p dir="auto">这是用户将质押(锁定)到合约中的<strong>代币</strong>。</p>
<ul dir="auto">
<li>它可以是任何东西:自定义代币、治理代币、像 DAI 这样的稳定币等。</li>
<li>它作为 <code>IERC20</code> 接口存储，因此我们可以对其调用像 <code>transferFrom()</code>、<code>transfer()</code> 和 <code>balanceOf()</code> 这样的函数。</li>
</ul>
<p dir="auto">✅ 这是用户存入农场的<strong>资产</strong>。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">IERC20</span> <span class="pl-k">public</span> rewardToken;
</pre></div>
<p dir="auto">这是用户将作为奖励赚取的<strong>代币</strong>。</p>
<ul dir="auto">
<li>它可以与质押代币相同(质押 DAI，赚取 DAI)</li>
<li>或者它可以是不同的(质押 DAI，赚取 FARM 代币)</li>
</ul>
<p dir="auto">✅ 这为系统提供了灵活性 — 你可以用任何你想要的 ERC-20 代币奖励用户。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> <span class="pl-k">public</span> rewardRatePerSecond;
</pre></div>
<p dir="auto">这定义了<strong>奖励生成的速度</strong>。</p>
<ul dir="auto">
<li>它是<strong>每秒</strong>在所有质押者之间分配的奖励代币数量。</li>
<li>因此，如果你设置 <code>rewardRatePerSecond = 1e18</code>，系统<strong>每秒</strong>发放 <code>1</code> 个奖励代币(以 wei 计算)。</li>
</ul>
<p dir="auto">✅ 这允许你根据奖励池的大小微调耕作程序的<strong>速度</strong>。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">address</span> <span class="pl-k">public</span> owner;
</pre></div>
<p dir="auto">这存储<strong>管理员的钱包地址</strong> —</p>
<p dir="auto">部署合约的人(或多重签名，或 DAO)。</p>
<p dir="auto"><code>owner</code> 将拥有特殊权力，如:</p>
<ul dir="auto">
<li>补充奖励池</li>
<li>在更高级的版本中可能暂停/更新事物</li>
</ul>
<p dir="auto">✅ 只有所有者可以调用受 <code>onlyOwner</code> 修饰符保护的敏感函数。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint8</span> <span class="pl-k">public</span> stakingTokenDecimals;
</pre></div>
<p dir="auto">当我们进行奖励计算时，我们必须<strong>根据小数位数正确缩放数学</strong>。</p>
<ul dir="auto">
<li>一些代币有 18 位小数(如 ETH)。</li>
<li>一些代币有 6 位小数(如 USDC)。</li>
<li>一些奇怪的代币甚至更少。</li>
</ul>
<p dir="auto">通过在合约部署时读取并保存质押代币的小数位数，</p>
<p dir="auto">我们确保<strong>奖励数学保持准确</strong>，无论用户质押什么代币。</p>
<p dir="auto">✅ 没有小数位数不匹配错误 = 没有数学灾难。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🧱 5. 跟踪每个用户 – 结构和映射</h1></div>
<p dir="auto">好的 — 到目前为止，我们已经设置了<em>全局</em>变量:</p>
<p dir="auto">人们正在质押什么代币，他们赚取什么，谁拥有农场，等等。</p>
<p dir="auto">但现在是时候放大并考虑<strong>个人用户</strong>了。</p>
<p dir="auto">因为当有人将代币质押到农场时，</p>
<p dir="auto">我们需要<strong>跟踪他们的个人数据</strong>:</p>
<ul dir="auto">
<li>他们质押了多少</li>
<li>他们赚取了多少奖励(但可能还没有领取)</li>
<li>他们的奖励上次更新是什么时候</li>
</ul>
<p dir="auto">如果我们不正确跟踪这个，整个奖励系统将崩溃 —</p>
<p dir="auto">一些用户可能得到太多，其他人太少。</p>
<p dir="auto">因此，在合约的这一部分，我们正在设置一个<strong>干净、有组织的结构</strong>来管理<strong>每个质押者的信息</strong>。</p>
<p dir="auto">这是我们正在看的代码:</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">struct<span class="pl-en"> StakerInfo</span></span> {
    <span class="pl-c1">uint256</span> stakedAmount;
    <span class="pl-c1">uint256</span> rewardDebt;
    <span class="pl-c1">uint256</span> lastUpdate;
}

<span class="pl-k">mapping</span>(<span class="pl-c1">address</span> <span class="pl-k">=&gt;</span> StakerInfo) <span class="pl-k">public</span> stakers;
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧠 这些行背后的逻辑</h2></div>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakedAmount
</pre></div>
<p dir="auto">这跟踪用户存入农场的<strong>质押代币数量</strong>。</p>
<p dir="auto">每次用户<strong>质押</strong>或<strong>取消质押</strong>时，我们都会更新这个数字。</p>
<ul dir="auto">
<li>更多质押 = 随时间获得更多奖励。</li>
<li>更少质押 = 更小的奖励份额。</li>
</ul>
<p dir="auto">✅ 它告诉我们用户在农场内<strong>任何时刻的位置有多大</strong>。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>rewardDebt
</pre></div>
<p dir="auto">这跟踪用户<strong>已经赚取但尚未领取的奖励数量</strong>。</p>
<p dir="auto">每当用户与农场互动时，我们<strong>更新</strong>他们的 <code>rewardDebt</code>，基于:</p>
<ul dir="auto">
<li>他们质押了多少</li>
<li>过了多少时间</li>
<li>奖励率</li>
</ul>
<p dir="auto">✅ 它防止用户"忘记"旧奖励或意外为同一质押时间赚取两次。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>lastUpdate
</pre></div>
<p dir="auto">这记录<strong>我们上次更新</strong>用户奖励的时间。</p>
<p dir="auto">当用户质押、取消质押或领取时，我们:</p>
<ul dir="auto">
<li>计算自 <code>lastUpdate</code> 以来他们赚了多少</li>
<li>更新 <code>rewardDebt</code></li>
<li>然后<strong>刷新</strong>他们的 <code>lastUpdate</code> 到当前区块时间戳。</li>
</ul>
<p dir="auto">✅ 它确保奖励基于<strong>实际花费的时间</strong>质押 — 而不是假设。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">mapping</span>(<span class="pl-c1">address</span> <span class="pl-k">=&gt;</span> StakerInfo) <span class="pl-k">public</span> stakers;
</pre></div>
<p dir="auto">这将<strong>每个用户的地址</strong>映射到他们的<strong>个人 StakerInfo 数据</strong>。</p>
<p dir="auto">因此，对于每个用户，合约知道:</p>
<ul dir="auto">
<li>他们质押了多少</li>
<li>他们积累了多少奖励</li>
<li>他们的奖励上次更新是什么时候</li>
</ul>
<p dir="auto">✅ 这是我们如何在农场内部<strong>单独跟踪每个人的位置</strong> — 干净和安全。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">📢 6. 事件 – 广播农场内部发生的事情</h1></div>
<p dir="auto">好的 — 现在我们正在跟踪谁在质押和赚取奖励，</p>
<p dir="auto">我们还需要一种方法向外部世界<strong>广播重要行动</strong>。</p>
<p dir="auto">因为记住:</p>
<p dir="auto"><strong>智能合约没有前端。</strong></p>
<p dir="auto">它们不能直接与用户"交谈" —</p>
<p dir="auto">它们只能<strong>发出事件</strong>，钱包、dapp 和像 Etherscan 这样的浏览器可以监听。</p>
<hr>
<p dir="auto">以下是我们声明的事件:</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">Staked</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
<span class="pl-k">event <span class="pl-en">Unstaked</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
<span class="pl-k">event <span class="pl-en">RewardClaimed</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
<span class="pl-k">event <span class="pl-en">EmergencyWithdraw</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
<span class="pl-k">event <span class="pl-en">RewardRefilled</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">owner</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧠 每个事件背后的逻辑</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📥 <code>Staked</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">Staked</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
</pre></div>
<ul dir="auto">
<li>当用户<strong>质押代币</strong>到农场时触发。</li>
<li>告诉我们<strong>谁质押了</strong>以及<strong>他们质押了多少</strong>。</li>
</ul>
<p dir="auto">✅ 对于跟踪存款、构建用户仪表板以及在前端显示"用户 X 质押了 Y 代币"很有用。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🚪 <code>Unstaked</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">Unstaked</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
</pre></div>
<ul dir="auto">
<li>当用户<strong>取消质押</strong>(提取)他们的代币时触发。</li>
<li>告诉我们<strong>谁提取了</strong>以及<strong>他们移除了多少</strong>。</li>
</ul>
<p dir="auto">✅ 帮助前端更新余额，并让用户看到他们退出的干净历史。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💰 <code>RewardClaimed</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">RewardClaimed</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
</pre></div>
<ul dir="auto">
<li>当用户<strong>领取他们的待处理奖励</strong>而不取消质押时触发。</li>
<li>显示<strong>谁领取了</strong>以及<strong>他们收到了多少奖励代币</strong>。</li>
</ul>
<p dir="auto">✅ 对于奖励历史、分析以及向用户显示他们到目前为止赚了多少至关重要。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🚨 <code>EmergencyWithdraw</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">EmergencyWithdraw</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">user</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
</pre></div>
<ul dir="auto">
<li>当用户<strong>立即取出他们的质押</strong>而不等待奖励时触发。</li>
<li>告诉我们<strong>谁进行了紧急退出</strong>以及<strong>他们提取了多少</strong>。</li>
</ul>
<p dir="auto">✅ 帮助在紧急情况下跟踪恐慌退出 — 并告诉用户他们的紧急提取成功了。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧹 <code>RewardRefilled</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">RewardRefilled</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">owner</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>);
</pre></div>
<ul dir="auto">
<li>当<strong>管理员</strong>用新的奖励代币补充合约时触发。</li>
<li>告诉我们<strong>谁补充了</strong>以及<strong>向池中添加了多少代币</strong>。</li>
</ul>
<p dir="auto">✅ 对于透明度至关重要 — 用户可以看到奖励池何时被充值，耕作继续。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🛡️ 7. 修饰符 – 保护仅限管理员的操作</h1></div>
<p dir="auto">这是代码:</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">modifier<span class="pl-en"> onlyOwner</span></span>() {
    <span class="pl-k">require</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span> <span class="pl-k">==</span> owner, <span class="pl-s">"<span class="pl-s">Not the owner</span>"</span>);
    <span class="pl-k">_;</span>
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧠 这里发生了什么?</h2></div>
<p dir="auto">这个 <code>onlyOwner</code> 修饰符就像一个<strong>安全检查点</strong>。</p>
<p dir="auto">每当我们将 <code>onlyOwner</code> 附加到函数时，</p>
<p dir="auto">它强制合约<strong>检查</strong>:</p>
<blockquote>
<p dir="auto">调用此函数的人实际上是农场的所有者吗?</p>
</blockquote>
<p dir="auto">如果是 — ✅ 函数正常执行。</p>
<p dir="auto">如果不是 — ❌ 交易立即恢复，错误为 <code>"Not the owner"</code>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🏗️ 8. 构造函数</h1></div>
<p dir="auto">好的 — 在任何人可以开始质押或赚取奖励之前，</p>
<p dir="auto">我们需要<strong>设置农场</strong>:</p>
<ul dir="auto">
<li>用户将质押什么代币?</li>
<li>他们将作为奖励赚取什么代币?</li>
<li>奖励应该多快分配?</li>
</ul>
<p dir="auto">所有这些都在合约部署时<strong>一次</strong>决定 — 在<strong>构造函数</strong>内部。</p>
<blockquote>
<p dir="auto">把它想象成在你向农民开放大门之前设置农场的规则。</p>
</blockquote>
<p dir="auto">这个构造函数锁定所有重要的起始值，以便其他一切稍后可以顺利运行。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 构造函数代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">constructor</span>(
    <span class="pl-c1">address</span> <span class="pl-v">_stakingToken</span>,
    <span class="pl-c1">address</span> <span class="pl-v">_rewardToken</span>,
    <span class="pl-c1">uint256</span> <span class="pl-v">_rewardRatePerSecond</span>
) {
    stakingToken <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_stakingToken);
    rewardToken <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_rewardToken);
    rewardRatePerSecond <span class="pl-k">=</span> _rewardRatePerSecond;
    owner <span class="pl-k">=</span> <span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>;

    <span class="pl-c">// 尝试获取小数位数</span>
    <span class="pl-k">try</span> <span class="pl-c1">IERC20Metadata</span>(_stakingToken).<span class="pl-en">decimals</span>() <span class="pl-k">returns</span> (<span class="pl-c1">uint8</span> <span class="pl-v">decimals</span>) {
        stakingTokenDecimals <span class="pl-k">=</span> decimals;
    } <span class="pl-k">catch</span> (<span class="pl-c1">bytes</span> <span class="pl-k">memory</span>) {
        stakingTokenDecimals <span class="pl-k">=</span> <span class="pl-c1">18</span>; <span class="pl-c">// 如果获取失败,默认为 18 位小数</span>
    }
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧩 设置质押代币</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakingToken <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_stakingToken);
</pre></div>
<ul dir="auto">
<li>这告诉合约用户必须质押参与的 <strong>ERC-20 代币</strong>。</li>
<li>我们将 <code>_stakingToken</code> 地址视为 <code>IERC20</code> — 因此我们可以安全地与其交互(转账、余额检查等)</li>
</ul>
<p dir="auto">✅ 没有这个，用户不知道他们应该锁定什么资产到农场。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🎁 设置奖励代币</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>rewardToken <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_rewardToken);
</pre></div>
<ul dir="auto">
<li>这告诉合约用户将作为奖励赚取的 <strong>ERC-20 代币</strong>。</li>
<li>它可以与质押代币相同，或完全不同的代币。</li>
</ul>
<p dir="auto">✅ 灵活性直接内置 — 你可以以任何你想要的方式奖励用户。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">⏳ 设置奖励率</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>rewardRatePerSecond <span class="pl-k">=</span> _rewardRatePerSecond;
</pre></div>
<ul dir="auto">
<li>这定义了<strong>每秒</strong>向质押者集体分配<strong>多少奖励代币</strong>。</li>
<li>更高的比率 = 奖励分配得更快。</li>
<li>更低的比率 = 奖励分配得更慢。</li>
</ul>
<p dir="auto">✅ 这是控制农场支付奖励"速度"的东西。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">👑 设置所有者</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>owner <span class="pl-k">=</span> <span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>;
</pre></div>
<ul dir="auto">
<li>部署合约的人成为<strong>所有者</strong>。</li>
<li>这个人将有权限调用像 <code>refillRewards()</code> 这样的特殊函数。</li>
</ul>
<p dir="auto">✅ 只有所有者可以补充奖励池并管理农场的健康。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 尝试获取质押代币小数位数</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">try</span> <span class="pl-c1">IERC20Metadata</span>(_stakingToken).<span class="pl-en">decimals</span>() <span class="pl-k">returns</span> (<span class="pl-c1">uint8</span> <span class="pl-v">decimals</span>) {
    stakingTokenDecimals <span class="pl-k">=</span> decimals;
} <span class="pl-k">catch</span> (<span class="pl-c1">bytes</span> <span class="pl-k">memory</span>) {
    stakingTokenDecimals <span class="pl-k">=</span> <span class="pl-c1">18</span>; <span class="pl-c">// 如果获取失败,默认为 18 位小数</span>
}
</pre></div>
<ul dir="auto">
<li>我们<strong>尝试</strong>从质押代币读取 <code>decimals()</code> 函数。</li>
<li>一些代币(特别是非标准代币)可能不实现这个，所以我们用 <code>try/catch</code> 包装它。</li>
<li>如果获取小数位数成功，太好了 — 我们存储它。</li>
<li>如果失败，我们假设 <strong>18 位小数</strong>(这是大多数现代 ERC-20 的标准)。</li>
</ul>
<p dir="auto">✅ 这确保我们的奖励计算保持<strong>准确</strong>，即使跨不同类型的代币。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">📥 9. <code>stake()</code> – 用户进入农场并开始赚取</h1></div>
<p dir="auto">好的 — 现在农场已经设置好了，</p>
<p dir="auto">我们需要一种方式让用户<strong>实际加入</strong>并<strong>开始耕作奖励</strong>。</p>
<p dir="auto">这正是 <code>stake()</code> 函数所做的:</p>
<blockquote>
<p dir="auto">用户将一些代币发送到合约 →</p>
<p dir="auto">我们存储他们的存款 →</p>
<p dir="auto">他们立即开始<strong>按秒</strong>赚取奖励。</p>
</blockquote>
<p dir="auto">这是用户在耕作系统中<strong>正式播种</strong>的地方。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 <code>stake()</code> 的完整代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">///     质押代币以开始赚取奖励</span>
<span class="pl-k">function<span class="pl-en"> stake</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> nonReentrant {
    <span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Cannot stake 0</span>"</span>);

    <span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);

    stakingToken.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amount);
    stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">+=</span> amount;

    <span class="pl-k">emit</span> <span class="pl-en">Staked</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🛡️ 防止重入</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> stake</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> nonReentrant {
</pre></div>
<ul dir="auto">
<li>这个函数可以被<strong>任何人</strong>调用(<code>external</code>)，但</li>
<li>它受到 <code>nonReentrant</code> 修饰符的保护，以<strong>阻止重入攻击</strong>(因为它涉及转移代币)。</li>
</ul>
<p dir="auto">✅ 始终保护移动资金的函数。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">⚡ 基本验证:不能质押 0</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Cannot stake 0</span>"</span>);
</pre></div>
<ul dir="auto">
<li>用户必须至少质押 <strong>1 单位</strong>(即使是非常小的数量)。</li>
<li>质押零没有意义，可能会导致奇怪的边界情况。</li>
</ul>
<p dir="auto">✅ 一个简单、好的第一次检查。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 更新待处理奖励</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);
</pre></div>
<ul dir="auto">
<li>在接受新存款之前，我们<strong>计算并存储</strong>用户到目前为止已经赚取的任何待处理奖励。</li>
<li>这确保<strong>公平的奖励跟踪</strong> — 新存款不会抹去或搞乱先前的奖励。</li>
</ul>
<p dir="auto">✅ 奖励必须在更改质押金额<em>之前</em>计算。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 拉入质押的代币</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakingToken.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amount);
</pre></div>
<ul dir="auto">
<li>我们从用户的钱包<strong>拉入</strong>质押代币到合约中。</li>
<li>用户必须事先<strong>批准</strong>农场合约花费他们的代币(标准 ERC-20 行为)。</li>
</ul>
<p dir="auto">✅ 在这一行之后，用户的代币正式锁定到农场中。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 更新质押者的金额</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">+=</span> amount;
</pre></div>
<ul dir="auto">
<li>我们通过新存入的金额<strong>增加</strong>用户的总 <code>stakedAmount</code>。</li>
<li>这个新金额将用于计算未来的奖励。</li>
</ul>
<p dir="auto">✅ 更大的质押 = 每秒更大的奖励份额。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📢 发出质押事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">Staked</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
</pre></div>
<ul dir="auto">
<li>触发一个事件，让 UI 和浏览器知道:
<ul dir="auto">
<li><strong>谁质押了</strong></li>
<li><strong>他们质押了多少</strong></li>
</ul>
</li>
</ul>
<p dir="auto">✅ 为用户和前端提供透明的历史。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🚪 10. <code>unstake()</code> – 让用户退出农场(并仍然赚取)</h1></div>
<p dir="auto">好的 — 质押很棒，但用户也需要一种方式<strong>随时离开农场</strong>。</p>
<p dir="auto">也许他们想兑现。也许他们只是需要他们的代币回来。</p>
<p dir="auto"><code>unstake()</code> 函数让他们<strong>安全地提取他们的质押代币</strong>,</p>
<p dir="auto"><strong>同时仍然收集他们到那时为止赚取的任何奖励</strong>。</p>
<p dir="auto">这就像把你的种子从地里拉出来<strong>并拾起你到目前为止种出的所有果实</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 <code>unstake()</code> 的完整代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">///     取消质押代币并可选择领取奖励</span>
<span class="pl-k">function<span class="pl-en"> unstake</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> nonReentrant {
    <span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Cannot unstake 0</span>"</span>);
    <span class="pl-k">require</span>(stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">&gt;=</span> amount, <span class="pl-s">"<span class="pl-s">Not enough staked</span>"</span>);

    <span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);

    stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">-=</span> amount;
    stakingToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);

    <span class="pl-k">emit</span> <span class="pl-en">Unstaked</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🛡️ 锁定函数防止重入</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> unstake</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> nonReentrant {
</pre></div>
<ul dir="auto">
<li><code>external</code>:任何人都可以调用它 — 只为他们自己。</li>
<li><code>nonReentrant</code>:我们锁定它以<strong>防止重入攻击</strong>，因为正在转移代币。</li>
</ul>
<p dir="auto">✅ 安全第一，始终如一。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">⚡ 基本验证</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Cannot unstake 0</span>"</span>);
</pre></div>
<ul dir="auto">
<li>用户必须取消质押<strong>真实数量</strong>。</li>
<li>不允许零取消质押(会毫无意义并可能搞乱记账)。</li>
</ul>
<p dir="auto">✅ 干净、可预测的行为。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">&gt;=</span> amount, <span class="pl-s">"<span class="pl-s">Not enough staked</span>"</span>);
</pre></div>
<ul dir="auto">
<li>用户不能取消质押超过他们最初存入的数量。</li>
<li>如果他们试图取消质押太多，交易<strong>立即恢复</strong>。</li>
</ul>
<p dir="auto">✅ 保护农场的内部余额。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 取消质押前更新奖励</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);
</pre></div>
<ul dir="auto">
<li>在更改用户的质押之前，我们<strong>计算并锁定</strong>他们到这一点为止赚取的任何奖励。</li>
<li>这样，即使他们部分取消质押，用户<strong>也不会失去</strong>奖励。</li>
</ul>
<p dir="auto">✅ 公平的奖励，即使在部分退出时。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 减少质押金额</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">-=</span> amount;
</pre></div>
<ul dir="auto">
<li>更新奖励后，我们通过他们取消质押的金额<strong>减少</strong>用户的 <code>stakedAmount</code>。</li>
</ul>
<p dir="auto">✅ 他们的耕作能力立即调整以匹配他们的新质押。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 将代币转回用户</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakingToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
</pre></div>
<ul dir="auto">
<li>我们<strong>发回</strong>取消质押的代币到用户的钱包。</li>
<li>没有第三方参与 — 这是一个直接的、链上的、自助操作。</li>
</ul>
<p dir="auto">✅ 用户重新获得对他们代币的完全控制。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📢 发出取消质押事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">Unstaked</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
</pre></div>
<ul dir="auto">
<li>我们触发一个事件，以便 UI、浏览器和日志知道:
<ul dir="auto">
<li><strong>谁取消质押了</strong></li>
<li><strong>他们取消质押了多少</strong></li>
</ul>
</li>
</ul>
<p dir="auto">✅ 使系统保持透明和易于跟踪。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">💰 11. <code>claimRewards()</code> – 收获你赚取的代币</h1></div>
<p dir="auto">好的 — 到目前为止，用户一直在质押他们的代币并观察他们的奖励在后台悄悄增长。</p>
<p dir="auto">但他们如何实际<strong>收集</strong>这些奖励?</p>
<p dir="auto">这正是 <code>claimRewards()</code> 让他们做的:</p>
<blockquote>
<p dir="auto">这就像收获你种出的果实 —</p>
<p dir="auto">而不用连根拔起树本身。</p>
</blockquote>
<p dir="auto">用户可以<strong>随时领取他们赚取的奖励</strong>,</p>
<p dir="auto"><strong>而不触碰</strong>他们的原始质押。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 <code>claimRewards()</code> 的完整代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">///     领取累积的奖励</span>
<span class="pl-k">function<span class="pl-en"> claimRewards</span></span>() <span class="pl-k">external</span> nonReentrant {
    <span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);

    <span class="pl-c1">uint256</span> reward <span class="pl-k">=</span> stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt;
    <span class="pl-k">require</span>(reward <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">No rewards to claim</span>"</span>);
    <span class="pl-k">require</span>(rewardToken.<span class="pl-en">balanceOf</span>(<span class="pl-c1">address</span>(<span class="pl-mi">this</span>)) <span class="pl-k">&gt;=</span> reward, <span class="pl-s">"<span class="pl-s">Insufficient reward token balance</span>"</span>);

    stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    rewardToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, reward);

    <span class="pl-k">emit</span> <span class="pl-en">RewardClaimed</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, reward);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🛡️ 锁定函数防止重入</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> claimRewards</span></span>() <span class="pl-k">external</span> nonReentrant {
</pre></div>
<ul dir="auto">
<li>同样，因为我们正在移动代币，我们使用 <code>nonReentrant</code> 来防止潜在的重入漏洞。</li>
</ul>
<p dir="auto">✅ 始终锁定发送资金的函数。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 更新用户的待处理奖励</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">updateRewards</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>);
</pre></div>
<ul dir="auto">
<li>
<p dir="auto">在交出任何奖励之前，</p>
<p dir="auto">我们根据当前时间<strong>重新计算</strong>一切。</p>
</li>
<li>
<p dir="auto">这确保用户获得他们赚取的<strong>每一秒的价值</strong>的奖励。</p>
</li>
</ul>
<p dir="auto">✅ 没有错过的时间。没有丢失的代币。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 获取待处理奖励金额</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> reward <span class="pl-k">=</span> stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt;
</pre></div>
<ul dir="auto">
<li>我们读取用户当前欠的奖励数量(存储为他们的 <code>rewardDebt</code>)。</li>
</ul>
<p dir="auto">✅ 干净简单 — 奖励已经在内部跟踪。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">⚡ 验证检查</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(reward <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">No rewards to claim</span>"</span>);
</pre></div>
<ul dir="auto">
<li>如果用户没有积累奖励，我们拒绝领取。</li>
</ul>
<p dir="auto">✅ 节省 gas 并防止意外的空交易。</p>
<hr>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(rewardToken.<span class="pl-en">balanceOf</span>(<span class="pl-c1">address</span>(<span class="pl-mi">this</span>)) <span class="pl-k">&gt;=</span> reward, <span class="pl-s">"<span class="pl-s">Insufficient reward token balance</span>"</span>);
</pre></div>
<ul dir="auto">
<li>仔细检查合约实际上<strong>持有足够的奖励代币</strong>来支付领取。</li>
<li>如果奖励池为空或太低，交易将恢复。</li>
</ul>
<p dir="auto">✅ 良好的故障保护，避免破损的支付。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧹 重置用户的奖励债务</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt <span class="pl-k">=</span> <span class="pl-c1">0</span>;
</pre></div>
<ul dir="auto">
<li>发送奖励后，我们<strong>重置</strong>用户的 <code>rewardDebt</code> 为零。</li>
<li>否则，他们可能会再次领取相同的奖励。</li>
</ul>
<p dir="auto">✅ 使记账保持干净和公平。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 将奖励转给用户</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>rewardToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, reward);
</pre></div>
<ul dir="auto">
<li>最后，我们<strong>发送</strong>奖励代币直接到用户的钱包。</li>
</ul>
<p dir="auto">✅ 平滑、直接和无需信任。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📢 发出奖励领取事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">RewardClaimed</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, reward);
</pre></div>
<ul dir="auto">
<li>为透明度和历史跟踪触发事件:
<ul dir="auto">
<li><strong>谁领取了</strong></li>
<li><strong>他们领取了多少</strong></li>
</ul>
</li>
</ul>
<p dir="auto">✅ 让前端更新 UI，浏览器干净地记录操作。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🚨 12. <code>emergencyWithdraw()</code> – 恐慌按钮</h1></div>
<p dir="auto">好的 — 当一切顺利运行时，质押很棒...</p>
<p dir="auto">但如果发生了一些疯狂的事情怎么办?</p>
<ul dir="auto">
<li>也许前端坏了。</li>
<li>也许用户只是急需他们的代币回来。</li>
<li>也许有突然的安全恐慌。</li>
</ul>
<p dir="auto">无论什么原因 —</p>
<p dir="auto">用户应该有一种方式<strong>立即退出</strong>而不用担心待处理的奖励。</p>
<p dir="auto">这正是 <code>emergencyWithdraw()</code> 的目的:</p>
<blockquote>
<p dir="auto">这就像在紧急情况下打破玻璃 —</p>
<p dir="auto"><strong>立即</strong>取回你的代币，但<strong>留下你的奖励</strong>。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 <code>emergencyWithdraw()</code> 的完整代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">///     紧急取消质押而不领取奖励</span>
<span class="pl-k">function<span class="pl-en"> emergencyWithdraw</span></span>() <span class="pl-k">external</span> nonReentrant {
    <span class="pl-c1">uint256</span> amount <span class="pl-k">=</span> stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount;
    <span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Nothing staked</span>"</span>);

    stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].lastUpdate <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span>;

    stakingToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);

    <span class="pl-k">emit</span> <span class="pl-en">EmergencyWithdraw</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🛡️ 锁定函数防止重入</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> emergencyWithdraw</span></span>() <span class="pl-k">external</span> nonReentrant {
</pre></div>
<ul dir="auto">
<li>安全第一 — 即使紧急退出也受到重入攻击的保护。</li>
</ul>
<p dir="auto">✅ 即使在压力下也保持安全。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 获取质押金额</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> amount <span class="pl-k">=</span> stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount;
</pre></div>
<ul dir="auto">
<li>将用户的<strong>当前质押金额</strong>加载到临时变量中。</li>
</ul>
<p dir="auto">✅ 我们准备将其发送回用户。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">⚡ 验证检查</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Nothing staked</span>"</span>);
</pre></div>
<ul dir="auto">
<li>确保用户实际上<strong>有东西质押</strong>。</li>
<li>如果没有，没有什么可以提取，函数恢复。</li>
</ul>
<p dir="auto">✅ 防止无用的交易。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧹 重置所有用户信息</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].stakedAmount <span class="pl-k">=</span> <span class="pl-c1">0</span>;
stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].rewardDebt <span class="pl-k">=</span> <span class="pl-c1">0</span>;
stakers[<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>].lastUpdate <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span>;
</pre></div>
<ul dir="auto">
<li><strong>清零</strong>用户的质押和奖励债务。</li>
<li><strong>更新</strong>他们的 <code>lastUpdate</code> 到当前时间(即使他们正在退出)。</li>
<li>这确保如果他们再次返回并质押，他们从新开始。</li>
</ul>
<p dir="auto">✅ 干净、安全的状态重置 — 没有剩余或奇怪的奖励错误。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 将代币转回用户</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>stakingToken.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
</pre></div>
<ul dir="auto">
<li>将质押的代币直接发送回用户的钱包。</li>
</ul>
<p dir="auto">✅ 快速自助退出 — 不需要管理员。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📢 发出紧急提取事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">EmergencyWithdraw</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
</pre></div>
<ul dir="auto">
<li>触发一个事件，以便操作公开记录:
<ul dir="auto">
<li><strong>谁提取了</strong></li>
<li><strong>他们取出了多少</strong></li>
</ul>
</li>
</ul>
<p dir="auto">✅ 帮助前端和浏览器清楚地显示紧急退出。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🔋 13. <code>refillRewards()</code> – 保持奖励池活跃</h1></div>
<p dir="auto">好的 — 用户正在愉快地质押、耕作和领取奖励...</p>
<p dir="auto">但当奖励池开始不足时会发生什么?</p>
<p dir="auto">而不是关闭一切或部署新合约，</p>
<p dir="auto">管理员(所有者)可以简单地<strong>充值</strong>奖励池 —</p>
<p dir="auto"><strong>注入新的奖励</strong>以保持耕作季节继续。</p>
<p dir="auto">这正是 <code>refillRewards()</code> 所做的:</p>
<blockquote>
<p dir="auto">这就像给杂货店补货。</p>
<p dir="auto">新奖励进来 → 耕作继续而没有任何中断。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 <code>refillRewards()</code> 的完整代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">///     管理员可以补充奖励代币</span>
<span class="pl-k">function<span class="pl-en"> refillRewards</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> onlyOwner {
    rewardToken.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amount);

    <span class="pl-k">emit</span> <span class="pl-en">RewardRefilled</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔒 仅限所有者访问</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> refillRewards</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">external</span> onlyOwner {
</pre></div>
<ul dir="auto">
<li>只有 <code>owner</code>(部署农场的人)可以调用这个。</li>
<li>受我们之前设置的 <code>onlyOwner</code> 修饰符保护。</li>
<li>普通用户<strong>不能</strong>补充奖励池 — 只有管理员可以。</li>
</ul>
<p dir="auto">✅ 使敏感操作保持在管理员控制下。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 将新奖励拉入合约</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>rewardToken.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amount);
</pre></div>
<ul dir="auto">
<li>所有者必须首先<strong>批准</strong>收益耕作合约花费他们的奖励代币。</li>
<li>然后这个函数<strong>拉入</strong>指定数量到农场合约中。</li>
<li>这些新代币现在可用于随时间支付给农民。</li>
</ul>
<p dir="auto">✅ 没有奖励铸造。没有奇怪的黑客。只是简单、干净的 ERC-20 转账。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📢 发出奖励补充事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">RewardRefilled</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amount);
</pre></div>
<ul dir="auto">
<li>触发一个事件以公开记录:
<ul dir="auto">
<li><strong>谁补充了</strong>奖励</li>
<li><strong>他们添加了多少代币</strong></li>
</ul>
</li>
</ul>
<p dir="auto">✅ 前端可以观察这个事件以实时更新奖励池余额。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🧠 14. <code>updateRewards()</code> – 保持奖励公平和新鲜</h1></div>
<p dir="auto">好的 — 耕作奖励不会神奇地自己更新。</p>
<p dir="auto">每次用户<strong>质押</strong>、<strong>取消质押</strong>或<strong>领取奖励</strong>时，</p>
<p dir="auto">我们需要<strong>重新计算</strong>他们基于以下因素赚了多少:</p>
<ul dir="auto">
<li><strong>多长时间</strong>他们一直在质押</li>
<li><strong>多少</strong>他们质押了</li>
<li><strong>多快</strong>奖励正在分配</li>
</ul>
<p dir="auto">这就是内部 <code>updateRewards()</code> 函数的用武之地:</p>
<blockquote>
<p dir="auto">这就像每次有人触摸植物时检查其生长 —</p>
<p dir="auto">并确保它与过了多少时间相匹配。</p>
</blockquote>
<p dir="auto">这个函数悄悄地<strong>保持一切公平和准确</strong>在幕后。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 <code>updateRewards()</code> 的完整代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">///     更新质押者的奖励</span>
<span class="pl-k">function<span class="pl-en"> updateRewards</span></span>(<span class="pl-c1">address</span> <span class="pl-v">user</span>) <span class="pl-k">internal</span> {
    StakerInfo <span class="pl-k">storage</span> staker <span class="pl-k">=</span> stakers[user];

    <span class="pl-k">if</span> (staker.stakedAmount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
        <span class="pl-c1">uint256</span> timeDiff <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span> <span class="pl-k">-</span> staker.lastUpdate;
        <span class="pl-c1">uint256</span> rewardMultiplier <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> stakingTokenDecimals;
        <span class="pl-c1">uint256</span> pendingReward <span class="pl-k">=</span> (timeDiff <span class="pl-k">*</span> rewardRatePerSecond <span class="pl-k">*</span> staker.stakedAmount) <span class="pl-k">/</span> rewardMultiplier;
        staker.rewardDebt <span class="pl-k">+=</span> pendingReward;
    }

    staker.lastUpdate <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span>;
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📚 加载用户信息</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>StakerInfo <span class="pl-k">storage</span> staker <span class="pl-k">=</span> stakers[user];
</pre></div>
<ul dir="auto">
<li>
<p dir="auto">我们从<strong>存储</strong>中获取用户的质押者数据，</p>
<p dir="auto">以便我们可以直接更新它而不将其复制到内存中。</p>
</li>
</ul>
<p dir="auto">✅ 我们所做的任何更改都将立即反映在链上。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔍 检查用户是否有质押的代币</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">if</span> (staker.stakedAmount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
</pre></div>
<ul dir="auto">
<li>只有在用户实际上有东西质押时才更新奖励。</li>
<li>如果他们没有质押任何东西，就不需要计算奖励。</li>
</ul>
<p dir="auto">✅ 节省 gas 并避免不必要的数学。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🕒 计算过了多少时间</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> timeDiff <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span> <span class="pl-k">-</span> staker.lastUpdate;
</pre></div>
<ul dir="auto">
<li>找出自用户奖励上次更新以来<strong>过了多少秒</strong>。</li>
</ul>
<p dir="auto">✅ 他们质押的时间越长，他们赚得越多。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 根据小数位数设置奖励乘数</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> rewardMultiplier <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> stakingTokenDecimals;
</pre></div>
<ul dir="auto">
<li>
<p dir="auto">由于代币可能有不同的小数位数(6、18 等),</p>
<p dir="auto">我们使用代币的小数位数<strong>规范化</strong>奖励计算。</p>
</li>
</ul>
<p dir="auto">✅ 使奖励数学在任何质押代币上保持准确。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💰 计算待处理奖励</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> pendingReward <span class="pl-k">=</span> (timeDiff <span class="pl-k">*</span> rewardRatePerSecond <span class="pl-k">*</span> staker.stakedAmount) <span class="pl-k">/</span> rewardMultiplier;
</pre></div>
<ul dir="auto">
<li>这个公式说:
<ul dir="auto">
<li>乘以<strong>过去的时间</strong> × <strong>奖励率</strong> × <strong>质押金额</strong></li>
<li>然后除以奖励乘数以调整小数位数</li>
</ul>
</li>
</ul>
<p dir="auto">✅ 这给我们用户自上次更新以来赚取的<strong>新奖励</strong>的确切数量。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">➕ 将待处理奖励添加到奖励债务</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>staker.rewardDebt <span class="pl-k">+=</span> pendingReward;
</pre></div>
<ul dir="auto">
<li>我们将新计算的奖励添加到用户的 <code>rewardDebt</code>。</li>
<li>这个奖励债务稍后将在他们调用 <code>claimRewards()</code> 时<strong>被领取</strong>。</li>
</ul>
<p dir="auto">✅ 使奖励随时间公平累积。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🕒 更新上次更新时间</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>staker.lastUpdate <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span>;
</pre></div>
<ul dir="auto">
<li>将用户的上次更新时间戳重置为<strong>现在</strong>。</li>
<li>下次我们更新奖励时，我们将只计算从这一刻起的<strong>新收益</strong>。</li>
</ul>
<p dir="auto">✅ 始终干净地向前移动时间跟踪。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">👀 15. <code>pendingRewards()</code> – 在不触碰的情况下查看你的收益</h1></div>
<p dir="auto">好的 — 用户喜欢看到他们的奖励<strong>实时</strong>增长。</p>
<p dir="auto">但他们不想<strong>每秒</strong>领取奖励 — 有时他们只想<strong>检查</strong>到目前为止他们赚了多少。</p>
<p dir="auto">这正是 <code>pendingRewards()</code> 让他们做的:</p>
<blockquote>
<p dir="auto">这就像检查你的农场，看有多少果实长出来了 —</p>
<p dir="auto">而不用摘它。</p>
</blockquote>
<p dir="auto">这个函数是一个<strong>仅查看函数</strong> —</p>
<p dir="auto">意味着调用它不花费 gas，并且不会改变合约内部的任何东西。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 <code>pendingRewards()</code> 的完整代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">///     查看待处理奖励而不领取</span>
<span class="pl-k">function<span class="pl-en"> pendingRewards</span></span>(<span class="pl-c1">address</span> <span class="pl-v">user</span>) <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span>) {
    StakerInfo <span class="pl-k">memory</span> staker <span class="pl-k">=</span> stakers[user];

    <span class="pl-c1">uint256</span> pendingReward <span class="pl-k">=</span> staker.rewardDebt;

    <span class="pl-k">if</span> (staker.stakedAmount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
        <span class="pl-c1">uint256</span> timeDiff <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span> <span class="pl-k">-</span> staker.lastUpdate;
        <span class="pl-c1">uint256</span> rewardMultiplier <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> stakingTokenDecimals;
        pendingReward <span class="pl-k">+=</span> (timeDiff <span class="pl-k">*</span> rewardRatePerSecond <span class="pl-k">*</span> staker.stakedAmount) <span class="pl-k">/</span> rewardMultiplier;
    }

    <span class="pl-k">return</span> pendingReward;
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 逐行分解</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📚 获取用户信息</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>StakerInfo <span class="pl-k">memory</span> staker <span class="pl-k">=</span> stakers[user];
</pre></div>
<ul dir="auto">
<li>我们将用户的质押信息<strong>加载到内存</strong>中(而不是存储)。</li>
<li>由于我们只是<strong>读取</strong>而不是<strong>更改</strong>任何东西，使用 <code>memory</code> 节省 gas 并更快。</li>
</ul>
<p dir="auto">✅ 查看函数的良好实践。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 从当前存储的奖励开始</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> pendingReward <span class="pl-k">=</span> staker.rewardDebt;
</pre></div>
<ul dir="auto">
<li>从用户<strong>已经累积</strong>但尚未领取的任何奖励开始。</li>
<li>这作为基本待处理奖励金额。</li>
</ul>
<p dir="auto">✅ 在计算更多之前捕获已欠的内容。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🕒 如果他们有质押的代币，添加新奖励</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">if</span> (staker.stakedAmount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
    <span class="pl-c1">uint256</span> timeDiff <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span> <span class="pl-k">-</span> staker.lastUpdate;
    <span class="pl-c1">uint256</span> rewardMultiplier <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> stakingTokenDecimals;
    pendingReward <span class="pl-k">+=</span> (timeDiff <span class="pl-k">*</span> rewardRatePerSecond <span class="pl-k">*</span> staker.stakedAmount) <span class="pl-k">/</span> rewardMultiplier;
}
</pre></div>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">1. <strong>首先，检查用户是否有任何质押的代币。</strong></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">if</span> (staker.stakedAmount <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
</pre></div>
<ul dir="auto">
<li>如果用户没有质押任何东西，他们显然不应该赚取奖励。</li>
<li>所以我们<strong>只在</strong>他们实际上在农场中锁定了一些代币时才计算。</li>
<li>节省 gas 并防止无用的计算。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">2. <strong>计算自我们上次更新他们的奖励以来过了多少时间。</strong></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> timeDiff <span class="pl-k">=</span> <span class="pl-c1">block</span>.<span class="pl-c1">timestamp</span> <span class="pl-k">-</span> staker.lastUpdate;
</pre></div>
<ul dir="auto">
<li><code>block.timestamp</code> 给出<strong>当前时间</strong>(以秒为单位)。</li>
<li><code>staker.lastUpdate</code> 是<strong>上次</strong>我们更新此用户奖励的时间。</li>
<li>通过减法，我们得到<strong>过了多少秒</strong>。</li>
</ul>
<p dir="auto">✅ 这很重要，因为用户<strong>每秒</strong>赚取奖励 —</p>
<p dir="auto">他们质押的时间越长，他们应得的越多。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">3. <strong>使用奖励乘数正确处理代币小数位数。</strong></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> rewardMultiplier <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> stakingTokenDecimals;
</pre></div>
<ul dir="auto">
<li>不同的 ERC-20 代币使用不同数量的小数位数。</li>
<li><code>rewardMultiplier</code> 将一切规范化回<strong>真实世界的数字</strong>。</li>
<li>例如:
<ul dir="auto">
<li>如果代币使用 18 位小数，<code>rewardMultiplier = 10^18</code>。</li>
<li>如果代币使用 6 位小数，<code>rewardMultiplier = 10^6</code>。</li>
</ul>
</li>
<li>这确保数学总是正确缩放。</li>
</ul>
<p dir="auto">✅ 没有这一步，你可能会意外地支付用户<strong>数十亿</strong>或<strong>微小的分数</strong>，取决于代币的设置。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">4. <strong>计算用户在那段时间内赚了多少奖励。</strong></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>pendingReward <span class="pl-k">+=</span> (timeDiff <span class="pl-k">*</span> rewardRatePerSecond <span class="pl-k">*</span> staker.stakedAmount) <span class="pl-k">/</span> rewardMultiplier;
</pre></div>
<ul dir="auto">
<li>简单解释的公式:
<ul dir="auto">
<li><strong><code>timeDiff</code></strong> = 他们一直在赚取的时间有多长。</li>
<li><strong><code>rewardRatePerSecond</code></strong> = 每秒支付多少奖励代币。</li>
<li><strong><code>stakedAmount</code></strong> = 他们质押了多少(更大的质押 = 更大的奖励)。</li>
<li><strong>除以 <code>rewardMultiplier</code></strong> 以调整小数位数。</li>
</ul>
</li>
</ul>
<p dir="auto">✅ 这个计算<strong>准确地衡量</strong>他们自上次互动以来对农场的贡献。</p>
<p dir="auto">注意 <code>+=</code>:</p>
<ul dir="auto">
<li>我们在已经在那里的任何 <code>pendingReward</code> 之上<strong>添加</strong>新奖励。</li>
<li>所以如果他们已经有一些未领取的奖励，我们在上面<strong>堆叠</strong>新的。</li>
<li>什么都不会丢失。什么都不会被覆盖。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔙 返回总待处理奖励</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">return</span> pendingReward;
</pre></div>
<ul dir="auto">
<li>我们返回用户<strong>现在可以领取的</strong>最终奖励金额，如果他们想要的话。</li>
</ul>
<p dir="auto">✅ 前端可以向用户美观地显示此信息。</p>
<hr>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">📏 16. <code>getStakingTokenDecimals()</code> – 帮助前端处理数学</h1></div>
<p dir="auto">好的 — 不同的 ERC-20 代币可以有不同的<strong>小数位数设置</strong>。</p>
<p dir="auto">一些代币使用 18 位小数(如 ETH)，一些使用 6 位小数(如 USDC)，一些甚至更奇怪。</p>
<p dir="auto">当你在前端显示余额、奖励或进行数学运算时，</p>
<p dir="auto"><strong>你需要确切知道质押代币使用多少小数位数</strong> —</p>
<p dir="auto">否则你的数字对用户来说会看起来错误或令人困惑。</p>
<p dir="auto">这就是这个小辅助函数的用武之地:</p>
<blockquote>
<p dir="auto">这就像在测量任何东西之前检查尺子。</p>
<p dir="auto">没有假设，没有错误。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📜 <code>getStakingTokenDecimals()</code> 的完整代码</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">/// 查看质押代币小数位数</span>
<span class="pl-k">function<span class="pl-en"> getStakingTokenDecimals</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint8</span>) {
    <span class="pl-k">return</span> stakingTokenDecimals;
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔍 这一行背后的逻辑</h2></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📚 简单返回小数位数</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">return</span> stakingTokenDecimals;
</pre></div>
<ul dir="auto">
<li>当我们部署合约时，我们<strong>获取</strong>并<strong>保存</strong>了质押代币的小数位数。</li>
<li>现在，这个函数只是<strong>返回</strong>那个存储的值。</li>
<li>没有重新计算。没有消耗 gas 的调用。只是一个干净、快速的读取。</li>
</ul>
<p dir="auto">✅ 前端或用户可以随时调用这个以确切知道如何<strong>缩放</strong>和<strong>显示</strong>代币余额。</p>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🧪 如何在 Remix 上运行和测试你的收益耕作合约</h1></div>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">1️⃣ 部署两个简单的 ERC-20 代币合约</h2></div>
<p dir="auto">在我们甚至可以触碰收益农场之前，</p>
<p dir="auto">我们需要<strong>两个代币</strong>:</p>
<ul dir="auto">
<li>一个用户将<strong>质押</strong>的代币</li>
<li>一个用户将<strong>作为奖励赚取</strong>的代币</li>
</ul>
<p dir="auto">✅ 使用这个简单的 ERC-20 代码:</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">// SPDX-License-Identifier: MIT</span>
<span class="pl-k">pragma solidity</span> <span class="pl-k">^</span><span class="pl-c1">0.8.20</span>;

<span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/token/ERC20/ERC20.sol</span>"</span>;

<span class="pl-k">contract</span> <span class="pl-en">SimpleToken</span> <span class="pl-k">is</span> <span class="pl-en">ERC20</span> {
    <span class="pl-k">constructor</span>(<span class="pl-c1">string</span> <span class="pl-k">memory</span> <span class="pl-v">name</span>, <span class="pl-c1">string</span> <span class="pl-k">memory</span> <span class="pl-v">symbol</span>, <span class="pl-c1">uint256</span> <span class="pl-v">initialSupply</span>) <span class="pl-c1">ERC20</span>(name, symbol) {
        <span class="pl-en">_mint</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, initialSupply);
    }
}
</pre></div>
<p dir="auto"><strong>步骤:</strong></p>
<ul dir="auto">
<li>编译并部署 <strong>SimpleToken</strong> 两次:
<ol dir="auto">
<li>第一次:name = <code>"StakeToken"</code>,symbol = <code>"STK"</code>,initialSupply = <code>1000000 * 10^18</code>(即 100 万个有 18 位小数的代币 — 输入为 <code>1000000000000000000000000</code>)</li>
<li>第二次:name = <code>"RewardToken"</code>,symbol = <code>"RWD"</code>，相同的初始供应量。</li>
</ol>
</li>
</ul>
<p dir="auto">✅ 现在你有两个 ERC-20 代币部署了。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">2️⃣ 部署你的 YieldFarming 合约</h2></div>
<p dir="auto">现在你部署实际的农场!</p>
<p dir="auto">所需输入:</p>
<ul dir="auto">
<li><code>stakingToken</code>:你刚部署的 <code>StakeToken</code> 的地址</li>
<li><code>rewardToken</code>:<code>RewardToken</code> 的地址</li>
<li><code>rewardRatePerSecond</code>:选择像 <code>1000000000000000</code> 这样的东西(如果使用 18 位小数，这是每秒 0.001 奖励代币)</li>
</ul>
<p dir="auto">✅ 这部署了你的耕作平台 — 它准备好接受质押者了!</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">3️⃣ <strong>重要!批准农场移动你的代币</strong></h2></div>
<p dir="auto">在你可以<strong>质押</strong>之前，你必须给 YieldFarming 合约<strong>权限</strong>代表你移动你的质押代币。</p>
<p dir="auto">否则，当你调用 <code>stake()</code> 时，农场将不被允许从你的钱包拉代币。</p>
<p dir="auto"><strong>步骤:</strong></p>
<p dir="auto">转到你部署的 <strong>StakeToken</strong> 合约:</p>
<ul dir="auto">
<li>找到并调用函数:</li>
</ul>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> approve</span></span>(<span class="pl-c1">address</span> <span class="pl-v">spender</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amount</span>) <span class="pl-k">public</span> <span class="pl-k">returns</span> (<span class="pl-c1">bool</span>)
</pre></div>
<ul dir="auto">
<li>参数:
<ul dir="auto">
<li><code>spender</code>:YieldFarming 合约的<strong>地址</strong></li>
<li><code>amount</code>:你允许它拉取的最大数量(设置一些大的，如 <code>1000000000000000000000</code> = 1000 STK)</li>
</ul>
</li>
</ul>
<p dir="auto">✅ 一旦批准，农场现在可以在你调用 <code>stake()</code> 时移动你的质押代币。</p>
<p dir="auto">⚡ <strong>批准对于任何 ERC-20 中的 <code>transferFrom</code></strong> 操作是强制性的。</p>
<hr>
<blockquote>
<p dir="auto">❗ 重要提示:</p>
<p dir="auto">你只需要批准农场一次(除非你想稍后更改津贴)。</p>
<p dir="auto">每次你与使用 <code>transferFrom()</code> 的新代币合约交互时，你必须分别批准它!</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">4️⃣ 资助奖励池(可选但推荐)</h2></div>
<p dir="auto">由于用户将赚取<strong>奖励代币</strong>,</p>
<p dir="auto">你的 YieldFarming 合约需要在其余额中有一些<strong>奖励代币</strong>。</p>
<p dir="auto"><strong>步骤:</strong></p>
<ul dir="auto">
<li>转到你部署的 <strong>RewardToken</strong> 合约。</li>
<li>首先调用 <code>approve()</code>:
<ul dir="auto">
<li><code>spender</code>:YieldFarming 合约地址</li>
<li><code>amount</code>:足够大的数字，如 <code>100000000000000000000000</code>(100,000 RWD)</li>
</ul>
</li>
<li>然后在你的 YieldFarming 合约中，调用:</li>
</ul>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">refillRewards</span>(amount)
</pre></div>
<ul dir="auto">
<li><code>amount</code>:你想要作为奖励转移到农场的 RWD 代币数量。</li>
</ul>
<p dir="auto">✅ 现在你的农场有奖励准备分配了!</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">5️⃣ 质押你的代币</h2></div>
<p dir="auto">现在转到你部署的 <strong>YieldFarming</strong> 合约:</p>
<ul dir="auto">
<li>调用:</li>
</ul>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">stake</span>(amount)
</pre></div>
<ul dir="auto">
<li><code>amount</code>:你想要质押的 STK 代币数量(例如，<code>1000000000000000000000</code> 表示 1000 STK)</li>
</ul>
<p dir="auto">✅ 质押后:</p>
<ul dir="auto">
<li>你的代币被锁定在农场内。</li>
<li>你的奖励赚取立即开始(按秒)!</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">6️⃣ 查看你的待处理奖励</h2></div>
<p dir="auto">等待几秒钟或几分钟后:</p>
<ul dir="auto">
<li>调用:</li>
</ul>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">pendingRewards</span>(<span class="pl-c1">address</span> <span class="pl-v">user</span>)
</pre></div>
<ul dir="auto">
<li><code>user</code>:你的钱包地址</li>
</ul>
<p dir="auto">✅ 它显示你<strong>实时</strong>赚了多少奖励(<code>RWD</code>)，而不用领取。</p>
<p dir="auto">前端(如 Dapps)通常自动调用这个以向用户显示"你到目前为止赚了 X"。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">7️⃣ 领取你的奖励</h2></div>
<p dir="auto">每当你想收获你赚的东西:</p>
<ul dir="auto">
<li>调用:</li>
</ul>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">claimRewards</span>()
</pre></div>
<p dir="auto">✅ 你赚取的奖励代币(<code>RWD</code>)被转移到你的钱包。</p>
<p dir="auto">✅ 你的原始质押保持不变 — 你可以继续耕作!</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">8️⃣ 取消质押你的代币(并稍后继续领取)</h2></div>
<p dir="auto">如果你想移除你的质押:</p>
<ul dir="auto">
<li>调用:</li>
</ul>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">unstake</span>(amount)
</pre></div>
<ul dir="auto">
<li>传递你想要提取的质押代币数量(例如，<code>500000000000000000000</code> = 500 STK)。</li>
</ul>
<p dir="auto">✅ 你取回你的质押。</p>
<p dir="auto">✅ 你仍然可以分别领取任何剩余的奖励。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">9️⃣ 紧急提取(即时退出)</h2></div>
<p dir="auto">如果发生了紧急情况，你想要<strong>即时退出</strong>而不用担心待处理的奖励:</p>
<ul dir="auto">
<li>调用:</li>
</ul>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">emergencyWithdraw</span>()
</pre></div>
<p dir="auto">✅ 你的<strong>整个质押金额</strong>立即回来。</p>
<p dir="auto">✅ <strong>你放弃任何未领取的奖励</strong>。</p>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">🎉 恭喜!</h1></div>
<p dir="auto">你今天不仅仅是部署了另一个智能合约 —</p>
<p dir="auto">你构建了真实世界 DeFi 的支柱。</p>
<p dir="auto">你设计了一个系统，用户可以质押、赚取、提取和收获奖励 — 安全、公平和自动 —</p>
<p dir="auto">正是驱动像 Uniswap、SushiSwap 等平台的那种系统。</p>
<p dir="auto">但更重要的是:</p>
<p dir="auto">你理解了每一行背后的<em>原因</em> —</p>
<p dir="auto">不仅仅是如何编写它，而是<strong>如何像 DeFi 建设者一样思考</strong>。</p>
<p dir="auto">这是一大步。</p>
<p dir="auto">你现在知道如何:</p>
<ul dir="auto">
<li>安全地移动 ERC-20 代币</li>
<li>正确管理批准</li>
<li>随时间计算奖励</li>
<li>保护合约免受攻击</li>
<li>构建<strong>逐块增长价值</strong>的系统</li>
</ul>
<p dir="auto">你不仅仅是在学习 Solidity 了 —</p>
<p dir="auto">你正在构建去中心化金融的未来。</p>
<p dir="auto"><strong>感到自豪吧。认真的。</strong> 🚀</p>
<p dir="auto">农场是活的。</p>
<p dir="auto">种子已经播下了。</p>
<p dir="auto"><strong>而你才刚刚开始。🌱</strong></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/solidity.min.js"></script>
    <script>
        hljs.highlightAll();
        
        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
            
        // Sneha的一封来信模块功能
        document.addEventListener('DOMContentLoaded', function() {
            const envelopeContainer = document.getElementById('envelope-container');
            const answerModal = document.getElementById('answer-modal');
            const closeLetter = document.getElementById('close-letter');
            
            if (!envelopeContainer || !answerModal || !closeLetter) {
                return; // 如果元素不存在，直接返回
            }
            
            // 点击信封打开弹窗
            envelopeContainer.addEventListener('click', function() {
                envelopeContainer.classList.add('open');
                
                // 延迟显示弹窗，让信封翻转动画完成
                setTimeout(function() {
                    answerModal.style.display = 'flex';
                    setTimeout(function() {
                        answerModal.classList.add('open');
                    }, 50);
                }, 400);
            });
            
            // 关闭弹窗
            closeLetter.addEventListener('click', function() {
                answerModal.classList.remove('open');
                
                setTimeout(function() {
                    answerModal.style.display = 'none';
                    envelopeContainer.classList.remove('open');
                }, 600);
            });
            
            // 点击弹窗外部关闭
            answerModal.addEventListener('click', function(e) {
                if (e.target === answerModal) {
                    closeLetter.click();
                }
            });
        });
    </script>
</body>
</html>
