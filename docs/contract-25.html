<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMM - 自动做市商 - Solidity学习</title>
    <link href="https://fonts.googleapis.com/css2?family=Gochi+Hand&family=Reenie+Beanie&family=Comic+Neue:ital,wght@0,400;0,700;1,400&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --accent: #4cc9f0;
            --light: #f8f9fa;
            --dark: #212529;
            --easy: #43AA8B;
            --medium: #F8961E;
            --hard: #E71D36;
            --expert: #7209B7;
            --warm-brown: #8B7355;
            --parchment: #F5F1E6;
            --vintage-blue: #6B8E9F;
            --warm-red: #C44536;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Comic Neue', cursive;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf9 100%);
            color: var(--dark);
            line-height: 1.8;
            background-image: radial-gradient(#d0e3ff 1px, transparent 1px);
            background-size: 30px 30px;
        }
        
        .nav-bar {
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px 20px;
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .nav-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .back-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 10px;
            font-family: 'Comic Neue', cursive;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .back-btn:hover {
            background: var(--secondary);
            transform: translateX(-3px);
        }
        
        .nav-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.3rem;
            color: var(--secondary);
        }
        
        .nav-right {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .nav-btn {
            background: white;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 5px 15px;
            border-radius: 8px;
            font-family: 'Comic Neue', cursive;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
        }
        
        .nav-btn:hover {
            background: var(--primary);
            color: white;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px 20px;
        }
        
        .hero-section {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            border-top: 5px solid var(--accent);
        }
        
        .hero-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .hero-title {
            flex: 1;
            min-width: 250px;
        }
        
        .day-badge {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 8px 20px;
            border-radius: 15px;
            font-family: 'Gochi Hand', cursive;
            font-size: 1.2rem;
            margin-bottom: 10px;
            display: inline-block;
        }
        
        h1 {
            font-family: 'Gochi Hand', cursive;
            font-size: 2.8rem;
            color: var(--secondary);
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 20px;
        }
        
        .meta-tags {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .difficulty-badge {
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            color: white;
            font-size: 1rem;
        }
        
        .tag {
            background: var(--light);
            padding: 5px 15px;
            border-radius: 15px;
            color: var(--secondary);
            font-size: 0.9rem;
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 25px;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.1);
        }
        
        .section-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 2rem;
            color: var(--secondary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px dashed var(--accent);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .key-points {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .key-point {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--accent);
        }
        
        .key-point-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .concept-card {
            background: linear-gradient(135deg, #e6f7ff, #d6f0ff);
            border-left: 5px solid var(--primary);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .concept-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.4rem;
            color: var(--secondary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        pre {
            background: #282c34;
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
            margin: 15px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }
        
        code {
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #f8f8f2;
        }
        
        .inline-code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Fira Code', monospace;
            color: var(--hard);
            font-size: 0.9em;
        }
        
        .navigation-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .nav-footer-btn {
            flex: 1;
            min-width: 200px;
            background: white;
            border: 3px solid var(--primary);
            padding: 20px;
            border-radius: 15px;
            text-decoration: none;
            color: var(--dark);
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .nav-footer-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .nav-footer-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .nav-footer-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.3rem;
        }        
        /* 参考答案模块样式 - 温暖治愈风格 */
        .answer-reference {
            position: relative;
            margin: 60px 0 30px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .envelope-container {
            position: relative;
            width: 340px;
            height: 240px;
            cursor: pointer;
            perspective: 1200px;
            margin-bottom: 20px;
            filter: drop-shadow(0 10px 20px rgba(139, 115, 85, 0.2));
        }
        
        .envelope {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        .envelope-front, .envelope-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .envelope-front {
            background: linear-gradient(135deg, #f9f3e9, #e8dfd1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #d4c9b8;
        }
        
        .envelope-flap {
            position: absolute;
            top: -70px;
            width: 0;
            height: 0;
            border-left: 170px solid transparent;
            border-right: 170px solid transparent;
            border-bottom: 70px solid #e8dfd1;
            z-index: 1;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.1));
        }
        
        .envelope-flap::after {
            content: "";
            position: absolute;
            top: 3px;
            left: -170px;
            width: 0;
            height: 0;
            border-left: 170px solid transparent;
            border-right: 170px solid transparent;
            border-bottom: 67px solid #f9f3e9;
        }
        
        .envelope-seal {
            position: absolute;
            bottom: 25px;
            right: 35px;
            width: 70px;
            height: 70px;
            background: radial-gradient(circle at 30% 30%, #C44536, #8B2E24);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 2;
            border: 2px solid #A52A2A;
        }
        
        .seal-icon {
            color: #F5F1E6;
            font-size: 1.8rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .envelope-text {
            font-family: 'Reenie Beanie', cursive;
            font-size: 2.4rem;
            color: var(--warm-brown);
            z-index: 2;
            position: relative;
            margin-top: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            letter-spacing: 1px;
        }
        
        .envelope-pattern {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 15% 25%, rgba(139, 115, 85, 0.05) 3px, transparent 3px),
                radial-gradient(circle at 85% 75%, rgba(139, 115, 85, 0.05) 3px, transparent 3px);
            background-size: 40px 40px;
            z-index: 0;
        }
        
        .envelope-back {
            background: linear-gradient(135deg, #f5f1e6, #e8dfd1);
            transform: rotateY(180deg);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d4c9b8;
        }
        
        .envelope-container:hover .envelope {
            transform: rotateY(10deg) translateY(-5px);
        }
        
        .envelope-container.open .envelope {
            transform: rotateY(180deg);
        }
        
        .envelope-hint {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.3rem;
            color: var(--warm-brown);
            margin-top: 15px;
            opacity: 0.9;
            background: rgba(245, 241, 230, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
        }
        
        /* 弹窗样式 */
        .answer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            background: rgba(107, 142, 159, 0.7);
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(3px);
        }
        
        .letter-container {
            width: 90%;
            max-width: 900px;
            height: 80vh;
            background: #F5F1E6;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(107, 142, 159, 0.4);
            overflow: hidden;
            transform: scale(0);
            transition: transform 0.7s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            flex-direction: column;
            position: relative;
            border: 1px solid #d4c9b8;
        }
        
        .answer-modal.open .letter-container {
            transform: scale(1);
        }
        
        .letter-header {
            background: linear-gradient(135deg, #8B7355, #6B5A45);
            padding: 25px 30px;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-bottom: 2px dashed #A5947A;
        }
        
        .letter-title {
            font-family: 'Reenie Beanie', cursive;
            font-size: 3rem;
            color: #F5F1E6;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            letter-spacing: 2px;
        }
        
        .letter-subtitle {
            color: rgba(245, 241, 230, 0.9);
            font-size: 1.3rem;
            font-family: 'Gochi Hand', cursive;
        }
        
        .close-letter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(245, 241, 230, 0.2);
            color: #F5F1E6;
            border: 1px solid rgba(245, 241, 230, 0.3);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }
        
        .close-letter:hover {
            background: rgba(245, 241, 230, 0.3);
            transform: rotate(90deg);
        }
        
        .letter-body {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            background: #F5F1E6;
            position: relative;
        }
        
        .letter-body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background-image: 
                linear-gradient(90deg, transparent 98%, rgba(139, 115, 85, 0.1) 98%),
                linear-gradient(rgba(139, 115, 85, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
        }
        
        /* MD内容样式 */
        .md-content {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        .md-section {
            margin-bottom: 40px;
        }
        
        .md-section h1 {
            font-family: 'Reenie Beanie', cursive;
            font-size: 3rem;
            color: var(--warm-brown);
            margin-bottom: 20px;
            border-bottom: 2px dashed #A5947A;
            padding-bottom: 10px;
            text-align: center;
        }
        
        .md-section h2 {
            font-family: 'Reenie Beanie', cursive;
            font-size: 2.2rem;
            color: var(--warm-brown);
            margin: 30px 0 15px 0;
            position: relative;
            padding-left: 25px;
        }
        
        .md-section h2::before {
            content: "•";
            position: absolute;
            left: 0;
            top: 0;
            color: var(--warm-red);
            font-size: 2.5rem;
        }
        
        .md-meta {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .md-tag {
            background: rgba(139, 115, 85, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            color: var(--warm-brown);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
            border: 1px solid rgba(139, 115, 85, 0.2);
        }
        
        .md-highlight {
            background: rgba(107, 142, 159, 0.1);
            border-left: 5px solid var(--vintage-blue);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            border: 1px solid rgba(107, 142, 159, 0.2);
        }
        
        .md-content pre {
            background: #2d2a2e;
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.1);
            border: 1px solid #3a363b;
        }
        
        .md-content code {
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #f8f8f2;
        }
        
        .md-content .inline-code {
            background: rgba(139, 115, 85, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            color: var(--warm-brown);
            font-size: 0.9em;
            border: 1px solid rgba(139, 115, 85, 0.2);
        }
        
        .md-content ul, .md-content ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .md-content li {
            margin-bottom: 8px;
            line-height: 1.7;
        }
        
        .md-content blockquote {
            border-left: 4px solid var(--vintage-blue);
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #666;
            background: rgba(107, 142, 159, 0.05);
            padding: 15px 20px;
            border-radius: 0 8px 8px 0;
        }
        
        .md-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(139, 115, 85, 0.2);
        }
        
        .md-content th, .md-content td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(139, 115, 85, 0.2);
        }
        
        .md-content th {
            background: linear-gradient(135deg, var(--warm-brown), #6B5A45);
            color: #F5F1E6;
            font-weight: bold;
            font-family: 'Gochi Hand', cursive;
            font-size: 1.1rem;
        }
        
        .md-content tr:nth-child(even) {
            background: rgba(139, 115, 85, 0.05);
        }
        
        .signature {
            text-align: right;
            margin-top: 40px;
            font-family: 'Reenie Beanie', cursive;
            font-size: 2rem;
            color: var(--warm-brown);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .hero-section {
                padding: 25px;
            }
            
            .section {
                padding: 20px;
            }
            
            .key-points {
                grid-template-columns: 1fr;
            }
            
            .envelope-container {
                width: 300px;
                height: 210px;
            }
            
            .envelope-flap {
                border-left: 150px solid transparent;
                border-right: 150px solid transparent;
                border-bottom: 60px solid #e8dfd1;
            }
            
            .envelope-flap::after {
                border-left: 150px solid transparent;
                border-right: 150px solid transparent;
                border-bottom: 57px solid #f9f3e9;
                left: -150px;
            }
            
            .envelope-text {
                font-size: 2rem;
            }
            
            .answer-modal {
                padding: 10px;
            }
            
            .letter-container {
                width: 95%;
                height: 85vh;
            }
            
            .letter-title {
                font-size: 2.2rem;
            }
            
            .md-section h1 {
                font-size: 2.2rem;
            }
            
            .md-section h2 {
                font-size: 1.8rem;
            }
        }
    </style>

        <style>
        /* 隐藏 mermaid 渲染组件 */
        .md-content section.js-render-needs-enrichment,
        .md-content .js-render-enrichment-target,
        .md-content .js-render-block-actions,
        .md-content .render-container,
        .md-content .js-render-enrichment-fallback,
        .md-content details[class*="details"],
        .md-content iframe[title="File display"] {
            display: none !important;
        }
        
        /* 修复 GitHub 代码块样式 */
        .md-content .highlight,
        .md-content .highlight-source-solidity,
        .md-content .highlight-source-js,
        .md-content .highlight-source-javascript {
            background: #2d2a2e !important;
            border-radius: 10px;
            padding: 20px !important;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.1);
            border: 1px solid #3a363b;
        }
        
        .md-content .highlight pre,
        .md-content .highlight-source-solidity pre,
        .md-content .highlight-source-js pre {
            background: transparent !important;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
        }
        
        /* 基础代码文字颜色 - 确保所有文字都可见 */
        .md-content .highlight pre {
            color: #f8f8f2 !important;
        }
        
        .md-content .highlight code,
        .md-content .highlight pre code,
        .md-content .highlight pre span,
        .md-content .highlight pre * {
            /* Added to ensure all text in pre is visible */
            color: #f8f8f2 !important;
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        /* 确保代码块内所有文字（包括没有 span 包裹的文字）都可见 */
        .md-content .highlight pre,
        .md-content .highlight pre code {
            color: #f8f8f2 !important;
        }
        
        /* 特别处理代码块中的纯文本节点（没有被 span 包裹的文字，如变量名） */
        .md-content .highlight pre {
            color: #f8f8f2 !important;
        }
        
        /* 确保所有直接文本内容都可见 - 覆盖继承的颜色 */
        .md-content .highlight pre * {
            color: #f8f8f2 !important;
        }
        
        /* 特别处理变量名 - 确保清晰可见 */
        .md-content .highlight pre span.pl-v,
        .md-content .highlight pre span.pl-en,
        .md-content .highlight pre span.pl-e {
            color: #dcdcaa !important;
            font-weight: 500 !important;
        }
        
        /* GitHub 语法高亮类颜色修复 */
        .md-content .highlight [class*="pl-"] {
            color: #f8f8f2 !important; /* Default to light color */
        }
        .md-content .highlight .pl-c { /* 注释 */
            color: #6a9955 !important;
        }
        .md-content .highlight .pl-s, .md-content .highlight .pl-s1 { /* 字符串 */
            color: #ce9178 !important;
        }
        .md-content .highlight .pl-k, .md-content .highlight .pl-c1 { /* 关键字/常量 */
            color: #569cd6 !important;
        }
        .md-content .highlight .pl-v, .md-content .highlight .pl-en, .md-content .highlight .pl-e, .md-content .highlight .pl-ent { /* 变量/函数名/实体名 */
            color: #dcdcaa !important;
            font-weight: 500 !important;
        }
        .md-content code {
            background-color: rgba(139, 115, 85, 0.15);
            color: var(--warm-brown);
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }
        </style>
        </head>
<body>
    <div class="nav-bar">
        <div class="nav-left">
            <a href="index.html" class="back-btn">
                <i class="fas fa-arrow-left"></i> 返回首页
            </a>
            <span class="nav-title">第25天 - 自动做市商</span>
        </div>
        <div class="nav-right">
            <a href="#concepts" class="nav-btn">📚 核心概念</a>
            <a href="#code" class="nav-btn">💻 代码讲解</a>
            <a href="#practice" class="nav-btn">🎯 实践</a>
        </div>
    </div>

    <div class="container">
        <div class="hero-section">
            <div class="hero-header">
                <div class="hero-title">
                    <div class="day-badge">第 25 天 🔄</div>
                    <h1>AMM - 自动做市商</h1>
                    <p class="subtitle">构建Uniswap风格的去中心化交易引擎</p>
                </div>
                <div class="meta-tags">
                    <div class="difficulty-badge" style="background: var(--expert);">
                        🏆 专家
                    </div>
                    <span class="tag">AMM</span>
                    <span class="tag">流动性池</span>
                    <span class="tag">x*y=k</span>
                    <span class="tag">LP代币</span>
                </div>
            </div>
            
            <div class="key-points">
                <div class="key-point">
                    <div class="key-point-title">📌 学习目标</div>
                    <div>掌握AMM原理和流动性池机制</div>
                </div>
                <div class="key-point">
                    <div class="key-point-title">🎯 核心技能</div>
                    <div>常数乘积公式、LP代币、滑点控制</div>
                </div>
                <div class="key-point">
                    <div class="key-point-title">⏱️ 预计时间</div>
                    <div>80分钟</div>
                </div>
                <div class="key-point">
                    <div class="key-point-title">🔥 难度系数</div>
                    <div>★★★★★</div>
                </div>
            </div>
        </div>

        <div class="section" id="concepts">
            <h2 class="section-title">
                <i class="fas fa-lightbulb"></i> 核心概念详解
            </h2>
            
            <div class="concept-card">
                <div class="concept-title">🏛️ 从订单簿到AMM的革命</div>
                <p>传统交易所使用订单簿匹配买卖双方，但在区块链上存在问题：</p>
                <div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong style="color: #721c24;">❌ 订单簿的问题</strong>
                    <ul style="margin-left: 20px; margin-top: 10px; color: #721c24;">
                        <li>每次下单都需要Gas费用</li>
                        <li>需要等待交易对手方</li>
                        <li>流动性分散，价格发现困难</li>
                        <li>中心化程度高</li>
                    </ul>
                </div>
                <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong style="color: #155724;">✅ AMM的优势</strong>
                    <ul style="margin-left: 20px; margin-top: 10px; color: #155724;">
                        <li>无需等待对手方，即时交易</li>
                        <li>数学公式自动定价</li>
                        <li>流动性集中在池中</li>
                        <li>完全去中心化</li>
                    </ul>
                </div>
                <p><strong>核心思想：</strong>用数学公式替代人工订单匹配！</p>
            </div>

            <div class="concept-card">
                <div class="concept-title">📐 常数乘积公式 x × y = k</div>
                <p>AMM的核心是一个简单而强大的数学公式：</p>
                <div style="background: #fff3cd; padding: 20px; border-radius: 8px; margin: 15px 0; text-align: center;">
                    <h3 style="color: #856404; font-size: 1.8rem; margin-bottom: 10px;">x × y = k</h3>
                    <p style="color: #856404;">
                        <strong>x</strong> = 代币A的数量<br>
                        <strong>y</strong> = 代币B的数量<br>
                        <strong>k</strong> = 常数（不变）
                    </p>
                </div>
                <p><strong>工作原理：</strong></p>
                <ol style="margin-left: 25px; margin-top: 10px; line-height: 2;">
                    <li>池中有1000个ETH和2000个DAI，k = 1000 × 2000 = 2,000,000</li>
                    <li>用户想用100个ETH换DAI</li>
                    <li>新的ETH数量：1000 + 100 = 1100</li>
                    <li>为保持k不变：1100 × y = 2,000,000，所以 y = 1818.18</li>
                    <li>用户得到：2000 - 1818.18 = 181.82个DAI</li>
                </ol>
                <p><strong>关键特性：</strong></p>
                <ul style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                    <li>交易量越大，价格影响越大（滑点）</li>
                    <li>池子永远不会完全耗尽</li>
                    <li>价格自动调整，无需人工干预</li>
                </ul>
            </div>

            <div class="concept-card">
                <div class="concept-title">🏊‍♂️ 流动性池和LP代币</div>
                <p>流动性提供者（LP）为池子提供资金，获得LP代币作为凭证：</p>
                <pre><code class="language-solidity">// 添加流动性
function addLiquidity(uint256 amountA, uint256 amountB) external {
    // 转入代币
    tokenA.transferFrom(msg.sender, address(this), amountA);
    tokenB.transferFrom(msg.sender, address(this), amountB);
    
    uint256 liquidity;
    if (totalSupply() == 0) {
        // 首次添加：LP = sqrt(amountA * amountB)
        liquidity = sqrt(amountA * amountB);
    } else {
        // 后续添加：按比例计算
        liquidity = min(
            amountA * totalSupply() / reserveA,
            amountB * totalSupply() / reserveB
        );
    }
    
    _mint(msg.sender, liquidity);  // 铸造LP代币
}</code></pre>
                <p><strong>LP代币特点：</strong></p>
                <ul style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                    <li><strong>所有权证明：</strong>代表在池中的份额</li>
                    <li><strong>可赎回：</strong>随时换回底层资产</li>
                    <li><strong>收益来源：</strong>交易手续费分成</li>
                    <li><strong>可转让：</strong>LP代币本身可以交易</li>
                </ul>
            </div>

            <div class="concept-card">
                <div class="concept-title">💹 滑点和价格影响</div>
                <p>滑点是AMM中的重要概念，影响交易体验：</p>
                <pre><code class="language-solidity">function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) 
    public pure returns (uint256 amountOut) {
    
    // 应用0.3%手续费
    uint256 amountInWithFee = amountIn * 997;
    uint256 numerator = amountInWithFee * reserveOut;
    uint256 denominator = reserveIn * 1000 + amountInWithFee;
    
    amountOut = numerator / denominator;
}</code></pre>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>滑点计算示例：</strong>
                    <p style="margin-top: 10px;">
                        池子：1000 ETH ↔ 2000 DAI<br>
                        交易：100 ETH → ? DAI<br>
                        预期价格：1 ETH = 2 DAI<br>
                        实际获得：~181.82 DAI<br>
                        <strong style="color: var(--hard);">滑点：(200-181.82)/200 = 9.09%</strong>
                    </p>
                </div>
                <p><strong>滑点保护：</strong></p>
                <pre><code class="language-solidity">function swapAforB(uint256 amountAIn, uint256 minBOut) external {
    uint256 amountBOut = getAmountOut(amountAIn, reserveA, reserveB);
    require(amountBOut >= minBOut, "Slippage too high");
    // 执行交换...
}</code></pre>
            </div>
        </div>

        <div class="section" id="code">
            <h2 class="section-title">
                <i class="fas fa-code"></i> 完整代码详解
            </h2>
            
            <h3 style="color: var(--secondary); margin: 20px 0;">📄 AMM合约完整实现</h3>
            <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract AutomatedMarketMaker is ERC20 {
    IERC20 public tokenA;
    IERC20 public tokenB;
    
    uint256 public reserveA;
    uint256 public reserveB;
    
    address public owner;
    
    event LiquidityAdded(address indexed provider, uint256 amountA, uint256 amountB, uint256 liquidity);
    event LiquidityRemoved(address indexed provider, uint256 amountA, uint256 amountB, uint256 liquidity);
    event TokensSwapped(address indexed trader, address tokenIn, uint256 amountIn, address tokenOut, uint256 amountOut);
    
    constructor(address _tokenA, address _tokenB, string memory _name, string memory _symbol)
        ERC20(_name, _symbol)
    {
        tokenA = IERC20(_tokenA);
        tokenB = IERC20(_tokenB);
        owner = msg.sender;
    }
    
    // 添加流动性
    function addLiquidity(uint256 amountA, uint256 amountB) external {
        require(amountA > 0 && amountB > 0, "Amounts must be > 0");
        
        tokenA.transferFrom(msg.sender, address(this), amountA);
        tokenB.transferFrom(msg.sender, address(this), amountB);
        
        uint256 liquidity;
        if (totalSupply() == 0) {
            // 首次添加流动性
            liquidity = sqrt(amountA * amountB);
        } else {
            // 按现有比例添加
            liquidity = min(
                amountA * totalSupply() / reserveA,
                amountB * totalSupply() / reserveB
            );
        }
        
        _mint(msg.sender, liquidity);
        
        reserveA += amountA;
        reserveB += amountB;
        
        emit LiquidityAdded(msg.sender, amountA, amountB, liquidity);
    }
    
    // 移除流动性
    function removeLiquidity(uint256 liquidityToRemove) external returns (uint256 amountAOut, uint256 amountBOut) {
        require(liquidityToRemove > 0, "Liquidity to remove must be > 0");
        require(balanceOf(msg.sender) >= liquidityToRemove, "Insufficient liquidity tokens");
        
        uint256 totalLiquidity = totalSupply();
        require(totalLiquidity > 0, "No liquidity in the pool");
        
        // 按比例计算可提取的代币数量
        amountAOut = liquidityToRemove * reserveA / totalLiquidity;
        amountBOut = liquidityToRemove * reserveB / totalLiquidity;
        
        require(amountAOut > 0 && amountBOut > 0, "Insufficient reserves");
        
        reserveA -= amountAOut;
        reserveB -= amountBOut;
        
        _burn(msg.sender, liquidityToRemove);
        
        tokenA.transfer(msg.sender, amountAOut);
        tokenB.transfer(msg.sender, amountBOut);
        
        emit LiquidityRemoved(msg.sender, amountAOut, amountBOut, liquidityToRemove);
        return (amountAOut, amountBOut);
    }
    
    // A换B
    function swapAforB(uint256 amountAIn, uint256 minBOut) external {
        require(amountAIn > 0, "Amount must be > 0");
        require(reserveA > 0 && reserveB > 0, "Insufficient reserves");
        
        // 计算输出数量（扣除0.3%手续费）
        uint256 amountAInWithFee = amountAIn * 997 / 1000;
        uint256 amountBOut = reserveB * amountAInWithFee / (reserveA + amountAInWithFee);
        
        require(amountBOut >= minBOut, "Slippage too high");
        
        tokenA.transferFrom(msg.sender, address(this), amountAIn);
        tokenB.transfer(msg.sender, amountBOut);
        
        reserveA += amountAInWithFee;  // 手续费留在池中
        reserveB -= amountBOut;
        
        emit TokensSwapped(msg.sender, address(tokenA), amountAIn, address(tokenB), amountBOut);
    }
    
    // B换A
    function swapBforA(uint256 amountBIn, uint256 minAOut) external {
        require(amountBIn > 0, "Amount must be > 0");
        require(reserveA > 0 && reserveB > 0, "Insufficient reserves");
        
        uint256 amountBInWithFee = amountBIn * 997 / 1000;
        uint256 amountAOut = reserveA * amountBInWithFee / (reserveB + amountBInWithFee);
        
        require(amountAOut >= minAOut, "Slippage too high");
        
        tokenB.transferFrom(msg.sender, address(this), amountBIn);
        tokenA.transfer(msg.sender, amountAOut);
        
        reserveB += amountBInWithFee;
        reserveA -= amountAOut;
        
        emit TokensSwapped(msg.sender, address(tokenB), amountBIn, address(tokenA), amountAOut);
    }
    
    // 获取储备量
    function getReserves() external view returns (uint256, uint256) {
        return (reserveA, reserveB);
    }
    
    // 计算交换输出
    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) 
        public pure returns (uint256 amountOut) {
        require(amountIn > 0, "Amount in must be > 0");
        require(reserveIn > 0 && reserveOut > 0, "Insufficient reserves");
        
        uint256 amountInWithFee = amountIn * 997;
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = reserveIn * 1000 + amountInWithFee;
        
        amountOut = numerator / denominator;
    }
    
    // 工具函数
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
    
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}</code></pre>

            <div style="background: linear-gradient(135deg, #d4edda, #c3e6cb); border-left: 5px solid #28a745; padding: 20px; border-radius: 10px; margin: 20px 0;">
                <strong style="color: #155724;">✅ AMM核心机制</strong>
                <p style="margin-top: 10px; color: #155724;">
                    1. 流动性提供者存入代币对，获得LP代币 → 2. 交易者使用常数乘积公式进行代币交换 → 3. 手续费留在池中，增加LP收益 → 4. LP可随时赎回代币和累积收益
                </p>
            </div>

            <div style="background: #fff3cd; border-left: 5px solid #ffc107; padding: 20px; border-radius: 10px; margin: 20px 0;">
                <strong style="color: #856404;">⚠️ 无常损失风险</strong>
                <p style="margin-top: 10px; color: #856404;">
                    当代币价格比例发生变化时，LP可能面临无常损失。例如：存入1 ETH + 2000 DAI，如果ETH涨到4000 DAI，LP的资产价值可能低于单纯持有代币。这是AMM的固有风险。
                </p>
            </div>
        </div>

        <div class="section" id="practice">
            <h2 class="section-title">
                <i class="fas fa-dumbbell"></i> 实践与练习
            </h2>
            
            <h3 style="color: var(--secondary); margin-bottom: 20px;">📝 Remix实战步骤</h3>
            
            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤1: 准备代币</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>部署两个ERC-20测试代币（TokenA和TokenB）</li>
                    <li>给自己铸造足够的代币用于测试</li>
                    <li>记录代币合约地址</li>
                </ol>
            </div>

            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤2: 部署AMM合约</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>使用代币地址部署AMM合约</li>
                    <li>设置LP代币名称和符号</li>
                    <li>验证合约部署成功</li>
                </ol>
            </div>

            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤3: 添加初始流动性</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>批准AMM合约使用你的代币</li>
                    <li>调用<code class="inline-code">addLiquidity(1000, 2000)</code>建立1:2的价格比例</li>
                    <li>检查获得的LP代币数量</li>
                    <li>验证池子储备量</li>
                </ol>
            </div>

            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤4: 测试代币交换</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>使用<code class="inline-code">getAmountOut()</code>预估交换结果</li>
                    <li>调用<code class="inline-code">swapAforB(100, 180)</code>进行交换</li>
                    <li>观察滑点和价格变化</li>
                    <li>尝试反向交换验证价格机制</li>
                </ol>
            </div>

            <div style="margin: 30px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.2rem;">步骤5: 移除流动性</h4>
                <ol style="margin: 10px 0 10px 25px; line-height: 2;">
                    <li>调用<code class="inline-code">removeLiquidity()</code>移除部分LP</li>
                    <li>检查获得的代币数量</li>
                    <li>验证手续费收益</li>
                    <li>观察池子储备变化</li>
                </ol>
            </div>

            <h3 style="color: var(--secondary); margin: 40px 0 20px 0;">🎯 挑战练习</h3>
            <div style="background: linear-gradient(135deg, #fff9e6, #ffedd5); border-left: 5px solid var(--medium); padding: 25px; border-radius: 10px;">
                <p style="font-weight: bold; margin-bottom: 15px; font-size: 1.1rem;">尝试以下改进:</p>
                <ol style="margin-left: 25px; line-height: 2.2;">
                    <li>实现多代币池（支持3个或更多代币）</li>
                    <li>添加动态手续费机制</li>
                    <li>实现价格预言机功能</li>
                    <li>添加流动性挖矿奖励</li>
                    <li>实现闪电贷功能</li>
                    <li>创建AMM工厂合约</li>
                </ol>
            </div>

            <h3 style="color: var(--secondary); margin: 40px 0 20px 0;">📚 扩展知识</h3>
            
            <div style="background: white; border: 2px solid var(--accent); padding: 20px; border-radius: 10px; margin: 20px 0;">
                <h4 style="color: var(--primary); margin-bottom: 10px;">不同AMM模型对比</h4>
                <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                    <tr style="background: var(--light);">
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--accent);">模型</th>
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--accent);">公式</th>
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--accent);">特点</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Uniswap V2</td>
                        <td style="padding: 10px;">x * y = k</td>
                        <td style="padding: 10px;">简单、通用</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 10px;">Curve</td>
                        <td style="padding: 10px;">稳定币优化</td>
                        <td style="padding: 10px;">低滑点</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Balancer</td>
                        <td style="padding: 10px;">加权池</td>
                        <td style="padding: 10px;">多代币、自定义权重</td>
                    </tr>
                </table>
            </div>

            <div style="background: white; border: 2px solid var(--accent); padding: 20px; border-radius: 10px; margin: 20px 0;">
                <h4 style="color: var(--primary); margin-bottom: 10px;">无常损失计算</h4>
                <pre><code class="language-javascript">// 无常损失计算公式
function calculateImpermanentLoss(priceRatio) {
    // priceRatio = 当前价格 / 初始价格
    const loss = 2 * Math.sqrt(priceRatio) / (1 + priceRatio) - 1;
    return Math.abs(loss) * 100; // 转换为百分比
}

// 示例：ETH价格翻倍
console.log(calculateImpermanentLoss(2)); // ~5.72%</code></pre>
                <p style="margin-top: 10px;">价格变化越大，无常损失越严重。这是LP需要考虑的主要风险。</p>
            </div>
        </div>

        <div class="navigation-footer">
            <a href="contract-24.html" class="nav-footer-btn" style="border-color: var(--accent);">
                <div class="nav-footer-label">← 上一个</div>
                <div class="nav-footer-title">DecentraliseEscrow - 去中心化托管</div>
            </a>
            <a href="contract-26.html" class="nav-footer-btn" style="border-color: var(--accent);">
                <div class="nav-footer-label">下一个 →</div>
                <div class="nav-footer-title">NFT Marketplace - NFT市场</div>
            </a>
        </div>
    
        <!-- Sneha的一封来信模块 -->
        <div class="answer-reference">
            <div class="envelope-container" id="envelope-container">
                <div class="envelope">
                    <div class="envelope-front">
                        <div class="envelope-flap"></div>
                        <div class="envelope-pattern"></div>
                        <div class="envelope-seal">
                            <i class="fas fa-feather-alt seal-icon"></i>
                        </div>
                        <div class="envelope-text">Sneha的一封来信</div>
                    </div>
                    <div class="envelope-back">
                        <div class="envelope-text" style="color: var(--warm-brown);">点击开启</div>
                    </div>
                </div>
            </div>
            <div class="envelope-hint">点击信封查看Sneha的来信</div>
        </div>
    </div>

    <!-- 弹窗 - 内容待后续精细化处理 -->
    <div class="answer-modal" id="answer-modal">
        <div class="letter-container">
            <div class="letter-header">
                <div class="letter-title">Sneha的一封来信</div>
                <div class="letter-subtitle">关于第25天的学习指导</div>
                <button id="close-letter" class="close-letter">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="letter-body">
                <div id="md-content" class="md-content">
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">自动做市商合约</h1></div>
<p dir="auto">Day: Day 25
ID: 25
译者: 月亮
难度等级: 高级</p>
<p dir="auto">欢迎回到 <strong>30天学Solidity</strong> —— 在这里，我们每天把一个复杂概念变成你真正能理解的代码。</p>
<p dir="auto">今天，我们将揭开 DeFi 中最传奇机制之一的神秘面纱：</p>
<p dir="auto"><strong>自动化做市商（Automated Market Maker）</strong>，简称 AMM。</p>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">产品需求说明书</h1></div>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">用户流程</h2></div>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">数据库</h2></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>Contract</th>
<th>Type</th>
<th>Bases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AutomatedMarketMaker</strong></td>
<td>Implementation</td>
<td>ERC20</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">状态变量</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>变量名</th>
<th>类型</th>
<th>可见性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tokenA</td>
<td>IERC20</td>
<td>Public</td>
<td>代币A合约地址</td>
</tr>
<tr>
<td>tokenB</td>
<td>IERC20</td>
<td>Public</td>
<td>代币B合约地址</td>
</tr>
<tr>
<td>reserveA</td>
<td>uint256</td>
<td>Public</td>
<td>代币A储备量</td>
</tr>
<tr>
<td>reserveB</td>
<td>uint256</td>
<td>Public</td>
<td>代币B储备量</td>
</tr>
<tr>
<td>owner</td>
<td>address</td>
<td>Public</td>
<td>合约所有者</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">函数清单</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>Function Name</th>
<th>Visibility</th>
<th>Mutability</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>constructor</strong></td>
<td>Public ❗️</td>
<td>🛑</td>
<td>构造函数，初始化代币对和合约名称</td>
</tr>
<tr>
<td><strong>addLiquidity</strong></td>
<td>Public ❗️</td>
<td>🛑</td>
<td>添加流动性到资金池</td>
</tr>
<tr>
<td><strong>removeLiquidity</strong></td>
<td>Public ❗️</td>
<td>🛑</td>
<td>从资金池移除流动性</td>
</tr>
<tr>
<td><strong>swapAforB</strong></td>
<td>Public ❗️</td>
<td>🛑</td>
<td>用代币A交换代币B</td>
</tr>
<tr>
<td><strong>swapBforA</strong></td>
<td>Public ❗️</td>
<td>🛑</td>
<td>用代币B交换代币A</td>
</tr>
<tr>
<td><strong>getReserves</strong></td>
<td>Public ❗️</td>
<td></td>
<td>查看当前储备量</td>
</tr>
<tr>
<td><strong>min</strong></td>
<td>Internal</td>
<td></td>
<td>返回两个值中的较小值</td>
</tr>
<tr>
<td><strong>sqrt</strong></td>
<td>Internal</td>
<td></td>
<td>巴比伦平方根算法</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">事件</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>Event Name</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LiquidityAdded</strong></td>
<td>provider, amountA, amountB, liquidity</td>
<td>流动性添加事件</td>
</tr>
<tr>
<td><strong>LiquidityRemoved</strong></td>
<td>provider, amountA, amountB, liquidity</td>
<td>流动性移除事件</td>
</tr>
<tr>
<td><strong>TokensSwapped</strong></td>
<td>trader, tokenIn, amountIn, tokenOut, amountOut</td>
<td>代币交换事件</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">继承的ERC20函数</h3></div>
<markdown-accessiblity-table data-catalyst=""><table>
<thead>
<tr>
<th>Function Name</th>
<th>Visibility</th>
<th>Mutability</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>totalSupply</strong></td>
<td>Public ❗️</td>
<td></td>
<td>获取总供应量</td>
</tr>
<tr>
<td><strong>balanceOf</strong></td>
<td>Public ❗️</td>
<td></td>
<td>获取账户余额</td>
</tr>
<tr>
<td><strong>_mint</strong></td>
<td>Internal</td>
<td>🛑</td>
<td>铸造代币</td>
</tr>
<tr>
<td><strong>_burn</strong></td>
<td>Internal</td>
<td>🛑</td>
<td>销毁代币</td>
</tr>
<tr>
<td><strong>transfer</strong></td>
<td>Public ❗️</td>
<td>🛑</td>
<td>转账代币</td>
</tr>
<tr>
<td><strong>transferFrom</strong></td>
<td>Public ❗️</td>
<td>🛑</td>
<td>从指定地址转账</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">细节解释</h1></div>
<hr>
<p dir="auto">自动化做市商是 <strong>DeFi 最强大的发明之一</strong> —— 这种东西帮助智能合约变成成熟的金融应用程序</p>
<p dir="auto">我们在谈论：</p>
<p dir="auto"><strong>自动化做市商</strong> —— 也就是 AMM。</p>
<p dir="auto">但如果你觉得听起来很高大上，不用担心 ——</p>
<p dir="auto">因为在学习结束时，你不仅会知道 AMM 是什么，</p>
<p dir="auto">你还能够自己构建一个 AMM。</p>
<p dir="auto">让我们先从 <strong>为什么 AMM 会存在</strong> 的故事开始。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🏛️ 回到过去：人们如何交易加密货币</h2></div>
<p dir="auto">让我们回到交易最初的运作方式 —— 即使在加密货币的早期：</p>
<p dir="auto">它就像一个股票市场。</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>买家</strong>说：</p>
<p dir="auto"><em>“我想买 1 个 DAI，我愿意付 0.95 个 ETH。”</em></p>
</li>
<li>
<p dir="auto"><strong>卖家</strong>说：</p>
<p dir="auto"><em>“我有 1 个 DAI 想卖，但我想要 1 个 ETH。”</em></p>
</li>
<li>
<p dir="auto">买家和卖家中间坐着一个叫做 <strong>订单簿</strong> 的系统。</p>
<p dir="auto">把它想象成一个巨大的列表，用来匹配买家和卖家。</p>
</li>
</ul>
<p dir="auto">当买家和卖家对价格达成一致？砰 —— 交易发生了。</p>
<p dir="auto">这种系统在像 Binance 或 Coinbase 这样的中心化交易所上运行良好。</p>
<p dir="auto">但有一个问题……</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🤕 为什么链上不能这样做</h2></div>
<p dir="auto">在区块链上，一切都要消耗 <strong>gas</strong>。</p>
<p dir="auto">即便是像“我想买 DAI”这样简单的操作，也意味着：</p>
<ul dir="auto">
<li>发送交易</li>
<li>支付手续费</li>
<li>等待确认</li>
</ul>
<p dir="auto">想象一下，对于买入或卖出价格的<strong>每一个微小动作变化</strong> ，都必须遵循这样的流程。那将是噩梦。</p>
<p dir="auto">而且如果那时没有人愿意和你交易呢？</p>
<p dir="auto">你就被卡住了。你的订单就那样挂着，浪费 gas 和时间。</p>
<p dir="auto">所以核心问题是：</p>
<ul dir="auto">
<li>订单簿是<strong>中心化的</strong></li>
<li>它们需要人一直活跃</li>
<li>链上使用既慢又贵</li>
</ul>
<p dir="auto">DeFi 需要一些<strong>更好的方式</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">💡 突破口：如果不需要买家和卖家会怎样？</h2></div>
<p dir="auto">这是改变一切的绝妙想法：</p>
<blockquote>
<p dir="auto">如果人们不需要等待交易伙伴呢？</p>
</blockquote>
<blockquote>
<p dir="auto">如果智能合约可以像自动售货机一样提供代币呢？</p>
</blockquote>
<p dir="auto">所以，不再依赖别人来交易……</p>
<p dir="auto">你将拥有一个包含两种代币的池子 —— 比如 DAI 和 ETH ——</p>
<p dir="auto">该池子锁在任何人都可以使用的合约中。</p>
<p dir="auto">想<strong>用 DAI 买 ETH</strong>？</p>
<p dir="auto">合约做数学运算，给你 ETH，同时收下你的 DAI。</p>
<p dir="auto">想<strong>出售ETH 换取 DAI</strong>？</p>
<p dir="auto">同样 —— 合约给你 DAI，同时留存你的 ETH。</p>
<p dir="auto">不需要买家，不需要卖家。只需要数学。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">📐 那它实际上是如何运作的？</h2></div>
<p dir="auto">AMM 使用一个简单公式：</p>
<blockquote>
<p dir="auto">x × y = k</p>
</blockquote>
<p dir="auto">让我们拆解一下。</p>
<ul dir="auto">
<li><code>x</code> = 池中代币 A 的数量</li>
<li><code>y</code> = 池中代币 B 的数量</li>
<li><code>k</code> = 某个常数（永远不变）</li>
</ul>
<p dir="auto">所以 <strong>两个代币储备的乘积必须始终保持不变</strong>。</p>
<p dir="auto">这里的魔力是：</p>
<p dir="auto">如果有人想添加更多的代币 A（比如 ETH），</p>
<p dir="auto">保持 <code>k</code> 不变的唯一方法是让合约给Ta们更少的代币 B（比如 DAI）。</p>
<p dir="auto">这就是价格<strong>自动</strong>调整的方式。</p>
<p dir="auto">随着交易的增多，比例会发生变化 —— 价格也随之自动更新。</p>
<p dir="auto">这就是为什么它叫<strong>自动化做市商</strong>。</p>
<p dir="auto">合约使用数学来创造市场，而不是依赖人工订单。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔁 那么 AMM 可以做什么？</h2></div>
<p dir="auto">主要有三件大事可以做：</p>
<ol dir="auto">
<li><strong>兑换</strong>代币
<ul dir="auto">
<li>即时将代币 A 换成代币 B（或反过来）</li>
<li>不用等待匹配</li>
<li>只需发送代币，即可得到另一种代币</li>
</ul>
</li>
<li><strong>添加流动性</strong>
<ul dir="auto">
<li>存入等值的代币 A 和 B</li>
<li>获得 <strong>LP 代币</strong>（类似收据）</li>
<li>当你的代币在池中时，你会获得交易费用分成</li>
</ul>
</li>
<li><strong>移除流动性</strong>
<ul dir="auto">
<li>归还 LP 代币</li>
<li>取回你对应份额的两种代币</li>
</ul>
</li>
</ol>
<hr>
<p dir="auto">现在你已经理解了概念……</p>
<p dir="auto">下一部分，我们将查看一个真实的 Solidity 合约 —— 并演示如何<strong>从零开始编码自己的 AMM</strong>。</p>
<p dir="auto">我们将展示：</p>
<ul dir="auto">
<li>流动性池是如何工作的</li>
<li>价格计算是如何完成的</li>
<li>如何确保一切公平平衡</li>
</ul>
<p dir="auto">准备好构建 DeFi 的核心引擎了吗？</p>
<p dir="auto">让我们进入代码部分。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🛠️ 今天你要构建的内容</h2></div>
<p dir="auto">今天的项目不仅仅是一个玩具合约。</p>
<p dir="auto">你要构建的是驱动数十亿美元去中心化交易的<strong>核心引擎</strong>。</p>
<p dir="auto">但有个特点：</p>
<ul dir="auto">
<li><strong>不用库（libraries）</strong></li>
<li><strong>不用捷径</strong></li>
<li><strong>没有幕后魔法</strong></li>
</ul>
<p dir="auto">你将<strong>纯手写</strong>自动化做市商的核心 —— 这是真正理解它的<strong>最佳方式</strong>。</p>
<p dir="auto">让我们准确分解一下你的智能合约将做什么，以及分析每部分的重要性：</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔁 创建两个 ERC-20 代币之间的流动性池</h3></div>
<p dir="auto">你将从锁定两个 ERC-20 代币开始 —— 我们称它们为 <strong>代币 A</strong> 和 <strong>代币 B</strong> —— 放入智能合约中。</p>
<p dir="auto">这些代币形成<strong>流动性池</strong>。</p>
<p dir="auto">人们将通过这个池子进行<strong>代币兑换</strong>或<strong>提供流动性</strong>。它就像存放所有交易资产的金库。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">➕ 允许用户添加和移除流动性</h3></div>
<p dir="auto">任何人都可以向池子存入等值的代币 A 和 B。</p>
<p dir="auto">为什么需要等值？</p>
<p dir="auto">因为它保持<strong>价格比例</strong>平衡。</p>
<p dir="auto">当有人添加流动性时：</p>
<ul dir="auto">
<li>你将Ta们的代币存入合约</li>
<li>然后你给Ta们签发 <strong>LP 代币</strong>（liquidity provider tokens 的缩写）—— 就像数字收据</li>
</ul>
<p dir="auto">稍后，当Ta们移除流动性时，归还 LP 代币 —— 你返还Ta们对应份额的两种代币。</p>
<p dir="auto">这样，每个人都有拥有池子份额的<strong>所有权证明（proof of ownership）</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 跟踪并更新内部储备</h3></div>
<p dir="auto">合约会始终跟踪记录两个数值：</p>
<ul dir="auto">
<li><code>reserveA</code>：池中代币 A 的数量</li>
<li><code>reserveB</code>：池中代币 B 的数量</li>
</ul>
<p dir="auto">每次有人添加、移除代币，或者进行兑换时，这些储备都会更新。</p>
<p dir="auto">这些数值非常<strong>关键</strong>，因为它们用于：</p>
<ul dir="auto">
<li>计算公平价格</li>
<li>执行恒定乘积公式（稍后详细说明）</li>
<li>防止滥用或操纵</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔁 允许任何人以代币 A 兑换代币 B（反之亦然）</h3></div>
<p dir="auto">这是 AMM 的核心功能。</p>
<p dir="auto">比如 Alice 想用她的代币 A 兑换代币 B。</p>
<p dir="auto">你的合约会：</p>
<ul dir="auto">
<li>接收她的代币 A</li>
<li>根据当前池比例计算给她多少代币 B</li>
<li>更新储备</li>
<li>转账代币</li>
</ul>
<p dir="auto">这一切都发生在<strong>无需交易对手</strong>的情况下 —— 不需要卖家。</p>
<p dir="auto">同样逻辑适用于反向兑换 —— 代币 B 换代币 A。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📐 使用恒定乘积公式</h3></div>
<p dir="auto">魔法发生时刻。</p>
<p dir="auto">你的合约将使用以下公式来确定兑换率：</p>
<blockquote>
<p dir="auto">x * y = k</p>
</blockquote>
<p dir="auto">其中：</p>
<ul dir="auto">
<li><code>x</code> = 代币 A 的储备</li>
<li><code>y</code> = 代币 B 的储备</li>
<li><code>k</code> = 永远不变的常数</li>
</ul>
<p dir="auto">当有人向池中添加代币 A 时，保持 <code>k</code> 不变的唯一方法是<strong>减少一些代币 B</strong> —— 反之亦然。</p>
<p dir="auto">这就是价格发现的方式。自动、公平，并且基于数学。</p>
<p dir="auto">为防止滥用，你还会对每笔交易收取小额手续费（例如 0.3%） —— 就像 Uniswap一样 —— 然后支付给流动性提供者。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🎟️ 发放自定义 LP 代币</h3></div>
<p dir="auto">还记得之前人们添加流动性得到的“收据”吗？</p>
<p dir="auto">这些 LP 代币代表Ta们在池中的<strong>所有权份额</strong>。</p>
<p dir="auto">如果池子因交易费用增长，LP 会受益 —— 因为Ta们可以提取的资产比投入的<strong>更多</strong>。</p>
<p dir="auto">你将扩展 ERC-20 合约来自己发行和管理这些 LP 代币。</p>
<hr>
<p dir="auto">这个合约表面看起来可能很简单 —— 只是几个函数、几个数学公式……</p>
<p dir="auto">但合约背后呢？</p>
<p dir="auto">你正在重新创建<strong>去中心化交易所</strong>的基本构建模块 —— 运行在以太坊上，无需任何人、经纪人或中间人。</p>
<p dir="auto">最棒的部分是，</p>
<p dir="auto">你将逐行编写 —— 完全透明、完全去中心化，并且完全在你掌控之下。</p>
<p dir="auto">让我们开始构建。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">合约拆解</h2></div>
<p dir="auto">现在你已经理解了<strong>什么是自动化做市商</strong>以及<strong>它为什么重要</strong>，是时候该深入了解。</p>
<p dir="auto">接下来你将看到的是一个<strong>可运行 AMM 的完整代码</strong> —— 如果一开始看上去有些吓人也不用担心。我们会<strong>逐步拆解</strong>，并用通俗语言解释每一部分。</p>
<p dir="auto">从开头的导入……</p>
<p dir="auto">到如何添加和移除流动性……</p>
<p dir="auto">再到代币兑换背后的精确数学……</p>
<p dir="auto">在本次拆解结束时，你将明白：</p>
<ul dir="auto">
<li>ERC-20 代币如何集成到智能合约中</li>
<li>储备余额如何被跟踪和更新</li>
<li><code>x * y = k</code> 公式在代码中究竟是什么样子</li>
<li>以及自定义 LP 代币如何被铸造和销毁</li>
</ul>
<p dir="auto">所以先深呼吸，慢慢往下滚动 —— 让我们逐行解码。</p>
<p dir="auto">这是一切开始变得清晰的地方。</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">// SPDX-License-Identifier: MIT</span>
<span class="pl-k">pragma solidity</span> <span class="pl-k">^</span><span class="pl-c1">0.8.20</span>;

<span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/token/ERC20/ERC20.sol</span>"</span>;

<span class="pl-c">/// @title Automated Market Maker with Liquidity Token</span>
<span class="pl-k">contract</span> <span class="pl-en">AutomatedMarketMaker</span> <span class="pl-k">is</span> <span class="pl-en">ERC20</span> {
    <span class="pl-c1">IERC20</span> <span class="pl-k">public</span> tokenA;
    <span class="pl-c1">IERC20</span> <span class="pl-k">public</span> tokenB;

    <span class="pl-c1">uint256</span> <span class="pl-k">public</span> reserveA;
    <span class="pl-c1">uint256</span> <span class="pl-k">public</span> reserveB;

    <span class="pl-c1">address</span> <span class="pl-k">public</span> owner;

    <span class="pl-k">event <span class="pl-en">LiquidityAdded</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">provider</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountA</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountB</span>, <span class="pl-c1">uint256</span> <span class="pl-v">liquidity</span>);
    <span class="pl-k">event <span class="pl-en">LiquidityRemoved</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">provider</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountA</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountB</span>, <span class="pl-c1">uint256</span> <span class="pl-v">liquidity</span>);
    <span class="pl-k">event <span class="pl-en">TokensSwapped</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">trader</span>, <span class="pl-c1">address</span> <span class="pl-v">tokenIn</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountIn</span>, <span class="pl-c1">address</span> <span class="pl-v">tokenOut</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountOut</span>);

    <span class="pl-k">constructor</span>(<span class="pl-c1">address</span> <span class="pl-v">_tokenA</span>, <span class="pl-c1">address</span> <span class="pl-v">_tokenB</span>, <span class="pl-c1">string</span> <span class="pl-k">memory</span> <span class="pl-v">_name</span>, <span class="pl-c1">string</span> <span class="pl-k">memory</span> <span class="pl-v">_symbol</span>) <span class="pl-c1">ERC20</span>(_name, _symbol) {
        tokenA <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_tokenA);
        tokenB <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_tokenB);
        owner <span class="pl-k">=</span> <span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>;
    }

    <span class="pl-c">/// @notice Add liquidity to the pool</span>
    <span class="pl-k">function<span class="pl-en"> addLiquidity</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amountA</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountB</span>) <span class="pl-k">external</span> {
        <span class="pl-k">require</span>(amountA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> amountB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amounts must be &gt; 0</span>"</span>);

        tokenA.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountA);
        tokenB.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountB);

        <span class="pl-c1">uint256</span> liquidity;
        <span class="pl-k">if</span> (<span class="pl-en">totalSupply</span>() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            liquidity <span class="pl-k">=</span> <span class="pl-en">sqrt</span>(amountA <span class="pl-k">*</span> amountB);
        } <span class="pl-k">else</span> {
            liquidity <span class="pl-k">=</span> <span class="pl-en">min</span>(
                amountA <span class="pl-k">*</span> <span class="pl-en">totalSupply</span>() <span class="pl-k">/</span> reserveA,
                amountB <span class="pl-k">*</span> <span class="pl-en">totalSupply</span>() <span class="pl-k">/</span> reserveB
            );
        }

        <span class="pl-en">_mint</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, liquidity);

        reserveA <span class="pl-k">+=</span> amountA;
        reserveB <span class="pl-k">+=</span> amountB;

        <span class="pl-k">emit</span> <span class="pl-en">LiquidityAdded</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountA, amountB, liquidity);
    }

    <span class="pl-c">/// @notice Remove liquidity from the pool</span>
    <span class="pl-k">function<span class="pl-en"> removeLiquidity</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">liquidityToRemove</span>) <span class="pl-k">external</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span> <span class="pl-v">amountAOut</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountBOut</span>) {
        <span class="pl-k">require</span>(liquidityToRemove <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Liquidity to remove must be &gt; 0</span>"</span>);
        <span class="pl-k">require</span>(<span class="pl-en">balanceOf</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>) <span class="pl-k">&gt;=</span> liquidityToRemove, <span class="pl-s">"<span class="pl-s">Insufficient liquidity tokens</span>"</span>);

        <span class="pl-c1">uint256</span> totalLiquidity <span class="pl-k">=</span> <span class="pl-en">totalSupply</span>();
        <span class="pl-k">require</span>(totalLiquidity <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">No liquidity in the pool</span>"</span>);

        amountAOut <span class="pl-k">=</span> liquidityToRemove <span class="pl-k">*</span> reserveA <span class="pl-k">/</span> totalLiquidity;
        amountBOut <span class="pl-k">=</span> liquidityToRemove <span class="pl-k">*</span> reserveB <span class="pl-k">/</span> totalLiquidity;

        <span class="pl-k">require</span>(amountAOut <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> amountBOut <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves for requested liquidity</span>"</span>);

        reserveA <span class="pl-k">-=</span> amountAOut;
        reserveB <span class="pl-k">-=</span> amountBOut;

        <span class="pl-en">_burn</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, liquidityToRemove);

        tokenA.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut);
        tokenB.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountBOut);

        <span class="pl-k">emit</span> <span class="pl-en">LiquidityRemoved</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut, amountBOut, liquidityToRemove);
        <span class="pl-k">return</span> (amountAOut, amountBOut);
    }

    <span class="pl-c">/// @notice Swap token A for token B</span>
    <span class="pl-k">function<span class="pl-en"> swapAforB</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amountAIn</span>, <span class="pl-c1">uint256</span> <span class="pl-v">minBOut</span>) <span class="pl-k">external</span> {
        <span class="pl-k">require</span>(amountAIn <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amount must be &gt; 0</span>"</span>);
        <span class="pl-k">require</span>(reserveA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> reserveB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves</span>"</span>);

        <span class="pl-c1">uint256</span> amountAInWithFee <span class="pl-k">=</span> amountAIn <span class="pl-k">*</span> <span class="pl-c1">997</span> <span class="pl-k">/</span> <span class="pl-c1">1000</span>;
        <span class="pl-c1">uint256</span> amountBOut <span class="pl-k">=</span> reserveB <span class="pl-k">*</span> amountAInWithFee <span class="pl-k">/</span> (reserveA <span class="pl-k">+</span> amountAInWithFee);

        <span class="pl-k">require</span>(amountBOut <span class="pl-k">&gt;=</span> minBOut, <span class="pl-s">"<span class="pl-s">Slippage too high</span>"</span>);

        tokenA.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountAIn);
        tokenB.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountBOut);

        reserveA <span class="pl-k">+=</span> amountAInWithFee;
        reserveB <span class="pl-k">-=</span> amountBOut;

        <span class="pl-k">emit</span> <span class="pl-en">TokensSwapped</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(tokenA), amountAIn, <span class="pl-c1">address</span>(tokenB), amountBOut);
    }

    <span class="pl-c">/// @notice Swap token B for token A</span>
    <span class="pl-k">function<span class="pl-en"> swapBforA</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amountBIn</span>, <span class="pl-c1">uint256</span> <span class="pl-v">minAOut</span>) <span class="pl-k">external</span> {
        <span class="pl-k">require</span>(amountBIn <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amount must be &gt; 0</span>"</span>);
        <span class="pl-k">require</span>(reserveA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> reserveB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves</span>"</span>);

        <span class="pl-c1">uint256</span> amountBInWithFee <span class="pl-k">=</span> amountBIn <span class="pl-k">*</span> <span class="pl-c1">997</span> <span class="pl-k">/</span> <span class="pl-c1">1000</span>;
        <span class="pl-c1">uint256</span> amountAOut <span class="pl-k">=</span> reserveA <span class="pl-k">*</span> amountBInWithFee <span class="pl-k">/</span> (reserveB <span class="pl-k">+</span> amountBInWithFee);

        <span class="pl-k">require</span>(amountAOut <span class="pl-k">&gt;=</span> minAOut, <span class="pl-s">"<span class="pl-s">Slippage too high</span>"</span>);

        tokenB.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountBIn);
        tokenA.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut);

        reserveB <span class="pl-k">+=</span> amountBInWithFee;
        reserveA <span class="pl-k">-=</span> amountAOut;

        <span class="pl-k">emit</span> <span class="pl-en">TokensSwapped</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(tokenB), amountBIn, <span class="pl-c1">address</span>(tokenA), amountAOut);
    }

    <span class="pl-c">/// @notice View the current reserves</span>
    <span class="pl-k">function<span class="pl-en"> getReserves</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span>, <span class="pl-c1">uint256</span>) {
        <span class="pl-k">return</span> (reserveA, reserveB);
    }

    <span class="pl-c">/// @dev Utility: Return the smaller of two values</span>
    <span class="pl-k">function<span class="pl-en"> min</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">a</span>, <span class="pl-c1">uint256</span> <span class="pl-v">b</span>) <span class="pl-k">internal</span> <span class="pl-k">pure</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span>) {
        <span class="pl-k">return</span> a <span class="pl-k">&lt;</span> b <span class="pl-k">?</span> a<span class="pl-k"> : </span>b;
    }

    <span class="pl-c">/// @dev Utility: Babylonian square root</span>
    <span class="pl-k">function<span class="pl-en"> sqrt</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">y</span>) <span class="pl-k">internal</span> <span class="pl-k">pure</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span> <span class="pl-v">z</span>) {
        <span class="pl-k">if</span> (y <span class="pl-k">&gt;</span> <span class="pl-c1">3</span>) {
            z <span class="pl-k">=</span> y;
            <span class="pl-c1">uint256</span> x <span class="pl-k">=</span> y <span class="pl-k">/</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            <span class="pl-k">while</span> (x <span class="pl-k">&lt;</span> z) {
                z <span class="pl-k">=</span> x;
                x <span class="pl-k">=</span> (y <span class="pl-k">/</span> x <span class="pl-k">+</span> x) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            }
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (y <span class="pl-k">!=</span> <span class="pl-c1">0</span>) {
            z <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }
    }
}
</pre></div>
<p dir="auto">让我们以最适合初学者的方式开始拆解这个合约。</p>
<hr>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧱 1. 导入 ERC20 标准</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/token/ERC20/ERC20.sol</span>"</span>;
</pre></div>
<p dir="auto">先从这一行开始 —— 很简单，但功能非常强大。</p>
<p dir="auto">这里，我们从 <strong>OpenZeppelin</strong> 导入了 ERC20 合约。</p>
<blockquote>
<p dir="auto">🧰 什么是 OpenZeppelin？</p>
<p dir="auto">它是一个经过实战验证、安全可靠的智能合约库，在以太坊生态系统中被广泛使用。可以把它想象成你可以信赖的乐高积木 —— 不用从零构建每一块砖。</p>
</blockquote>
<blockquote>
<p dir="auto">📦 什么是 ERC20？</p>
<p dir="auto">ERC-20 是以太坊上创建代币的标准。大多数你听说过的代币 —— 比如 DAI、USDC 或 UNI —— 都遵循这个标准。它定义了代币的行为方式，包括：</p>
</blockquote>
<ul dir="auto">
<li>如何发送和接收代币（<code>transfer</code>）</li>
<li>如何授权Ta人使用代币（<code>approve</code> + <code>transferFrom</code>）</li>
<li>如何查询余额（<code>balanceOf</code>）</li>
<li>甚至如何创建或销毁代币（<code>mint</code> 和 <code>burn</code>）（如果允许的话）</li>
</ul>
<p dir="auto">通过导入 <code>ERC20.sol</code>，我们可以立即访问使用<strong>所有这些功能</strong>，无需自己重新编写。</p>
<blockquote>
<p dir="auto">✨ 为什么我们在这里需要它？</p>
<p dir="auto">因为我们的 AMM 合约也会发行自己的代币 —— 当用户提供流动性时获得的 LP 代币。这些 LP 代币就是标准的 ERC-20 代币 —— 通过继承 ERC20 合约，我们可以像操作任何其它代币一样铸造它们。</p>
</blockquote>
<p dir="auto">这个导入为 LP 代币功能搭建了整个骨架。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧾 2. 合约声明</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">contract</span> <span class="pl-en">AutomatedMarketMaker</span> <span class="pl-k">is</span> <span class="pl-en">ERC20</span> {
</pre></div>
<p dir="auto">这一行开始了我们的主要智能合约。</p>
<p dir="auto">我们来拆解一下：</p>
<ul dir="auto">
<li>
<p dir="auto"><code>contract AutomatedMarketMaker</code>：</p>
<p dir="auto">定义了一个名为 <code>AutomatedMarketMaker</code> 的新合约。这将是我们的 AMM 的<strong>大脑</strong>，负责持有代币、计算兑换、跟踪流动性。</p>
</li>
<li>
<p dir="auto"><code>is ERC20</code>：</p>
<p dir="auto">这意味着我们的合约<strong>继承自我们刚导入的 ERC20 合约</strong>。</p>
</li>
</ul>
<p dir="auto">把继承想象成在说：</p>
<blockquote>
<p dir="auto">“我的合约应该像 ERC20 代币一样运作 —— 在此基础上，我还会添加一些 AMM 专属逻辑。”</p>
</blockquote>
<p dir="auto">因为有了继承，我们无需手动编码 ERC-20 的行为 —— 它已经内置好了。需要发行或销毁 LP 代币时，我们只需调用 <code>_mint()</code> 和 <code>_burn()</code>。</p>
<blockquote>
<p dir="auto">🎟️ 为什么 AMM 需要自己的代币？</p>
<p dir="auto">每当有人提供流动性时，我们会给Ta们一个代币，代表Ta们在<strong>流动性池中的份额证明</strong>。这就是 LP 代币。它像任何其它 ERC-20 代币一样 —— 可以转移、跟踪，并且可以在之后赎回池中对应份额。</p>
</blockquote>
<p dir="auto">所以这一行不仅仅是声明 —— 它是让我们的 AMM 同时扮演代币发行者和去中心化交易所的开始。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧮 3. 状态变量</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">IERC20</span> <span class="pl-k">public</span> tokenA;
<span class="pl-c1">IERC20</span> <span class="pl-k">public</span> tokenB;

<span class="pl-c1">uint256</span> <span class="pl-k">public</span> reserveA;
<span class="pl-c1">uint256</span> <span class="pl-k">public</span> reserveB;

<span class="pl-c1">address</span> <span class="pl-k">public</span> owner;
</pre></div>
<p dir="auto">这些是<strong>核心变量</strong>，存储 AMM 的重要状态。</p>
<p dir="auto">可以把它们想象成合约的内部记忆 —— 记录合约处理的代币、每种代币的数量，以及谁部署了合约。</p>
<p dir="auto">我们逐一解析：</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🪙 <code>tokenA</code> 和 <code>tokenB</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">IERC20</span> <span class="pl-k">public</span> tokenA;
<span class="pl-c1">IERC20</span> <span class="pl-k">public</span> tokenB;
</pre></div>
<ul dir="auto">
<li>
<p dir="auto">这两个变量存储 AMM 将管理的 ERC-20 代币的<strong>地址</strong>。</p>
</li>
<li>
<p dir="auto">它们的类型是 <code>IERC20</code>，只是一个接口 —— 用来表示：</p>
<blockquote>
<p dir="auto">“这东西表现得像 ERC-20 代币，所以我知道它有 transfer、transferFrom、approve 等函数。”</p>
</blockquote>
</li>
</ul>
<p dir="auto">如果这个 AMM 用于交易 <strong>DAI 和 USDC</strong>，那么 <code>tokenA</code> 可能是 DAI，<code>tokenB</code> 是 USDC。</p>
<blockquote>
<p dir="auto">✅ 为什么是 public？</p>
<p dir="auto">因为我们希望这些变量可以<strong>被外部查看</strong> —— 例如前端、区块链浏览器或其他合约。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧾 <code>reserveA</code> 和 <code>reserveB</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> <span class="pl-k">public</span> reserveA;
<span class="pl-c1">uint256</span> <span class="pl-k">public</span> reserveB;
</pre></div>
<p dir="auto">这两个数值跟踪当前锁定在 AMM 合约中的每种代币数量。</p>
<p dir="auto">为什么需要这个数值？</p>
<p dir="auto">因为<strong>整个 AMM 逻辑 —— 兑换、价格、LP 份额 —— 都依赖于知道池中每种代币的数量</strong>。</p>
<p dir="auto">当有人兑换代币时：</p>
<ul dir="auto">
<li>我们更新这些储备</li>
<li>并使用这些数值在公式 <code>x * y = k</code> 中计算兑换量</li>
</ul>
<blockquote>
<p dir="auto">🎯 重要提示：这些数值不会自动根据代币余额自动更新 —— 而是每次我们进行操作（如兑换或去除流动性）时，需要手动更新。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧑‍💼 <code>owner</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">address</span> <span class="pl-k">public</span> owner;
</pre></div>
<p dir="auto">存储<strong>部署</strong>合约的地址。</p>
<p dir="auto">目前，我们还没有使用它来做任何仅限管理员的操作……但这是一个好的模式，如果未来我们想要做以下操作可以考虑该模式：</p>
<ul dir="auto">
<li>添加治理</li>
<li>在紧急情况下让拥有者暂停交易</li>
<li>或者之后引入费用转换</li>
</ul>
<blockquote>
<p dir="auto">🔐 现在的案例只是简单追踪谁控制合约 —— 或者只是标记谁最初部署了合约。</p>
</blockquote>
<hr>
<p dir="auto">这些变量一起定义了 AMM 的 <strong>核心身份和状态</strong>：</p>
<ul dir="auto">
<li>支持哪些代币</li>
<li>拥有多少流动性</li>
<li>谁拥有或管理它</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔔 4. Event（事件）</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">LiquidityAdded</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">provider</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountA</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountB</span>, <span class="pl-c1">uint256</span> <span class="pl-v">liquidity</span>);
<span class="pl-k">event <span class="pl-en">LiquidityRemoved</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">provider</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountA</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountB</span>, <span class="pl-c1">uint256</span> <span class="pl-v">liquidity</span>);
<span class="pl-k">event <span class="pl-en">TokensSwapped</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">trader</span>, <span class="pl-c1">address</span> <span class="pl-v">tokenIn</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountIn</span>, <span class="pl-c1">address</span> <span class="pl-v">tokenOut</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountOut</span>);
</pre></div>
<p dir="auto">这些是 <strong>event（事件）</strong>，虽然它们不会影响合约的底层运作，但在应用与用户交互中起到<strong>重要作用</strong>。</p>
<p dir="auto">把事件想象成<strong>链上通知</strong>或<strong>区块链的控制台日志</strong>。</p>
<p dir="auto">每当发生关键操作 —— 添加流动性、移除流动性或兑换代币 —— 我们就会触发一个事件。</p>
<p dir="auto">让我们逐一解析：</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💧 <code>LiquidityAdded</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">LiquidityAdded</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">provider</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountA</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountB</span>, <span class="pl-c1">uint256</span> <span class="pl-v">liquidity</span>);
</pre></div>
<ul dir="auto">
<li>该事件在有人<strong>添加代币</strong>到池子时触发。</li>
<li>记录：
<ul dir="auto">
<li>谁添加了流动性 (<code>provider</code>)</li>
<li>添加了多少 tokenA 和 tokenB</li>
<li>获得了多少 <strong>LP 代币</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p dir="auto">🧠 为什么记录事件有用？</p>
<p dir="auto">因为dapps可以<strong>监听这个事件</strong> 并在 UI 显示。例如，一个网站可能显示：</p>
<p dir="auto">“你向池中添加了 100 DAI 和 100 USDC，获得了 99 个 LP 代币。”</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 <code>LiquidityRemoved</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">LiquidityRemoved</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">provider</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountA</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountB</span>, <span class="pl-c1">uint256</span> <span class="pl-v">liquidity</span>);
</pre></div>
<ul dir="auto">
<li>该事件在有人 <strong>移除池中流动性</strong> 时记录。</li>
<li>显示：
<ul dir="auto">
<li>谁进行了操作</li>
<li>取回了每种代币的多少</li>
<li>销毁了多少 LP 代币</li>
</ul>
</li>
</ul>
<blockquote>
<p dir="auto">🔍 前端可以用该事件来更新你的池子持仓或历史记录。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔄 <code>TokensSwapped</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">event <span class="pl-en">TokensSwapped</span></span>(<span class="pl-c1">address</span> <span class="pl-k">indexed</span> <span class="pl-v">trader</span>, <span class="pl-c1">address</span> <span class="pl-v">tokenIn</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountIn</span>, <span class="pl-c1">address</span> <span class="pl-v">tokenOut</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountOut</span>);
</pre></div>
<ul dir="auto">
<li>当有人<strong>兑换</strong> 一种代币换另一种代币时触发该事件。</li>
<li>告诉我们：
<ul dir="auto">
<li>谁进行了兑换 (<code>trader</code>)</li>
<li>兑换进来的代币种类 (<code>tokenIn</code>)</li>
<li>给进的代币数量</li>
<li>兑换出去的代币种类 (<code>tokenOut</code>)</li>
<li>支出的代币数量</li>
</ul>
</li>
</ul>
<blockquote>
<p dir="auto">🖥️ 有了这个，dapps 可以立即显示兑换确认，例如：</p>
<p dir="auto">“你用 10 DAI 换了 9.87 USDC。”</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🚀 5. 构造函数 – 初始化设置</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">constructor</span>(<span class="pl-c1">address</span> <span class="pl-v">_tokenA</span>, <span class="pl-c1">address</span> <span class="pl-v">_tokenB</span>, <span class="pl-c1">string</span> <span class="pl-k">memory</span> <span class="pl-v">_name</span>, <span class="pl-c1">string</span> <span class="pl-k">memory</span> <span class="pl-v">_symbol</span>) <span class="pl-c1">ERC20</span>(_name, _symbol) {
  tokenA <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_tokenA);
  tokenB <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_tokenB);
  owner <span class="pl-k">=</span> <span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>;
}
</pre></div>
<p dir="auto">这个函数可能看起来很小，但<strong>至关重要</strong>。</p>
<p dir="auto">这是<strong>构造函数</strong>，在合约部署到区块链时<strong>只会运行一次</strong>。</p>
<p dir="auto">我们逐步解析。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔧 构造函数的作用</h3></div>
<p dir="auto">就像在机器首次使用前进行初始配置。你定义：</p>
<ul dir="auto">
<li>AMM 支持哪些代币</li>
<li>LP 代币的名称</li>
<li>谁部署了合约（以后可能控制升级或特殊操作）</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📬 参数</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">constructor</span>(<span class="pl-c1">address</span> <span class="pl-v">_tokenA</span>, <span class="pl-c1">address</span> <span class="pl-v">_tokenB</span>, <span class="pl-c1">string</span> <span class="pl-k">memory</span> <span class="pl-v">_name</span>, <span class="pl-c1">string</span> <span class="pl-k">memory</span> <span class="pl-v">_symbol</span>)
</pre></div>
<p dir="auto">构造函数接受 <strong>四个输入</strong>：</p>
<ol dir="auto">
<li><code>_tokenA</code>：第一种 ERC-20 代币的地址（例如 DAI）</li>
<li><code>_tokenB</code>：第二种 ERC-20 代币的地址（例如 USDC）</li>
<li><code>_name</code>：LP 代币名称（例如 “DAI-USDC LP Token”）</li>
<li><code>_symbol</code>：LP 代币符号（例如 “DAIUSDC-LP”）</li>
</ol>
<blockquote>
<p dir="auto">📝 string memory 类型只是在 Solidity中 表示着：</p>
<p dir="auto">“我们临时传递这个字符串 —— 不是存储在固定长度的位置。”</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🎟️ <code>ERC20(_name, _symbol)</code></h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">ERC20</span>(_name, _symbol)
</pre></div>
<p dir="auto">这部分虽然隐蔽，但很重要。</p>
<p dir="auto">因为我们的 AMM 合约继承自 <code>ERC20</code>，这里调用它的构造函数设置 <strong>LP 代币的名称和符号</strong>。</p>
<p dir="auto">所以有人添加流动性后，可能会得到这个代币，名为：</p>
<blockquote>
<p dir="auto">“DAI-USDC LP Token (DAIUSDC-LP)”</p>
</blockquote>
<p dir="auto">就像 USDC 有自己的名称和符号一样 —— 你的 LP 代币也会有。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🪙 代币设置</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>tokenA <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_tokenA);
tokenB <span class="pl-k">=</span> <span class="pl-c1">IERC20</span>(_tokenB);
</pre></div>
<p dir="auto">这一部分把实际代币合约赋值给状态变量。</p>
<p dir="auto">我们将传入的两个地址 (<code>_tokenA</code> 和 <code>_tokenB</code>) 并将其视作 ERC-20 代币，通过 <code>IERC20</code> 接口使用。这让我们可以访问：</p>
<ul dir="auto">
<li><code>transfer()</code></li>
<li><code>transferFrom()</code></li>
<li><code>balanceOf()</code></li>
<li>以及其它与代币相关的函数</li>
</ul>
<p dir="auto">这样 AMM 就知道<strong>它正在处理哪些代币</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">👑 所有权</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>owner <span class="pl-k">=</span> <span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>;
</pre></div>
<p dir="auto">这一行把 <code>owner</code> 变量设置为部署合约的人。</p>
<p dir="auto"><code>msg.sender</code> 是 Solidity 中的全局变量 —— 总是指当前调用函数的地址。</p>
<p dir="auto">在构造函数中，它就是合约部署者的地址。</p>
<p dir="auto">我们目前还没有用 <code>owner</code> 做任何管理员相关操作，但记录部署者是一个好习惯 —— 以防以后想引入治理或费用分配机制。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">6.🧰 辅助函数 – 小工具，大用途</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> min</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">a</span>, <span class="pl-c1">uint256</span> <span class="pl-v">b</span>) <span class="pl-k">internal</span> <span class="pl-k">pure</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span>) {
    <span class="pl-k">return</span> a <span class="pl-k">&lt;</span> b <span class="pl-k">?</span> a<span class="pl-k"> : </span>b;
}

<span class="pl-k">function<span class="pl-en"> sqrt</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">y</span>) <span class="pl-k">internal</span> <span class="pl-k">pure</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span> <span class="pl-v">z</span>) {
    <span class="pl-k">if</span> (y <span class="pl-k">&gt;</span> <span class="pl-c1">3</span>) {
        z <span class="pl-k">=</span> y;
        <span class="pl-c1">uint256</span> x <span class="pl-k">=</span> y <span class="pl-k">/</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (x <span class="pl-k">&lt;</span> z) {
            z <span class="pl-k">=</span> x;
            x <span class="pl-k">=</span> (y <span class="pl-k">/</span> x <span class="pl-k">+</span> x) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
        }
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (y <span class="pl-k">!=</span> <span class="pl-c1">0</span>) {
        z <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    }
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔽 min(): 返回较小的数</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> min</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">a</span>, <span class="pl-c1">uint256</span> <span class="pl-v">b</span>) <span class="pl-k">internal</span> <span class="pl-k">pure</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span>) {
    <span class="pl-k">return</span> a <span class="pl-k">&lt;</span> b <span class="pl-k">?</span> a<span class="pl-k"> : </span>b;
}
</pre></div>
<p dir="auto">这个函数用来选择两个数字中较小的一个。</p>
<p dir="auto">我们为什么需要这个函数？</p>
<p dir="auto">👉 在 <code>addLiquidity()</code> 中，当有人向已有流动性池添加代币时，我们希望根据<strong>哪个代币贡献较少</strong>来铸造 LP 代币 —— 这样可以保持比例稳定，防止铸造过多。</p>
<p dir="auto">举例：如果用户发送 100 个 A 和 150 个 B，我们只会用 100 个 A 和 100 个 B 来铸造 LP 代币 —— 多余的 50 个 B 会返还给池子。</p>
<p dir="auto">这个 <code>min()</code> 函数确保了池子的<strong>平衡</strong>与<strong>公平</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 sqrt(): 巴比伦平方根算法</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> sqrt</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">y</span>) <span class="pl-k">internal</span> <span class="pl-k">pure</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span> <span class="pl-v">z</span>) {
    <span class="pl-k">if</span> (y <span class="pl-k">&gt;</span> <span class="pl-c1">3</span>) {
        z <span class="pl-k">=</span> y;
        <span class="pl-c1">uint256</span> x <span class="pl-k">=</span> y <span class="pl-k">/</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (x <span class="pl-k">&lt;</span> z) {
            z <span class="pl-k">=</span> x;
            x <span class="pl-k">=</span> (y <span class="pl-k">/</span> x <span class="pl-k">+</span> x) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
        }
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (y <span class="pl-k">!=</span> <span class="pl-c1">0</span>) {
        z <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    }
}
</pre></div>
<p dir="auto">这是一种经典的<strong>巴比伦算法</strong> ，用于在 Solidity 中计算数字的平方根——因为 Solidity 不像其它一些编程语言那样内置 sqrt（） 函数。</p>
<p dir="auto">它只用在一个地方，但用途非常重要：</p>
<p dir="auto">🎯 使用场景：</p>
<p dir="auto">在 <code>addLiquidity()</code> 中，<strong>第一个提供流动性的人</strong>获得的 LP 代币数量为：</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto"><pre class="notranslate"><code>sqrt(amountA * amountB)

</code></pre></div>
<p dir="auto">这保证了：</p>
<ul dir="auto">
<li>LP 代币供应从一个平衡值开始</li>
<li>结果反映了两个代币添加量的几何平均值</li>
<li>例如你添加了 100 A 和 400 B，你的 LP 代币将基于 √(100×400) = √40000 = 200，而不是简单的总和</li>
</ul>
<p dir="auto">这是一个公平且数学驱动的方式来初始化池子。</p>
<hr>
<p dir="auto">🧠 为什么把这些函数放在合约里？</p>
<ul dir="auto">
<li>它们都是小型<strong>纯函数</strong>（不读/写存储）</li>
<li>内部使用可以保持逻辑整洁</li>
<li>特别是在处理需要保证重要公平的代币数学时，它们有助于避免出错</li>
</ul>
<p dir="auto">我们将在后续函数中使用这些辅助函数。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">💧 7. 添加流动性 – 喂入池子</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> addLiquidity</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amountA</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountB</span>) <span class="pl-k">external</span> {
    <span class="pl-k">require</span>(amountA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> amountB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amounts must be &gt; 0</span>"</span>);

    tokenA.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountA);
    tokenB.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountB);

    <span class="pl-c1">uint256</span> liquidity;
    <span class="pl-k">if</span> (<span class="pl-en">totalSupply</span>() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        liquidity <span class="pl-k">=</span> <span class="pl-en">sqrt</span>(amountA <span class="pl-k">*</span> amountB);
    } <span class="pl-k">else</span> {
        liquidity <span class="pl-k">=</span> <span class="pl-en">min</span>(
            amountA <span class="pl-k">*</span> <span class="pl-en">totalSupply</span>() <span class="pl-k">/</span> reserveA,
            amountB <span class="pl-k">*</span> <span class="pl-en">totalSupply</span>() <span class="pl-k">/</span> reserveB
        );
    }

    <span class="pl-en">_mint</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, liquidity);

    reserveA <span class="pl-k">+=</span> amountA;
    reserveB <span class="pl-k">+=</span> amountB;

    <span class="pl-k">emit</span> <span class="pl-en">LiquidityAdded</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountA, amountB, liquidity);
}
</pre></div>
<hr>
<p dir="auto">🧠 总体思路：</p>
<p dir="auto">这个函数允许用户通过存入等值金额的 Token A 和 Token B 来向池子添加流动性。</p>
<p dir="auto">作为回报，用户会获得 LP 代币（流动性提供者代币），代表Ta们在池子中的份额。</p>
<blockquote>
<p dir="auto">这些 LP 代币就像一张证明你为池子做出了贡献的“收据”，也是你在池子里的代币份额的声明。</p>
</blockquote>
<p dir="auto">第一个添加流动性的人会设定初始价格。</p>
<p dir="auto">之后的每个人必须<strong>按照当前池子的比例</strong>存入代币 —— 以保持价格公平。</p>
<hr>
<p dir="auto">🧩 逐行解析：</p>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ 输入检查</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amountA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> amountB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amounts must be &gt; 0</span>"</span>);
</pre></div>
<p dir="auto">先做一个基本的合理性检查。</p>
<ul dir="auto">
<li>不允许有人存入零个代币。</li>
<li>这样可以保护合约免受奇怪操作影响或避免gas浪费。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 将代币转入池子</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>tokenA.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountA);
tokenB.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountB);
</pre></div>
<p dir="auto">用户将Ta们的代币实际发送到合约。</p>
<ul dir="auto">
<li>我们使用 <code>transferFrom()</code>，因为用户需要先批准合约可以拿走Ta们的代币。</li>
<li>这是标准ERC-20 行为操作 —— 用户必须先调用 <code>approve()</code>。</li>
</ul>
<p dir="auto">也就是说，用户把 <code>amountA</code> 的代币A 和<code>amountB</code> 的代币B给了合约。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📐 计算要铸造的 LP 代币</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> liquidity;
<span class="pl-k">if</span> (<span class="pl-en">totalSupply</span>() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
    liquidity <span class="pl-k">=</span> <span class="pl-en">sqrt</span>(amountA <span class="pl-k">*</span> amountB);
} <span class="pl-k">else</span> {
    liquidity <span class="pl-k">=</span> <span class="pl-en">min</span>(
        amountA <span class="pl-k">*</span> <span class="pl-en">totalSupply</span>() <span class="pl-k">/</span> reserveA,
        amountB <span class="pl-k">*</span> <span class="pl-en">totalSupply</span>() <span class="pl-k">/</span> reserveB
    );
}
</pre></div>
<p dir="auto">这一部分决定了<strong>要给用户多少 LP 代币</strong>。</p>
<ul dir="auto">
<li>如果用户是<strong>第一个添加流动性的人</strong>，池子中还没有 LP 代币：
<ul dir="auto">
<li>那么我们给Ta们：<code>sqrt(amountA * amountB)</code></li>
<li>这是 Uniswap常用的标准公式，用于公平地设定初始 LP 代币数量。</li>
</ul>
</li>
<li>如果池子已经有流动性：
<ul dir="auto">
<li>我们根据<strong>比例贡献</strong>来计算用户应获得的 LP 代币数量。</li>
<li>确保用户按<strong>正确比例</strong>添加流动性。</li>
<li>使用 <code>min()</code> 函数避免当用户输入的代币数量稍有偏差时铸造过多 LP 代币。</li>
</ul>
</li>
</ul>
<blockquote>
<p dir="auto">这保证了每个人在池子中的份额都是公平的。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🖨️ 铸造 LP 代币</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">_mint</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, liquidity);
</pre></div>
<p dir="auto">现在我们把 LP 代币实际发给用户。</p>
<p dir="auto">因为我们的合约继承自 <code>ERC20</code>，可以直接调用 <code>_mint()</code> 来给用户铸造新代币。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📊 更新储备量</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>reserveA <span class="pl-k">+=</span> amountA;
reserveB <span class="pl-k">+=</span> amountB;
</pre></div>
<p dir="auto">更新合约内部状态，反映新加入的代币数量。</p>
<p dir="auto">这是<strong>非常重要的</strong>，因为兑换的数学公式依赖于储备量保持准确。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔔 发出事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">LiquidityAdded</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountA, amountB, liquidity);
</pre></div>
<p dir="auto">记录这一操作，前端和 DApp可以显示用户刚刚做了什么。</p>
<p dir="auto">包括信息：</p>
<ul dir="auto">
<li>谁添加了流动性</li>
<li>添加了多少代币</li>
<li>获得了多少 LP 代币</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧯 8. 移除流动性 – 提取你的份额</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> removeLiquidity</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">liquidityToRemove</span>) <span class="pl-k">external</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span> <span class="pl-v">amountAOut</span>, <span class="pl-c1">uint256</span> <span class="pl-v">amountBOut</span>) {
    <span class="pl-k">require</span>(liquidityToRemove <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Liquidity to remove must be &gt; 0</span>"</span>);
    <span class="pl-k">require</span>(<span class="pl-en">balanceOf</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>) <span class="pl-k">&gt;=</span> liquidityToRemove, <span class="pl-s">"<span class="pl-s">Insufficient liquidity tokens</span>"</span>);

    <span class="pl-c1">uint256</span> totalLiquidity <span class="pl-k">=</span> <span class="pl-en">totalSupply</span>();
    <span class="pl-k">require</span>(totalLiquidity <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">No liquidity in the pool</span>"</span>);

    amountAOut <span class="pl-k">=</span> liquidityToRemove <span class="pl-k">*</span> reserveA <span class="pl-k">/</span> totalLiquidity;
    amountBOut <span class="pl-k">=</span> liquidityToRemove <span class="pl-k">*</span> reserveB <span class="pl-k">/</span> totalLiquidity;

    <span class="pl-k">require</span>(amountAOut <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> amountBOut <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves for requested liquidity</span>"</span>);

    reserveA <span class="pl-k">-=</span> amountAOut;
    reserveB <span class="pl-k">-=</span> amountBOut;

    <span class="pl-en">_burn</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, liquidityToRemove);

    tokenA.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut);
    tokenB.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountBOut);

    <span class="pl-k">emit</span> <span class="pl-en">LiquidityRemoved</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut, amountBOut, liquidityToRemove);
    <span class="pl-k">return</span> (amountAOut, amountBOut);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 总体思路</h3></div>
<p dir="auto">这个函数允许用户<strong>提取自己之前添加的代币份额</strong>。</p>
<p dir="auto">用户需要归还（销毁）Ta们的 <strong>LP 代币</strong>，合约会按比例返回：</p>
<ul dir="auto">
<li>对应比例的 Token A</li>
<li>对应比例的 Token B</li>
</ul>
<p dir="auto">所有计算都是基于Ta们在总流动性池中的份额。</p>
<p dir="auto">例如：如果用户持有 10% 的 LP 代币，Ta们将得到池子中每种代币的 10%。</p>
<p dir="auto">下面逐行解析：</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧩 逐行解析</h3></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ 输入检查</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(liquidityToRemove <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Liquidity to remove must be &gt; 0</span>"</span>);
<span class="pl-k">require</span>(<span class="pl-en">balanceOf</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>) <span class="pl-k">&gt;=</span> liquidityToRemove, <span class="pl-s">"<span class="pl-s">Insufficient liquidity tokens</span>"</span>);
</pre></div>
<ul dir="auto">
<li>首先确保用户想移除的 LP 代币数量为正</li>
<li>然后确认用户<strong>拥有</strong>足够的 LP 代币</li>
<li><code>balanceOf(msg.sender)</code> 用于检查用户持有的 LP 代币数量</li>
</ul>
<p dir="auto">这样可以保护合约免受无效或恶意输入的影响。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📊 获取 LP 代币总量</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> totalLiquidity <span class="pl-k">=</span> <span class="pl-en">totalSupply</span>();
<span class="pl-k">require</span>(totalLiquidity <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">No liquidity in the pool</span>"</span>);
</pre></div>
<ul dir="auto">
<li>获取 LP 代币 <strong>总供应量</strong>，这代表池子 100% 的所有权</li>
<li>如果总供应量为零，阻止交易 —— 因为没有流动性可提取</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 计算要返回的代币数量</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>amountAOut <span class="pl-k">=</span> liquidityToRemove <span class="pl-k">*</span> reserveA <span class="pl-k">/</span> totalLiquidity;
amountBOut <span class="pl-k">=</span> liquidityToRemove <span class="pl-k">*</span> reserveB <span class="pl-k">/</span> totalLiquidity;
</pre></div>
<p dir="auto">这里是魔法发生之处。</p>
<p dir="auto">使用简单的比例计算用户应获得多少代币：</p>
<blockquote>
<p dir="auto">用户的 LP 份额 × 代币总储备 = 提取数量</p>
</blockquote>
<p dir="auto">例如：如果用户持有 25% 的 LP 代币，Ta们将获得池中 25% 的 Token A 和 Token B。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">⛔ 最终合理性检查</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amountAOut <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> amountBOut <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves for requested liquidity</span>"</span>);
</pre></div>
<p dir="auto">防止计算因四舍五入出现灰尘值，如果任何输出为 0，则拒绝交易 —— 避免出错或浪费提款。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧾 更新内部储备量</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>reserveA <span class="pl-k">-=</span> amountAOut;
reserveB <span class="pl-k">-=</span> amountBOut;
</pre></div>
<p dir="auto">从内部储备中扣除提取的代币数量。</p>
<p dir="auto">这样使兑换数学公式保持正确，因为每笔交易都依赖储备量的准确性。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔥 销毁 LP 代币</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-en">_burn</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, liquidityToRemove);
</pre></div>
<p dir="auto">由于用户归还 LP 代币以换取实际代币，我们会<strong>销毁</strong>这些 LP 代币 —— 实际上是删除它们的存在。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 将代币转回给用户</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>tokenA.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut);
tokenB.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountBOut);
</pre></div>
<p dir="auto">这些操作将代币实际发送给用户：</p>
<ul dir="auto">
<li>用户获得<code>amountAOut</code> 个代币A</li>
<li>用户获得<code>amountBOut</code> 个 代币B</li>
</ul>
<p dir="auto">所有这些操作由合约自动处理。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔔 发出事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">LiquidityRemoved</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut, amountBOut, liquidityToRemove);
</pre></div>
<p dir="auto">记录操作到区块链上，方便 DApp、浏览器或索引器监听捕获。</p>
<p dir="auto">包括信息：</p>
<ul dir="auto">
<li>谁提取了流动性</li>
<li>提取了多少代币</li>
<li>销毁了多少 LP 代币</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📤 返回输出</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">return</span> (amountAOut, amountBOut);
</pre></div>
<p dir="auto">返回代币数量，方便调用者（可能是合约或前端）显示结果。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔄 9. 用 A 交换 B</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> swapAforB</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amountAIn</span>, <span class="pl-c1">uint256</span> <span class="pl-v">minBOut</span>) <span class="pl-k">external</span> {
    <span class="pl-k">require</span>(amountAIn <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amount must be &gt; 0</span>"</span>);
    <span class="pl-k">require</span>(reserveA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> reserveB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves</span>"</span>);

    <span class="pl-c1">uint256</span> amountAInWithFee <span class="pl-k">=</span> amountAIn <span class="pl-k">*</span> <span class="pl-c1">997</span> <span class="pl-k">/</span> <span class="pl-c1">1000</span>;
    <span class="pl-c1">uint256</span> amountBOut <span class="pl-k">=</span> reserveB <span class="pl-k">*</span> amountAInWithFee <span class="pl-k">/</span> (reserveA <span class="pl-k">+</span> amountAInWithFee);

    <span class="pl-k">require</span>(amountBOut <span class="pl-k">&gt;=</span> minBOut, <span class="pl-s">"<span class="pl-s">Slippage too high</span>"</span>);

    tokenA.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountAIn);
    tokenB.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountBOut);

    reserveA <span class="pl-k">+=</span> amountAInWithFee;
    reserveB <span class="pl-k">-=</span> amountBOut;

    <span class="pl-k">emit</span> <span class="pl-en">TokensSwapped</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(tokenA), amountAIn, <span class="pl-c1">address</span>(tokenB), amountBOut);
}
</pre></div>
<p dir="auto">假设你在 DEX 上想用 代币<strong>A</strong> 换 代币<strong>B</strong> —— 就像用 ETH 换 DAI。</p>
<p dir="auto">在中心化交易所，会有匹配引擎帮你配对售卖 DAI 的用户。</p>
<p dir="auto">而在这里没有卖家，凭借着数学公式计算，你直接和<strong>智能合约</strong>交易。</p>
<p dir="auto">此函数允许用户：</p>
<ul dir="auto">
<li>发送一些 <code>Token A</code> 给合约</li>
<li>自动获得对应数量的 <code>Token B</code></li>
<li>合约更新内部储备量以反映交换</li>
</ul>
<p dir="auto">但如何计算出正确价格呢？</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">⚙️ 核心思想：恒定乘积公式</h3></div>
<blockquote>
<p dir="auto">x * y = k</p>
</blockquote>
<p dir="auto">这是每个 Uniswap v2 风格的AMM 的公式。</p>
<ul dir="auto">
<li><code>x</code>：合约中 Token A 的数量</li>
<li><code>y</code>：合约中 Token B 的数量</li>
<li><code>k</code>：常数 —— 两者的乘积</li>
</ul>
<p dir="auto">当有人向池子添加 Token A，池子必须返还<strong>恰好数量的 Token B</strong>，保持 <code>x * y</code> 恒定（考虑到滑点和手续费现象，也可以非常接近恒定）。</p>
<p dir="auto">这意味着：<strong>你尝试交换的次数越多，你的兑换率越差</strong> —— 因为你推动了价格曲线。</p>
<p dir="auto">这种设计保持池子平衡，防止人为操纵，并根据供需自动调整价格。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧩 逐行解析</h3></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ 第 1 步：合理性检查</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amountAIn <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amount must be &gt; 0</span>"</span>);
<span class="pl-k">require</span>(reserveA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> reserveB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves</span>"</span>);
</pre></div>
<ul dir="auto">
<li>确保用户输入数量大于 0</li>
<li>确保池子有足够流动性，两种代币都必须有存量</li>
</ul>
<p dir="auto">若不满足其一，则提前停止交易并<strong>节省 gas</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧮 第 2 步：收取 0.3% 手续费</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> amountAInWithFee <span class="pl-k">=</span> amountAIn <span class="pl-k">*</span> <span class="pl-c1">997</span> <span class="pl-k">/</span> <span class="pl-c1">1000</span>;
</pre></div>
<p dir="auto">从输入代币中扣除 <strong>0.3% 手续费。</strong></p>
<ul dir="auto">
<li>比如输入 100 Token A，只用 99.7 参与交换</li>
<li>剩余的 0.3 保留在池子里，奖励流动性提供者</li>
</ul>
<p dir="auto">这个小额手续费可以防止滥用（如掉期合约），并让池子随时间增长，这有利于 LP。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔢 第 3 步：计算获得多少 Token B</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> amountBOut <span class="pl-k">=</span> reserveB <span class="pl-k">*</span> amountAInWithFee <span class="pl-k">/</span> (reserveA <span class="pl-k">+</span> amountAInWithFee);
</pre></div>
<ul dir="auto">
<li>计算用户投入<strong>代币A</strong>应获得的<strong>代币B</strong>数量</li>
<li><code>reserveA</code>：交换前池中 Token A 数量</li>
<li><code>amountAInWithFee</code>：扣除手续费后的新增 Token A数量</li>
<li>代码中的公式确保<strong>交易后</strong> <code>x * y = k</code> 大致保持不变</li>
</ul>
<p dir="auto">你投入越多，<strong>你每单位获得越少</strong>，因为这推动了价格曲线，这就是<strong>价格滑点</strong>。</p>
<p dir="auto">所以这很公平。它是自动的，无需人工定价。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🛡️ 第 4 步：滑点保护</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amountBOut <span class="pl-k">&gt;=</span> minBOut, <span class="pl-s">"<span class="pl-s">Slippage too high</span>"</span>);
</pre></div>
<p dir="auto">再继续深入之前，我们先检查<strong>实际输出</strong>是否符合用户期望。</p>
<ul dir="auto">
<li><code>minBOut</code> 是用户设置的最小可接受 Token B 数量，Ta们想表达的是：</li>
</ul>
<blockquote>
<p dir="auto">“只有当我至少获得x个代币B时，我才会进行交换。”</p>
</blockquote>
<p dir="auto">若计算结果低于x值，则交易回滚，防止<strong>意外价格波动的影响</strong></p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔄 第 5 步：转账代币</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>tokenA.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountAIn);
tokenB.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountBOut);
</pre></div>
<ul dir="auto">
<li>合约从用户钱包<strong>收取</strong>Token A。（前提是用户<code>approve()</code> 批准了合约这样做）</li>
<li>然后合约发送对应数量的 Token B 给用户。</li>
</ul>
<p dir="auto">无需订单簿，无需交易对手，只靠数学计算。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📊 第 6 步：更新储备量</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>reserveA <span class="pl-k">+=</span> amountAInWithFee;
reserveB <span class="pl-k">-=</span> amountBOut;
</pre></div>
<p dir="auto">更新合约持有代币数量的记录，记录每种代币还有多少。</p>
<blockquote>
<p dir="auto">为什么只加 amountAInWithFee 到 reserveA？</p>
<p dir="auto">因为手续费部分不参与下一笔交易的逻辑 —— 它留作奖励。</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔔 第 7 步：发出事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">TokensSwapped</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(tokenA), amountAIn, <span class="pl-c1">address</span>(tokenB), amountBOut);
</pre></div>
<p dir="auto">记录交易信息，让 DApp 或前端显示给用户：</p>
<ul dir="auto">
<li>谁进行了交换</li>
<li>涉及哪些代币</li>
<li>交换数量</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🔁 10. 用 B 交换 A —— 反向交易</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> swapBforA</span></span>(<span class="pl-c1">uint256</span> <span class="pl-v">amountBIn</span>, <span class="pl-c1">uint256</span> <span class="pl-v">minAOut</span>) <span class="pl-k">external</span> {
    <span class="pl-k">require</span>(amountBIn <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amount must be &gt; 0</span>"</span>);
    <span class="pl-k">require</span>(reserveA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> reserveB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves</span>"</span>);

    <span class="pl-c1">uint256</span> amountBInWithFee <span class="pl-k">=</span> amountBIn <span class="pl-k">*</span> <span class="pl-c1">997</span> <span class="pl-k">/</span> <span class="pl-c1">1000</span>;
    <span class="pl-c1">uint256</span> amountAOut <span class="pl-k">=</span> reserveA <span class="pl-k">*</span> amountBInWithFee <span class="pl-k">/</span> (reserveB <span class="pl-k">+</span> amountBInWithFee);

    <span class="pl-k">require</span>(amountAOut <span class="pl-k">&gt;=</span> minAOut, <span class="pl-s">"<span class="pl-s">Slippage too high</span>"</span>);

    tokenB.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountBIn);
    tokenA.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut);

    reserveB <span class="pl-k">+=</span> amountBInWithFee;
    reserveA <span class="pl-k">-=</span> amountAOut;

    <span class="pl-k">emit</span> <span class="pl-en">TokensSwapped</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(tokenB), amountBIn, <span class="pl-c1">address</span>(tokenA), amountAOut);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 作用是什么？</h3></div>
<p dir="auto">这个函数是 <code>swapAforB()</code> 的 <strong>镜像版本</strong>。</p>
<p dir="auto">它允许用户将 <strong>Token B</strong> 交换进池子，并获得 <strong>Token A</strong> — 遵循<strong>相同的定价逻辑</strong>、同样的<strong>常数乘积公式</strong> 和 <strong>0.3% 手续费</strong>。</p>
<p dir="auto">一切都只是“翻转”而已。</p>
<p dir="auto">如果你把 <code>Token A</code> 看作 ETH，把 <code>Token B</code> 看作 DAI，这就是一个用 DAI <strong>购买 ETH</strong> 的路径。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧩 逐行解析</h3></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ 步骤 1：输入检查</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amountBIn <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Amount must be &gt; 0</span>"</span>);
<span class="pl-k">require</span>(reserveA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> reserveB <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>, <span class="pl-s">"<span class="pl-s">Insufficient reserves</span>"</span>);
</pre></div>
<p dir="auto">和之前一样：</p>
<ul dir="auto">
<li>确保输入不为零。</li>
<li>确保池子中两种代币都有足够的流动性以完成交换。</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💸 步骤 2：应用 0.3% 手续费</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> amountBInWithFee <span class="pl-k">=</span> amountBIn <span class="pl-k">*</span> <span class="pl-c1">997</span> <span class="pl-k">/</span> <span class="pl-c1">1000</span>;
</pre></div>
<p dir="auto">同样地，我们在计算输出之前，从输入中减去 <strong>0.3% 的手续费</strong>。</p>
<p dir="auto">这保证了交易公平，并随着时间推移<strong>为流动性提供者产生奖励</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📐 步骤 3：常数乘积计算（B ➜ A）</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c1">uint256</span> amountAOut <span class="pl-k">=</span> reserveA <span class="pl-k">*</span> amountBInWithFee <span class="pl-k">/</span> (reserveB <span class="pl-k">+</span> amountBInWithFee);
</pre></div>
<p dir="auto">使用相同的常数乘积公式：</p>
<blockquote>
<p dir="auto">x * y = k 必须保持（大致）不变。</p>
</blockquote>
<p dir="auto">但现在：</p>
<ul dir="auto">
<li><code>reserveB</code> 是当前的 Token B 数量</li>
<li><code>amountBInWithFee</code> 是我们加入的量</li>
<li><code>reserveA</code> 用于计算需要发放多少 Token A</li>
</ul>
<p dir="auto">这个计算<strong>自动根据池子余额调整汇率</strong>。交易量越大，价格变化越明显 — 这叫做<strong>价格影响（price impact）</strong> 或 <strong>滑点（slippage）</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🛡️ 步骤 4：滑点检查</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">require</span>(amountAOut <span class="pl-k">&gt;=</span> minAOut, <span class="pl-s">"<span class="pl-s">Slippage too high</span>"</span>);
</pre></div>
<p dir="auto">这一行代码<strong>保护用户</strong>。</p>
<p dir="auto">用户指定了 <code>minAOut</code> — Ta们期望收到的最少 Token A 数量。</p>
<p dir="auto">如果池子状态变化太大，导致实际输出低于预期，交易会被取消。</p>
<p dir="auto">避免意外支付和损失。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔁 步骤 5：执行交换</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>tokenB.<span class="pl-en">transferFrom</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(<span class="pl-mi">this</span>), amountBIn);
tokenA.<span class="pl-en">transfer</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, amountAOut);
</pre></div>
<ul dir="auto">
<li>合约<strong>收取</strong>用户的 Token B。</li>
<li>然后<strong>发送</strong>计算好的 Token A 给用户。</li>
</ul>
<p dir="auto">交换完成 — 完全无需许可。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">📊 步骤 6：更新储备</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre>reserveB <span class="pl-k">+=</span> amountBInWithFee;
reserveA <span class="pl-k">-=</span> amountAOut;
</pre></div>
<p dir="auto">更新我们对池子内代币数量的内部记录。</p>
<p dir="auto">注意：</p>
<ul dir="auto">
<li>只有 <strong>扣除手续费后的金额</strong> 计入储备量（代币B）。</li>
<li>用户收到的确切金额从要换取的代币储备量（代币A）中减去。</li>
</ul>
<p dir="auto">这很重要 — 未来的交易都依赖这些储备数量 <strong>100% 准确</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔔 步骤 7：触发事件</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">emit</span> <span class="pl-en">TokensSwapped</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">address</span>(tokenB), amountBIn, <span class="pl-c1">address</span>(tokenA), amountAOut);
</pre></div>
<p dir="auto">记录完整的交易事件：</p>
<ul dir="auto">
<li>谁交易了</li>
<li>哪些代币参与</li>
<li>输入输出数量</li>
</ul>
<p dir="auto">前端可以使用这些信息即时显示给用户，例如：</p>
<blockquote>
<p dir="auto">“你用 50 DAI 换取了 0.027 ETH。”</p>
</blockquote>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 这些操作为什么重要</h3></div>
<p dir="auto"><code>swapAforB()</code> 和 <code>swapBforA()</code> 搭配，使 AMM 成为 <strong>功能完整的去中心化交易所</strong>。</p>
<ul dir="auto">
<li>无需匹配引擎</li>
<li>无需市场做市商</li>
<li>无需守门人</li>
</ul>
<p dir="auto">只是依靠存粹和开放的数学。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧐 11. 查看储备 – 公开池子状态</h2></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> getReserves</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span>, <span class="pl-c1">uint256</span>) {
    <span class="pl-k">return</span> (reserveA, reserveB);
}
</pre></div>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 这个函数的意义</h3></div>
<p dir="auto">它用于<strong>公开池子的当前状态</strong> — 具体来说，合约当前持有多少 <strong>Token A</strong> 和 <strong>Token B</strong>（即流动性储备）。</p>
<ul dir="auto">
<li>不会修改任何数据</li>
<li>外部调用不消耗 gas</li>
<li>仅返回<strong>两个数值</strong>：每个代币的当前储备</li>
</ul>
<p dir="auto">这些数字对于：</p>
<ul dir="auto">
<li>前端应用（如 DEX UI）</li>
<li>钱包集成</li>
<li>数据分析仪表板</li>
<li>任何想显示价格或流动性信息的人</li>
</ul>
<p dir="auto">都<strong>非常重要</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔍 逐行解析</h3></div>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">声明：</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">function<span class="pl-en"> getReserves</span></span>() <span class="pl-k">external</span> <span class="pl-k">view</span> <span class="pl-k">returns</span> (<span class="pl-c1">uint256</span>, <span class="pl-c1">uint256</span>)
</pre></div>
<ul dir="auto">
<li><code>external</code>：函数<strong>供合约外部调用</strong>，如前端</li>
<li><code>view</code>：告诉 Solidity<strong>我们不修改任何状态</strong>，仅读取</li>
<li><code>returns (uint256, uint256)</code>：返回两个值 — 分别对应 Token A 和 Token B</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">返回语句：</h3></div>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-k">return</span> (reserveA, reserveB);
</pre></div>
<ul dir="auto">
<li><code>reserveA</code> 是池子内 Token A 的数量</li>
<li><code>reserveB</code> 是池子内 Token B 的数量</li>
</ul>
<p dir="auto">简单、清晰、一目了然。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🖥️ 前端为何喜欢这个函数</h3></div>
<p dir="auto">想象你在 DEX 网站上准备交易。</p>
<p dir="auto">前端需要显示：</p>
<ul dir="auto">
<li>可用流动性</li>
<li>当前价格比率</li>
<li>你的交易量相对于池子的比例（用以估算滑点）</li>
</ul>
<p dir="auto">要做到这些，前端必须读取<strong>当前储备</strong> — 这个函数让操作变得简单。</p>
<p dir="auto">没有它，前端需要手动追踪每个事件并尝试推测状态 — 容易出错且效率低。</p>
<hr>
<p dir="auto">这就是去中心化交易所的核心逻辑。</p>
<p dir="auto">你现在理解了：</p>
<ul dir="auto">
<li>交易如何计算</li>
<li>流动性如何运作</li>
<li>LP 代币如何代表所有权</li>
</ul>
<p dir="auto">接下来：我们来测试一下，添加代币，并进行第一次交易。</p>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🧪 在 Remix 上测试你的 AMM 合约</h2></div>
<p dir="auto">你已经构建了一个强大的 AMM 合约 — 现在来看看它的运行效果。</p>
<p dir="auto">要正确测试，你需要：</p>
<ol dir="auto">
<li>两个基础 ERC-20 代币合约（Token A 和 Token B）</li>
<li>你的 <code>AutomatedMarketMaker</code> 合约</li>
<li>一些简单的批准和交易操作</li>
</ol>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧱 步骤 1：创建两个 ERC-20 代币</h3></div>
<p dir="auto">在 <a href="https://remix.ethereum.org/" rel="nofollow">Remix</a> 创建一个名为：</p>
<p dir="auto"><strong><code>TokenA.sol</code></strong> 的新文件，在里面粘贴这个简单 ERC-20 合约：</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">// SPDX-License-Identifier: MIT</span>
<span class="pl-k">pragma solidity</span> <span class="pl-k">^</span><span class="pl-c1">0.8.20</span>;

<span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/token/ERC20/ERC20.sol</span>"</span>;

<span class="pl-k">contract</span> <span class="pl-en">TokenA</span> <span class="pl-k">is</span> <span class="pl-en">ERC20</span> {
    <span class="pl-k">constructor</span>() <span class="pl-c1">ERC20</span>(<span class="pl-s">"<span class="pl-s">Token A</span>"</span>, <span class="pl-s">"<span class="pl-s">TKA</span>"</span>) {
        <span class="pl-en">_mint</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">1000000</span> <span class="pl-k">*</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> <span class="pl-en">decimals</span>()); <span class="pl-c">// 铸造 100 万代币给你</span>
    }
}
</pre></div>
<p dir="auto">然后创建第二个文件：</p>
<p dir="auto"><strong><code>TokenB.sol</code></strong></p>
<p dir="auto">粘贴：</p>
<div class="highlight highlight-source-solidity notranslate position-relative overflow-auto" dir="auto"><pre><span class="pl-c">// SPDX-License-Identifier: MIT</span>
<span class="pl-k">pragma solidity</span> <span class="pl-k">^</span><span class="pl-c1">0.8.20</span>;

<span class="pl-k">import</span> <span class="pl-s">"<span class="pl-s">@openzeppelin/contracts/token/ERC20/ERC20.sol</span>"</span>;

<span class="pl-k">contract</span> <span class="pl-en">TokenB</span> <span class="pl-k">is</span> <span class="pl-en">ERC20</span> {
    <span class="pl-k">constructor</span>() <span class="pl-c1">ERC20</span>(<span class="pl-s">"<span class="pl-s">Token B</span>"</span>, <span class="pl-s">"<span class="pl-s">TKB</span>"</span>) {
        <span class="pl-en">_mint</span>(<span class="pl-c1">msg</span>.<span class="pl-c1">sender</span>, <span class="pl-c1">1000000</span> <span class="pl-k">*</span> <span class="pl-c1">10</span> <span class="pl-k">**</span> <span class="pl-en">decimals</span>());
    }
}
</pre></div>
<p dir="auto">✅ <strong>使用 Solidity 编译器编译两个合约</strong>。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧠 步骤 2：部署两个代币</h3></div>
<p dir="auto">切换到 <strong>Deploy &amp; Run</strong> 标签页：</p>
<ul dir="auto">
<li>环境：<code>Remix VM (London)</code></li>
<li>部署 <code>TokenA</code></li>
<li>部署 <code>TokenB</code></li>
</ul>
<p dir="auto">现在你有两个代币，每个代币供应量为 100 万。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💧 步骤 3：部署你的 AMM 合约</h3></div>
<p dir="auto">新建文件 <strong><code>AutomatedMarketMaker.sol</code></strong>，</p>
<p dir="auto">粘贴你完整的 AMM 合约。</p>
<p dir="auto">然后在 Deploy 选项卡输入：</p>
<ul dir="auto">
<li><code>_tokenA</code>：填入部署的 <code>TokenA</code> 地址</li>
<li><code>_tokenB</code>：填入部署的 <code>TokenB</code> 地址</li>
<li><code>_name</code>：例如 <code>"Liquidity Pool Token"</code></li>
<li><code>_symbol</code>：例如 <code>"LPT"</code></li>
</ul>
<p dir="auto">👉 点击 <strong>Deploy</strong> — AMM 合约已上线。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ 步骤 4：批准代币转移</h3></div>
<p dir="auto">在 AMM 挪动你的代币前，你必须授予<strong>权限</strong>。</p>
<p dir="auto">ERC-20 代币不会允许任何人随意转移你的代币 — 你必须调用 <code>approve()</code> 授权 AMM。</p>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">对于Token A：</h3></div>
<ol dir="auto">
<li>复制 AMM 合约地址</li>
<li>打开已部署的 <code>TokenA</code> 合约</li>
<li>调用 <code>approve(address spender, uint amount)</code>
<ul dir="auto">
<li><code>spender</code>：粘贴 AMM 合约地址</li>
<li><code>amount</code>：大一点，例如 <code>1000000000000000000000</code>（1000 代币，18 位小数）</li>
</ul>
</li>
</ol>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">对于Token B：</h3></div>
<p dir="auto">对 <code>TokenB</code> 合约做与上面同样的操作。</p>
<p dir="auto">✅ 现在 AMM 合约被授权代表你挪动你的代币了。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">💧 步骤 5：添加流动性</h3></div>
<p dir="auto">现在将代币添加进池中。</p>
<ol dir="auto">
<li>打开已部署的 AMM 合约</li>
<li>调用 <code>addLiquidity(uint256 amountA, uint256 amountB)</code>
<ul dir="auto">
<li>代币使用 18 位小数：
<ul dir="auto">
<li>100 代币 = <code>100000000000000000000</code>（在原来基础上添加18个0）</li>
</ul>
</li>
<li>为两种代币试试 <code>100 * 10^18</code> 这种表示形式</li>
</ul>
</li>
</ol>
<p dir="auto">完成后：</p>
<ul dir="auto">
<li>你正式添加了流动性</li>
<li>LP 代币会铸造到你的地址</li>
<li>会触发一个事件</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔁 步骤 6：尝试代币交换</h3></div>
<p dir="auto">假设你想用 10 Token A 换 Token B：</p>
<ol dir="auto">
<li>再次批准 AMM 使用 10 Token A（如果之前没批准）</li>
<li>调用 <code>swapAforB(uint256 amountAIn, uint256 minBOut)</code>
<ul dir="auto">
<li><code>amountAIn</code>：<code>10000000000000000000</code>（10 代币A）</li>
<li><code>minBOut</code>：先填类似 <code>1</code> 的选择，避免交易失败</li>
</ul>
</li>
</ol>
<p dir="auto">调用后：</p>
<ul dir="auto">
<li>你会收到 Token B</li>
<li>AMM 内部储备更新</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔁 反向交换：Token B → Token A</h3></div>
<p dir="auto">同理，操作反向：</p>
<ol dir="auto">
<li>批准 AMM 使用一定数量的 Token B</li>
<li>调用 <code>swapBforA(amountBIn, minAOut)</code></li>
</ol>
<p dir="auto">✅ 成功 — 你用自己写的 AMM 完成了交易。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🔙 步骤 7：移除流动性</h3></div>
<ol dir="auto">
<li>使用 <code>balanceOf(你的地址)</code> 查看 LP 代币余额</li>
<li>调用 <code>removeLiquidity(uint liquidityToRemove)</code></li>
<li>你将收回相应份额的 Token A 和 B</li>
</ol>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧪 小技巧：观察事件</h3></div>
<p dir="auto">会看到类似日志：</p>
<ul dir="auto">
<li><code>LiquidityAdded</code></li>
<li><code>TokensSwapped</code></li>
<li><code>LiquidityRemoved</code></li>
</ul>
<p dir="auto">帮助你验证操作 — 也是前端用来更新 UI 的依据。</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ 你做到了</h3></div>
<p dir="auto">你现在已经：</p>
<ul dir="auto">
<li>部署了两个 ERC-20 代币</li>
<li>构建并测试了自己的 AMM</li>
<li>使用数学逻辑完成代币交换，而非依赖做市商</li>
<li>成为自己 DEX 的首位流动性提供者</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h2 tabindex="-1" class="heading-element" dir="auto">🎉 总结 — 你刚刚构建了一个DEX 引擎</h2></div>
<p dir="auto">稍微停一下，感受一下你的成就。</p>
<p dir="auto">你不仅写了一个 Solidity 合约 —</p>
<p dir="auto">你构建了<strong>驱动 Uniswap、SushiSwap 等 DeFi 平台的核心引擎</strong>。</p>
<p dir="auto">回顾你完成的内容：</p>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✅ 学到了 AMM 核心</h3></div>
<ul dir="auto">
<li>为什么传统交易方式（订单簿）无法链上使用</li>
<li>AMM 如何通过简单数学公式 <code>x * y = k</code> 改变游戏规则</li>
<li>流动性池如何运作以及 LP 代币的重要性</li>
<li>价格发现、滑点和手续费如何内置在数学逻辑中</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">✍️ 编写了完整智能合约逻辑</h3></div>
<ul dir="auto">
<li>从零创建基于 ERC-20 的 AMM</li>
<li>支持 <strong>交换</strong>、<strong>添加</strong>、<strong>移除流动性</strong></li>
<li>处理 LP 代币铸造、手续费逻辑和储备追踪</li>
<li>使用 <code>sqrt()</code> 和 <code>min()</code> 等<strong>工具函数</strong>保证公平和节省 gas</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🧪 在 Remix 上运行</h3></div>
<ul dir="auto">
<li>部署两个代币</li>
<li>启动 AMM</li>
<li>批准代币转移</li>
<li>添加流动性</li>
<li>执行真实代币交易</li>
<li>实时观察所有变化更新</li>
</ul>
<hr>
<div class="markdown-heading" dir="auto"><h3 tabindex="-1" class="heading-element" dir="auto">🎯 你构建了什么</h3></div>
<p dir="auto">你不仅理解了<strong>AMM 如何运作</strong>……</p>
<p dir="auto">还真正<strong>亲手构建了一个AMM</strong> — 这种技能在 Web3 世界中非常抢眼。</p>
<p dir="auto">你写了一个自包含、自维持的智能合约，它可以：</p>
<ul dir="auto">
<li>管理流动性</li>
<li>计算公平交换价格</li>
<li>保持池子平衡</li>
<li>永久在链上运行</li>
</ul>
<p dir="auto">无需中间人、无需权限控制。纯粹代码 + 数学。</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/solidity.min.js"></script>
    <script>
        hljs.highlightAll();
        
        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
            
        // Sneha的一封来信模块功能
        document.addEventListener('DOMContentLoaded', function() {
            const envelopeContainer = document.getElementById('envelope-container');
            const answerModal = document.getElementById('answer-modal');
            const closeLetter = document.getElementById('close-letter');
            
            if (!envelopeContainer || !answerModal || !closeLetter) {
                return; // 如果元素不存在，直接返回
            }
            
            // 点击信封打开弹窗
            envelopeContainer.addEventListener('click', function() {
                envelopeContainer.classList.add('open');
                
                // 延迟显示弹窗，让信封翻转动画完成
                setTimeout(function() {
                    answerModal.style.display = 'flex';
                    setTimeout(function() {
                        answerModal.classList.add('open');
                    }, 50);
                }, 400);
            });
            
            // 关闭弹窗
            closeLetter.addEventListener('click', function() {
                answerModal.classList.remove('open');
                
                setTimeout(function() {
                    answerModal.style.display = 'none';
                    envelopeContainer.classList.remove('open');
                }, 600);
            });
            
            // 点击弹窗外部关闭
            answerModal.addEventListener('click', function(e) {
                if (e.target === answerModal) {
                    closeLetter.click();
                }
            });
        });
    </script>
</body>
</html>
